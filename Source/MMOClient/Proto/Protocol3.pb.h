// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol3.proto

#pragma warning(disable:4800)

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol3_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol3_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol3_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol3_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[49]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol3_2eproto;
namespace PROTOCOL {
class C_AddItem;
struct C_AddItemDefaultTypeInternal;
extern C_AddItemDefaultTypeInternal _C_AddItem_default_instance_;
class C_AddQuest;
struct C_AddQuestDefaultTypeInternal;
extern C_AddQuestDefaultTypeInternal _C_AddQuest_default_instance_;
class C_Chat;
struct C_ChatDefaultTypeInternal;
extern C_ChatDefaultTypeInternal _C_Chat_default_instance_;
class C_CompleteQuest;
struct C_CompleteQuestDefaultTypeInternal;
extern C_CompleteQuestDefaultTypeInternal _C_CompleteQuest_default_instance_;
class C_CreatePlayer;
struct C_CreatePlayerDefaultTypeInternal;
extern C_CreatePlayerDefaultTypeInternal _C_CreatePlayer_default_instance_;
class C_Enter_Room;
struct C_Enter_RoomDefaultTypeInternal;
extern C_Enter_RoomDefaultTypeInternal _C_Enter_Room_default_instance_;
class C_EquipItem;
struct C_EquipItemDefaultTypeInternal;
extern C_EquipItemDefaultTypeInternal _C_EquipItem_default_instance_;
class C_Leave_Room;
struct C_Leave_RoomDefaultTypeInternal;
extern C_Leave_RoomDefaultTypeInternal _C_Leave_Room_default_instance_;
class C_Login;
struct C_LoginDefaultTypeInternal;
extern C_LoginDefaultTypeInternal _C_Login_default_instance_;
class C_Move;
struct C_MoveDefaultTypeInternal;
extern C_MoveDefaultTypeInternal _C_Move_default_instance_;
class C_RemoveQuest;
struct C_RemoveQuestDefaultTypeInternal;
extern C_RemoveQuestDefaultTypeInternal _C_RemoveQuest_default_instance_;
class C_Skill;
struct C_SkillDefaultTypeInternal;
extern C_SkillDefaultTypeInternal _C_Skill_default_instance_;
class C_Spawn;
struct C_SpawnDefaultTypeInternal;
extern C_SpawnDefaultTypeInternal _C_Spawn_default_instance_;
class C_Test;
struct C_TestDefaultTypeInternal;
extern C_TestDefaultTypeInternal _C_Test_default_instance_;
class C_UpdateQuest;
struct C_UpdateQuestDefaultTypeInternal;
extern C_UpdateQuestDefaultTypeInternal _C_UpdateQuest_default_instance_;
class C_UseItem;
struct C_UseItemDefaultTypeInternal;
extern C_UseItemDefaultTypeInternal _C_UseItem_default_instance_;
class ItemInfo;
struct ItemInfoDefaultTypeInternal;
extern ItemInfoDefaultTypeInternal _ItemInfo_default_instance_;
class LobbyPlayerInfo;
struct LobbyPlayerInfoDefaultTypeInternal;
extern LobbyPlayerInfoDefaultTypeInternal _LobbyPlayerInfo_default_instance_;
class ObjectInfo;
struct ObjectInfoDefaultTypeInternal;
extern ObjectInfoDefaultTypeInternal _ObjectInfo_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class QuestInfo;
struct QuestInfoDefaultTypeInternal;
extern QuestInfoDefaultTypeInternal _QuestInfo_default_instance_;
class S_AddExp;
struct S_AddExpDefaultTypeInternal;
extern S_AddExpDefaultTypeInternal _S_AddExp_default_instance_;
class S_AddItem;
struct S_AddItemDefaultTypeInternal;
extern S_AddItemDefaultTypeInternal _S_AddItem_default_instance_;
class S_AddQuest;
struct S_AddQuestDefaultTypeInternal;
extern S_AddQuestDefaultTypeInternal _S_AddQuest_default_instance_;
class S_ChangeHp;
struct S_ChangeHpDefaultTypeInternal;
extern S_ChangeHpDefaultTypeInternal _S_ChangeHp_default_instance_;
class S_ChangeStat;
struct S_ChangeStatDefaultTypeInternal;
extern S_ChangeStatDefaultTypeInternal _S_ChangeStat_default_instance_;
class S_Chat;
struct S_ChatDefaultTypeInternal;
extern S_ChatDefaultTypeInternal _S_Chat_default_instance_;
class S_CompleteQuest;
struct S_CompleteQuestDefaultTypeInternal;
extern S_CompleteQuestDefaultTypeInternal _S_CompleteQuest_default_instance_;
class S_CreatePlayer;
struct S_CreatePlayerDefaultTypeInternal;
extern S_CreatePlayerDefaultTypeInternal _S_CreatePlayer_default_instance_;
class S_DeSpawn;
struct S_DeSpawnDefaultTypeInternal;
extern S_DeSpawnDefaultTypeInternal _S_DeSpawn_default_instance_;
class S_Die;
struct S_DieDefaultTypeInternal;
extern S_DieDefaultTypeInternal _S_Die_default_instance_;
class S_Enter_Room;
struct S_Enter_RoomDefaultTypeInternal;
extern S_Enter_RoomDefaultTypeInternal _S_Enter_Room_default_instance_;
class S_EquipItem;
struct S_EquipItemDefaultTypeInternal;
extern S_EquipItemDefaultTypeInternal _S_EquipItem_default_instance_;
class S_ItemList;
struct S_ItemListDefaultTypeInternal;
extern S_ItemListDefaultTypeInternal _S_ItemList_default_instance_;
class S_Leave_Room;
struct S_Leave_RoomDefaultTypeInternal;
extern S_Leave_RoomDefaultTypeInternal _S_Leave_Room_default_instance_;
class S_LevelUp;
struct S_LevelUpDefaultTypeInternal;
extern S_LevelUpDefaultTypeInternal _S_LevelUp_default_instance_;
class S_Login;
struct S_LoginDefaultTypeInternal;
extern S_LoginDefaultTypeInternal _S_Login_default_instance_;
class S_Move;
struct S_MoveDefaultTypeInternal;
extern S_MoveDefaultTypeInternal _S_Move_default_instance_;
class S_QuestList;
struct S_QuestListDefaultTypeInternal;
extern S_QuestListDefaultTypeInternal _S_QuestList_default_instance_;
class S_RemoveItem;
struct S_RemoveItemDefaultTypeInternal;
extern S_RemoveItemDefaultTypeInternal _S_RemoveItem_default_instance_;
class S_RemoveQuest;
struct S_RemoveQuestDefaultTypeInternal;
extern S_RemoveQuestDefaultTypeInternal _S_RemoveQuest_default_instance_;
class S_Skill;
struct S_SkillDefaultTypeInternal;
extern S_SkillDefaultTypeInternal _S_Skill_default_instance_;
class S_Spawn;
struct S_SpawnDefaultTypeInternal;
extern S_SpawnDefaultTypeInternal _S_Spawn_default_instance_;
class S_Test;
struct S_TestDefaultTypeInternal;
extern S_TestDefaultTypeInternal _S_Test_default_instance_;
class S_UpdateItem;
struct S_UpdateItemDefaultTypeInternal;
extern S_UpdateItemDefaultTypeInternal _S_UpdateItem_default_instance_;
class S_UpdateQuest;
struct S_UpdateQuestDefaultTypeInternal;
extern S_UpdateQuestDefaultTypeInternal _S_UpdateQuest_default_instance_;
class S_UseItem;
struct S_UseItemDefaultTypeInternal;
extern S_UseItemDefaultTypeInternal _S_UseItem_default_instance_;
class Skill;
struct SkillDefaultTypeInternal;
extern SkillDefaultTypeInternal _Skill_default_instance_;
class Stat;
struct StatDefaultTypeInternal;
extern StatDefaultTypeInternal _Stat_default_instance_;
}  // namespace PROTOCOL
PROTOBUF_NAMESPACE_OPEN
template<> ::PROTOCOL::C_AddItem* Arena::CreateMaybeMessage<::PROTOCOL::C_AddItem>(Arena*);
template<> ::PROTOCOL::C_AddQuest* Arena::CreateMaybeMessage<::PROTOCOL::C_AddQuest>(Arena*);
template<> ::PROTOCOL::C_Chat* Arena::CreateMaybeMessage<::PROTOCOL::C_Chat>(Arena*);
template<> ::PROTOCOL::C_CompleteQuest* Arena::CreateMaybeMessage<::PROTOCOL::C_CompleteQuest>(Arena*);
template<> ::PROTOCOL::C_CreatePlayer* Arena::CreateMaybeMessage<::PROTOCOL::C_CreatePlayer>(Arena*);
template<> ::PROTOCOL::C_Enter_Room* Arena::CreateMaybeMessage<::PROTOCOL::C_Enter_Room>(Arena*);
template<> ::PROTOCOL::C_EquipItem* Arena::CreateMaybeMessage<::PROTOCOL::C_EquipItem>(Arena*);
template<> ::PROTOCOL::C_Leave_Room* Arena::CreateMaybeMessage<::PROTOCOL::C_Leave_Room>(Arena*);
template<> ::PROTOCOL::C_Login* Arena::CreateMaybeMessage<::PROTOCOL::C_Login>(Arena*);
template<> ::PROTOCOL::C_Move* Arena::CreateMaybeMessage<::PROTOCOL::C_Move>(Arena*);
template<> ::PROTOCOL::C_RemoveQuest* Arena::CreateMaybeMessage<::PROTOCOL::C_RemoveQuest>(Arena*);
template<> ::PROTOCOL::C_Skill* Arena::CreateMaybeMessage<::PROTOCOL::C_Skill>(Arena*);
template<> ::PROTOCOL::C_Spawn* Arena::CreateMaybeMessage<::PROTOCOL::C_Spawn>(Arena*);
template<> ::PROTOCOL::C_Test* Arena::CreateMaybeMessage<::PROTOCOL::C_Test>(Arena*);
template<> ::PROTOCOL::C_UpdateQuest* Arena::CreateMaybeMessage<::PROTOCOL::C_UpdateQuest>(Arena*);
template<> ::PROTOCOL::C_UseItem* Arena::CreateMaybeMessage<::PROTOCOL::C_UseItem>(Arena*);
template<> ::PROTOCOL::ItemInfo* Arena::CreateMaybeMessage<::PROTOCOL::ItemInfo>(Arena*);
template<> ::PROTOCOL::LobbyPlayerInfo* Arena::CreateMaybeMessage<::PROTOCOL::LobbyPlayerInfo>(Arena*);
template<> ::PROTOCOL::ObjectInfo* Arena::CreateMaybeMessage<::PROTOCOL::ObjectInfo>(Arena*);
template<> ::PROTOCOL::Position* Arena::CreateMaybeMessage<::PROTOCOL::Position>(Arena*);
template<> ::PROTOCOL::QuestInfo* Arena::CreateMaybeMessage<::PROTOCOL::QuestInfo>(Arena*);
template<> ::PROTOCOL::S_AddExp* Arena::CreateMaybeMessage<::PROTOCOL::S_AddExp>(Arena*);
template<> ::PROTOCOL::S_AddItem* Arena::CreateMaybeMessage<::PROTOCOL::S_AddItem>(Arena*);
template<> ::PROTOCOL::S_AddQuest* Arena::CreateMaybeMessage<::PROTOCOL::S_AddQuest>(Arena*);
template<> ::PROTOCOL::S_ChangeHp* Arena::CreateMaybeMessage<::PROTOCOL::S_ChangeHp>(Arena*);
template<> ::PROTOCOL::S_ChangeStat* Arena::CreateMaybeMessage<::PROTOCOL::S_ChangeStat>(Arena*);
template<> ::PROTOCOL::S_Chat* Arena::CreateMaybeMessage<::PROTOCOL::S_Chat>(Arena*);
template<> ::PROTOCOL::S_CompleteQuest* Arena::CreateMaybeMessage<::PROTOCOL::S_CompleteQuest>(Arena*);
template<> ::PROTOCOL::S_CreatePlayer* Arena::CreateMaybeMessage<::PROTOCOL::S_CreatePlayer>(Arena*);
template<> ::PROTOCOL::S_DeSpawn* Arena::CreateMaybeMessage<::PROTOCOL::S_DeSpawn>(Arena*);
template<> ::PROTOCOL::S_Die* Arena::CreateMaybeMessage<::PROTOCOL::S_Die>(Arena*);
template<> ::PROTOCOL::S_Enter_Room* Arena::CreateMaybeMessage<::PROTOCOL::S_Enter_Room>(Arena*);
template<> ::PROTOCOL::S_EquipItem* Arena::CreateMaybeMessage<::PROTOCOL::S_EquipItem>(Arena*);
template<> ::PROTOCOL::S_ItemList* Arena::CreateMaybeMessage<::PROTOCOL::S_ItemList>(Arena*);
template<> ::PROTOCOL::S_Leave_Room* Arena::CreateMaybeMessage<::PROTOCOL::S_Leave_Room>(Arena*);
template<> ::PROTOCOL::S_LevelUp* Arena::CreateMaybeMessage<::PROTOCOL::S_LevelUp>(Arena*);
template<> ::PROTOCOL::S_Login* Arena::CreateMaybeMessage<::PROTOCOL::S_Login>(Arena*);
template<> ::PROTOCOL::S_Move* Arena::CreateMaybeMessage<::PROTOCOL::S_Move>(Arena*);
template<> ::PROTOCOL::S_QuestList* Arena::CreateMaybeMessage<::PROTOCOL::S_QuestList>(Arena*);
template<> ::PROTOCOL::S_RemoveItem* Arena::CreateMaybeMessage<::PROTOCOL::S_RemoveItem>(Arena*);
template<> ::PROTOCOL::S_RemoveQuest* Arena::CreateMaybeMessage<::PROTOCOL::S_RemoveQuest>(Arena*);
template<> ::PROTOCOL::S_Skill* Arena::CreateMaybeMessage<::PROTOCOL::S_Skill>(Arena*);
template<> ::PROTOCOL::S_Spawn* Arena::CreateMaybeMessage<::PROTOCOL::S_Spawn>(Arena*);
template<> ::PROTOCOL::S_Test* Arena::CreateMaybeMessage<::PROTOCOL::S_Test>(Arena*);
template<> ::PROTOCOL::S_UpdateItem* Arena::CreateMaybeMessage<::PROTOCOL::S_UpdateItem>(Arena*);
template<> ::PROTOCOL::S_UpdateQuest* Arena::CreateMaybeMessage<::PROTOCOL::S_UpdateQuest>(Arena*);
template<> ::PROTOCOL::S_UseItem* Arena::CreateMaybeMessage<::PROTOCOL::S_UseItem>(Arena*);
template<> ::PROTOCOL::Skill* Arena::CreateMaybeMessage<::PROTOCOL::Skill>(Arena*);
template<> ::PROTOCOL::Stat* Arena::CreateMaybeMessage<::PROTOCOL::Stat>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace PROTOCOL {

enum MsgId : int {
  C_LOGIN = 0,
  S_LOGIN = 1,
  C_ENTER_ROOM = 2,
  S_ENTER_ROOM = 3,
  C_LEAVE_ROOM = 4,
  S_LEAVE_ROOM = 5,
  C_SPAWN = 6,
  S_SPAWN = 7,
  C_DESPAWN = 8,
  S_DESPAWN = 9,
  C_MOVE = 10,
  S_MOVE = 11,
  C_SKILL = 12,
  S_SKILL = 13,
  C_CHAT = 14,
  S_CHAT = 15,
  C_PING = 16,
  S_PONG = 17,
  S_CHANGE_HP = 18,
  S_DIE = 19,
  S_ITEM_LIST = 20,
  C_ADD_ITEM = 21,
  S_ADD_ITEM = 22,
  S_UPDATE_ITEM = 23,
  S_REMOVE_ITEM = 24,
  C_EQUIPITEM = 25,
  S_EQUIPITEM = 26,
  C_USEITEM = 27,
  S_USEITEM = 28,
  S_CHANGE_STAT = 29,
  C_CREATE_PLAYER = 30,
  S_CREATE_PLAYER = 31,
  S_ADD_EXP = 32,
  S_LEVEL_UP = 33,
  C_ADD_QUEST = 34,
  S_ADD_QUEST = 35,
  S_QUEST_LIST = 36,
  C_REMOVE_QUEST = 37,
  S_REMOVE_QUEST = 38,
  C_COMPLETE_QUEST = 39,
  S_COMPLETE_QUEST = 40,
  C_UPDATE_QUEST = 41,
  S_UPDATE_QUEST = 42,
  C_TEST = 43,
  S_TEST = 44,
  MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MsgId_IsValid(int value);
constexpr MsgId MsgId_MIN = C_LOGIN;
constexpr MsgId MsgId_MAX = S_TEST;
constexpr int MsgId_ARRAYSIZE = MsgId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgId_descriptor();
template<typename T>
inline const std::string& MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgId_descriptor(), enum_t_value);
}
inline bool MsgId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgId>(
    MsgId_descriptor(), name, value);
}
enum PlayerServerState : int {
  SERVER_STATE_NONE = 0,
  SERVER_STATE_CONNECTED = 1,
  SERVER_STATE_LOGIN = 2,
  SERVER_STATE_LOBBY = 3,
  SERVER_STATE_GAME = 4,
  PlayerServerState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PlayerServerState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PlayerServerState_IsValid(int value);
constexpr PlayerServerState PlayerServerState_MIN = SERVER_STATE_NONE;
constexpr PlayerServerState PlayerServerState_MAX = SERVER_STATE_GAME;
constexpr int PlayerServerState_ARRAYSIZE = PlayerServerState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerServerState_descriptor();
template<typename T>
inline const std::string& PlayerServerState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerServerState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerServerState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerServerState_descriptor(), enum_t_value);
}
inline bool PlayerServerState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerServerState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerServerState>(
    PlayerServerState_descriptor(), name, value);
}
enum GameObjectType : int {
  NONE = 0,
  PLAYER = 1,
  MONSTER = 2,
  PROJECTILE = 3,
  NPC = 4,
  Object = 5,
  GameObjectType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GameObjectType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GameObjectType_IsValid(int value);
constexpr GameObjectType GameObjectType_MIN = NONE;
constexpr GameObjectType GameObjectType_MAX = Object;
constexpr int GameObjectType_ARRAYSIZE = GameObjectType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameObjectType_descriptor();
template<typename T>
inline const std::string& GameObjectType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GameObjectType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GameObjectType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GameObjectType_descriptor(), enum_t_value);
}
inline bool GameObjectType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GameObjectType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GameObjectType>(
    GameObjectType_descriptor(), name, value);
}
enum SkillType : int {
  SKILL_NONE = 0,
  SKILL_AUTO = 1,
  SKILL_PROJECTTILE = 2,
  SkillType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SkillType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SkillType_IsValid(int value);
constexpr SkillType SkillType_MIN = SKILL_NONE;
constexpr SkillType SkillType_MAX = SKILL_PROJECTTILE;
constexpr int SkillType_ARRAYSIZE = SkillType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SkillType_descriptor();
template<typename T>
inline const std::string& SkillType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SkillType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SkillType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SkillType_descriptor(), enum_t_value);
}
inline bool SkillType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SkillType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SkillType>(
    SkillType_descriptor(), name, value);
}
enum ItemType : int {
  ITEM_TYPE_NONE = 0,
  ITEM_TYPE_WEAPON = 1,
  ITEM_TYPE_ARMOR = 2,
  ITEM_TYPE_CONSUMABLE = 3,
  ItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ItemType_IsValid(int value);
constexpr ItemType ItemType_MIN = ITEM_TYPE_NONE;
constexpr ItemType ItemType_MAX = ITEM_TYPE_CONSUMABLE;
constexpr int ItemType_ARRAYSIZE = ItemType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemType_descriptor();
template<typename T>
inline const std::string& ItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemType_descriptor(), enum_t_value);
}
inline bool ItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemType>(
    ItemType_descriptor(), name, value);
}
enum WeaponType : int {
  WEAPON_TYPE_NONE = 0,
  WEAPON_TYPE_SWORD = 1,
  WEAPON_TYPE_AXE = 2,
  WeaponType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WeaponType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WeaponType_IsValid(int value);
constexpr WeaponType WeaponType_MIN = WEAPON_TYPE_NONE;
constexpr WeaponType WeaponType_MAX = WEAPON_TYPE_AXE;
constexpr int WeaponType_ARRAYSIZE = WeaponType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WeaponType_descriptor();
template<typename T>
inline const std::string& WeaponType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WeaponType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WeaponType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WeaponType_descriptor(), enum_t_value);
}
inline bool WeaponType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WeaponType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WeaponType>(
    WeaponType_descriptor(), name, value);
}
enum ArmorType : int {
  ARMOR_TYPE_NONE = 0,
  ARMOR_TYPE_HELMET = 1,
  ARMOR_TYPE_ARMOR = 2,
  ArmorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ArmorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ArmorType_IsValid(int value);
constexpr ArmorType ArmorType_MIN = ARMOR_TYPE_NONE;
constexpr ArmorType ArmorType_MAX = ARMOR_TYPE_ARMOR;
constexpr int ArmorType_ARRAYSIZE = ArmorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArmorType_descriptor();
template<typename T>
inline const std::string& ArmorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArmorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArmorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ArmorType_descriptor(), enum_t_value);
}
inline bool ArmorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ArmorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ArmorType>(
    ArmorType_descriptor(), name, value);
}
enum ConsumableType : int {
  CONSUMABLE_TYPE_NONE = 0,
  CONSUMABLE_TYPE_HP_POTION = 1,
  CONSUMABLE_TYPE_MP_POTION = 2,
  ConsumableType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConsumableType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConsumableType_IsValid(int value);
constexpr ConsumableType ConsumableType_MIN = CONSUMABLE_TYPE_NONE;
constexpr ConsumableType ConsumableType_MAX = CONSUMABLE_TYPE_MP_POTION;
constexpr int ConsumableType_ARRAYSIZE = ConsumableType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConsumableType_descriptor();
template<typename T>
inline const std::string& ConsumableType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConsumableType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConsumableType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConsumableType_descriptor(), enum_t_value);
}
inline bool ConsumableType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConsumableType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConsumableType>(
    ConsumableType_descriptor(), name, value);
}
// ===================================================================

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  explicit constexpr Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Position& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationxFieldNumber = 1,
    kLocationyFieldNumber = 2,
    kLocationzFieldNumber = 3,
    kRotationyawFieldNumber = 4,
    kRotationpitchFieldNumber = 5,
    kRotationrollFieldNumber = 6,
    kVelocityxFieldNumber = 7,
    kVelocityyFieldNumber = 8,
    kVelocityzFieldNumber = 9,
  };
  // float locationx = 1;
  void clear_locationx();
  float locationx() const;
  void set_locationx(float value);
  private:
  float _internal_locationx() const;
  void _internal_set_locationx(float value);
  public:

  // float locationy = 2;
  void clear_locationy();
  float locationy() const;
  void set_locationy(float value);
  private:
  float _internal_locationy() const;
  void _internal_set_locationy(float value);
  public:

  // float locationz = 3;
  void clear_locationz();
  float locationz() const;
  void set_locationz(float value);
  private:
  float _internal_locationz() const;
  void _internal_set_locationz(float value);
  public:

  // float rotationyaw = 4;
  void clear_rotationyaw();
  float rotationyaw() const;
  void set_rotationyaw(float value);
  private:
  float _internal_rotationyaw() const;
  void _internal_set_rotationyaw(float value);
  public:

  // float rotationpitch = 5;
  void clear_rotationpitch();
  float rotationpitch() const;
  void set_rotationpitch(float value);
  private:
  float _internal_rotationpitch() const;
  void _internal_set_rotationpitch(float value);
  public:

  // float rotationroll = 6;
  void clear_rotationroll();
  float rotationroll() const;
  void set_rotationroll(float value);
  private:
  float _internal_rotationroll() const;
  void _internal_set_rotationroll(float value);
  public:

  // float velocityx = 7;
  void clear_velocityx();
  float velocityx() const;
  void set_velocityx(float value);
  private:
  float _internal_velocityx() const;
  void _internal_set_velocityx(float value);
  public:

  // float velocityy = 8;
  void clear_velocityy();
  float velocityy() const;
  void set_velocityy(float value);
  private:
  float _internal_velocityy() const;
  void _internal_set_velocityy(float value);
  public:

  // float velocityz = 9;
  void clear_velocityz();
  float velocityz() const;
  void set_velocityz(float value);
  private:
  float _internal_velocityz() const;
  void _internal_set_velocityz(float value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.Position)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float locationx_;
  float locationy_;
  float locationz_;
  float rotationyaw_;
  float rotationpitch_;
  float rotationroll_;
  float velocityx_;
  float velocityy_;
  float velocityz_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class Stat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.Stat) */ {
 public:
  inline Stat() : Stat(nullptr) {}
  ~Stat() override;
  explicit constexpr Stat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stat(const Stat& from);
  Stat(Stat&& from) noexcept
    : Stat() {
    *this = ::std::move(from);
  }

  inline Stat& operator=(const Stat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stat& operator=(Stat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stat* internal_default_instance() {
    return reinterpret_cast<const Stat*>(
               &_Stat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Stat& a, Stat& b) {
    a.Swap(&b);
  }
  inline void Swap(Stat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Stat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.Stat";
  }
  protected:
  explicit Stat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 1,
    kTotalExpFieldNumber = 2,
    kExpFieldNumber = 3,
    kMaxhpFieldNumber = 4,
    kHpFieldNumber = 5,
    kDamageFieldNumber = 6,
    kDefenceFieldNumber = 7,
    kSpeedFieldNumber = 8,
    kAttackdistanceFieldNumber = 9,
    kNoticedistanceFieldNumber = 10,
    kReturndistanceFieldNumber = 11,
    kAttackcooltimeFieldNumber = 12,
  };
  // int32 level = 1;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // int32 totalExp = 2;
  void clear_totalexp();
  int32_t totalexp() const;
  void set_totalexp(int32_t value);
  private:
  int32_t _internal_totalexp() const;
  void _internal_set_totalexp(int32_t value);
  public:

  // int32 exp = 3;
  void clear_exp();
  int32_t exp() const;
  void set_exp(int32_t value);
  private:
  int32_t _internal_exp() const;
  void _internal_set_exp(int32_t value);
  public:

  // int32 maxhp = 4;
  void clear_maxhp();
  int32_t maxhp() const;
  void set_maxhp(int32_t value);
  private:
  int32_t _internal_maxhp() const;
  void _internal_set_maxhp(int32_t value);
  public:

  // int32 hp = 5;
  void clear_hp();
  int32_t hp() const;
  void set_hp(int32_t value);
  private:
  int32_t _internal_hp() const;
  void _internal_set_hp(int32_t value);
  public:

  // int32 damage = 6;
  void clear_damage();
  int32_t damage() const;
  void set_damage(int32_t value);
  private:
  int32_t _internal_damage() const;
  void _internal_set_damage(int32_t value);
  public:

  // int32 defence = 7;
  void clear_defence();
  int32_t defence() const;
  void set_defence(int32_t value);
  private:
  int32_t _internal_defence() const;
  void _internal_set_defence(int32_t value);
  public:

  // float speed = 8;
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // float attackdistance = 9;
  void clear_attackdistance();
  float attackdistance() const;
  void set_attackdistance(float value);
  private:
  float _internal_attackdistance() const;
  void _internal_set_attackdistance(float value);
  public:

  // float noticedistance = 10;
  void clear_noticedistance();
  float noticedistance() const;
  void set_noticedistance(float value);
  private:
  float _internal_noticedistance() const;
  void _internal_set_noticedistance(float value);
  public:

  // float returndistance = 11;
  void clear_returndistance();
  float returndistance() const;
  void set_returndistance(float value);
  private:
  float _internal_returndistance() const;
  void _internal_set_returndistance(float value);
  public:

  // float attackcooltime = 12;
  void clear_attackcooltime();
  float attackcooltime() const;
  void set_attackcooltime(float value);
  private:
  float _internal_attackcooltime() const;
  void _internal_set_attackcooltime(float value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.Stat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t level_;
  int32_t totalexp_;
  int32_t exp_;
  int32_t maxhp_;
  int32_t hp_;
  int32_t damage_;
  int32_t defence_;
  float speed_;
  float attackdistance_;
  float noticedistance_;
  float returndistance_;
  float attackcooltime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class ObjectInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.ObjectInfo) */ {
 public:
  inline ObjectInfo() : ObjectInfo(nullptr) {}
  ~ObjectInfo() override;
  explicit constexpr ObjectInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectInfo(const ObjectInfo& from);
  ObjectInfo(ObjectInfo&& from) noexcept
    : ObjectInfo() {
    *this = ::std::move(from);
  }

  inline ObjectInfo& operator=(const ObjectInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectInfo& operator=(ObjectInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectInfo* internal_default_instance() {
    return reinterpret_cast<const ObjectInfo*>(
               &_ObjectInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ObjectInfo& a, ObjectInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObjectInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.ObjectInfo";
  }
  protected:
  explicit ObjectInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kPosFieldNumber = 6,
    kStatFieldNumber = 7,
    kObjectIdFieldNumber = 1,
    kPlayerdbidFieldNumber = 2,
    kObjecttypeFieldNumber = 4,
    kTypetemplateidFieldNumber = 5,
  };
  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .PROTOCOL.Position pos = 6;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::PROTOCOL::Position& pos() const;
  PROTOBUF_NODISCARD ::PROTOCOL::Position* release_pos();
  ::PROTOCOL::Position* mutable_pos();
  void set_allocated_pos(::PROTOCOL::Position* pos);
  private:
  const ::PROTOCOL::Position& _internal_pos() const;
  ::PROTOCOL::Position* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::PROTOCOL::Position* pos);
  ::PROTOCOL::Position* unsafe_arena_release_pos();

  // .PROTOCOL.Stat stat = 7;
  bool has_stat() const;
  private:
  bool _internal_has_stat() const;
  public:
  void clear_stat();
  const ::PROTOCOL::Stat& stat() const;
  PROTOBUF_NODISCARD ::PROTOCOL::Stat* release_stat();
  ::PROTOCOL::Stat* mutable_stat();
  void set_allocated_stat(::PROTOCOL::Stat* stat);
  private:
  const ::PROTOCOL::Stat& _internal_stat() const;
  ::PROTOCOL::Stat* _internal_mutable_stat();
  public:
  void unsafe_arena_set_allocated_stat(
      ::PROTOCOL::Stat* stat);
  ::PROTOCOL::Stat* unsafe_arena_release_stat();

  // int32 objectId = 1;
  void clear_objectid();
  int32_t objectid() const;
  void set_objectid(int32_t value);
  private:
  int32_t _internal_objectid() const;
  void _internal_set_objectid(int32_t value);
  public:

  // int32 playerdbid = 2;
  void clear_playerdbid();
  int32_t playerdbid() const;
  void set_playerdbid(int32_t value);
  private:
  int32_t _internal_playerdbid() const;
  void _internal_set_playerdbid(int32_t value);
  public:

  // .PROTOCOL.GameObjectType objecttype = 4;
  void clear_objecttype();
  ::PROTOCOL::GameObjectType objecttype() const;
  void set_objecttype(::PROTOCOL::GameObjectType value);
  private:
  ::PROTOCOL::GameObjectType _internal_objecttype() const;
  void _internal_set_objecttype(::PROTOCOL::GameObjectType value);
  public:

  // int32 typetemplateid = 5;
  void clear_typetemplateid();
  int32_t typetemplateid() const;
  void set_typetemplateid(int32_t value);
  private:
  int32_t _internal_typetemplateid() const;
  void _internal_set_typetemplateid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.ObjectInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOCOL::Position* pos_;
  ::PROTOCOL::Stat* stat_;
  int32_t objectid_;
  int32_t playerdbid_;
  int objecttype_;
  int32_t typetemplateid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class LobbyPlayerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.LobbyPlayerInfo) */ {
 public:
  inline LobbyPlayerInfo() : LobbyPlayerInfo(nullptr) {}
  ~LobbyPlayerInfo() override;
  explicit constexpr LobbyPlayerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LobbyPlayerInfo(const LobbyPlayerInfo& from);
  LobbyPlayerInfo(LobbyPlayerInfo&& from) noexcept
    : LobbyPlayerInfo() {
    *this = ::std::move(from);
  }

  inline LobbyPlayerInfo& operator=(const LobbyPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LobbyPlayerInfo& operator=(LobbyPlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LobbyPlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LobbyPlayerInfo* internal_default_instance() {
    return reinterpret_cast<const LobbyPlayerInfo*>(
               &_LobbyPlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LobbyPlayerInfo& a, LobbyPlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LobbyPlayerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LobbyPlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LobbyPlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LobbyPlayerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LobbyPlayerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LobbyPlayerInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LobbyPlayerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.LobbyPlayerInfo";
  }
  protected:
  explicit LobbyPlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kStatFieldNumber = 3,
    kPlayerdbidFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .PROTOCOL.Stat stat = 3;
  bool has_stat() const;
  private:
  bool _internal_has_stat() const;
  public:
  void clear_stat();
  const ::PROTOCOL::Stat& stat() const;
  PROTOBUF_NODISCARD ::PROTOCOL::Stat* release_stat();
  ::PROTOCOL::Stat* mutable_stat();
  void set_allocated_stat(::PROTOCOL::Stat* stat);
  private:
  const ::PROTOCOL::Stat& _internal_stat() const;
  ::PROTOCOL::Stat* _internal_mutable_stat();
  public:
  void unsafe_arena_set_allocated_stat(
      ::PROTOCOL::Stat* stat);
  ::PROTOCOL::Stat* unsafe_arena_release_stat();

  // int32 playerdbid = 1;
  void clear_playerdbid();
  int32_t playerdbid() const;
  void set_playerdbid(int32_t value);
  private:
  int32_t _internal_playerdbid() const;
  void _internal_set_playerdbid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.LobbyPlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOCOL::Stat* stat_;
  int32_t playerdbid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class Skill final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.Skill) */ {
 public:
  inline Skill() : Skill(nullptr) {}
  ~Skill() override;
  explicit constexpr Skill(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Skill(const Skill& from);
  Skill(Skill&& from) noexcept
    : Skill() {
    *this = ::std::move(from);
  }

  inline Skill& operator=(const Skill& from) {
    CopyFrom(from);
    return *this;
  }
  inline Skill& operator=(Skill&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Skill& default_instance() {
    return *internal_default_instance();
  }
  static inline const Skill* internal_default_instance() {
    return reinterpret_cast<const Skill*>(
               &_Skill_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Skill& a, Skill& b) {
    a.Swap(&b);
  }
  inline void Swap(Skill* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Skill* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Skill* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Skill>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Skill& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Skill& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Skill* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.Skill";
  }
  protected:
  explicit Skill(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkillIdFieldNumber = 1,
  };
  // int32 skillId = 1;
  void clear_skillid();
  int32_t skillid() const;
  void set_skillid(int32_t value);
  private:
  int32_t _internal_skillid() const;
  void _internal_set_skillid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.Skill)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t skillid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class ItemInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.ItemInfo) */ {
 public:
  inline ItemInfo() : ItemInfo(nullptr) {}
  ~ItemInfo() override;
  explicit constexpr ItemInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemInfo(const ItemInfo& from);
  ItemInfo(ItemInfo&& from) noexcept
    : ItemInfo() {
    *this = ::std::move(from);
  }

  inline ItemInfo& operator=(const ItemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemInfo& operator=(ItemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemInfo* internal_default_instance() {
    return reinterpret_cast<const ItemInfo*>(
               &_ItemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ItemInfo& a, ItemInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ItemInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.ItemInfo";
  }
  protected:
  explicit ItemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemDbIdFieldNumber = 1,
    kTemplateIdFieldNumber = 2,
    kCountFieldNumber = 3,
    kSlotFieldNumber = 4,
    kEquippedFieldNumber = 5,
    kPlayerdbidFieldNumber = 6,
  };
  // int32 itemDbId = 1;
  void clear_itemdbid();
  int32_t itemdbid() const;
  void set_itemdbid(int32_t value);
  private:
  int32_t _internal_itemdbid() const;
  void _internal_set_itemdbid(int32_t value);
  public:

  // int32 templateId = 2;
  void clear_templateid();
  int32_t templateid() const;
  void set_templateid(int32_t value);
  private:
  int32_t _internal_templateid() const;
  void _internal_set_templateid(int32_t value);
  public:

  // int32 count = 3;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // int32 slot = 4;
  void clear_slot();
  int32_t slot() const;
  void set_slot(int32_t value);
  private:
  int32_t _internal_slot() const;
  void _internal_set_slot(int32_t value);
  public:

  // bool equipped = 5;
  void clear_equipped();
  bool equipped() const;
  void set_equipped(bool value);
  private:
  bool _internal_equipped() const;
  void _internal_set_equipped(bool value);
  public:

  // int32 playerdbid = 6;
  void clear_playerdbid();
  int32_t playerdbid() const;
  void set_playerdbid(int32_t value);
  private:
  int32_t _internal_playerdbid() const;
  void _internal_set_playerdbid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.ItemInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t itemdbid_;
  int32_t templateid_;
  int32_t count_;
  int32_t slot_;
  bool equipped_;
  int32_t playerdbid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class QuestInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.QuestInfo) */ {
 public:
  inline QuestInfo() : QuestInfo(nullptr) {}
  ~QuestInfo() override;
  explicit constexpr QuestInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuestInfo(const QuestInfo& from);
  QuestInfo(QuestInfo&& from) noexcept
    : QuestInfo() {
    *this = ::std::move(from);
  }

  inline QuestInfo& operator=(const QuestInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuestInfo& operator=(QuestInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuestInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuestInfo* internal_default_instance() {
    return reinterpret_cast<const QuestInfo*>(
               &_QuestInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(QuestInfo& a, QuestInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(QuestInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuestInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuestInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuestInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuestInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QuestInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuestInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.QuestInfo";
  }
  protected:
  explicit QuestInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestdbidFieldNumber = 1,
    kTemplateidFieldNumber = 2,
    kProgressFieldNumber = 3,
    kCompletedFieldNumber = 4,
    kPlayerdbidFieldNumber = 5,
  };
  // int32 questdbid = 1;
  void clear_questdbid();
  int32_t questdbid() const;
  void set_questdbid(int32_t value);
  private:
  int32_t _internal_questdbid() const;
  void _internal_set_questdbid(int32_t value);
  public:

  // int32 templateid = 2;
  void clear_templateid();
  int32_t templateid() const;
  void set_templateid(int32_t value);
  private:
  int32_t _internal_templateid() const;
  void _internal_set_templateid(int32_t value);
  public:

  // int32 progress = 3;
  void clear_progress();
  int32_t progress() const;
  void set_progress(int32_t value);
  private:
  int32_t _internal_progress() const;
  void _internal_set_progress(int32_t value);
  public:

  // bool completed = 4;
  void clear_completed();
  bool completed() const;
  void set_completed(bool value);
  private:
  bool _internal_completed() const;
  void _internal_set_completed(bool value);
  public:

  // int32 playerdbid = 5;
  void clear_playerdbid();
  int32_t playerdbid() const;
  void set_playerdbid(int32_t value);
  private:
  int32_t _internal_playerdbid() const;
  void _internal_set_playerdbid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.QuestInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t questdbid_;
  int32_t templateid_;
  int32_t progress_;
  bool completed_;
  int32_t playerdbid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_Login final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_Login) */ {
 public:
  inline C_Login() : C_Login(nullptr) {}
  ~C_Login() override;
  explicit constexpr C_Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Login(const C_Login& from);
  C_Login(C_Login&& from) noexcept
    : C_Login() {
    *this = ::std::move(from);
  }

  inline C_Login& operator=(const C_Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Login& operator=(C_Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Login* internal_default_instance() {
    return reinterpret_cast<const C_Login*>(
               &_C_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(C_Login& a, C_Login& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Login* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Login>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_Login& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_Login& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Login* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_Login";
  }
  protected:
  explicit C_Login(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPwFieldNumber = 2,
    kTokenstringFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string pw = 2;
  void clear_pw();
  const std::string& pw() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pw(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pw();
  PROTOBUF_NODISCARD std::string* release_pw();
  void set_allocated_pw(std::string* pw);
  private:
  const std::string& _internal_pw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pw(const std::string& value);
  std::string* _internal_mutable_pw();
  public:

  // string tokenstring = 3;
  void clear_tokenstring();
  const std::string& tokenstring() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tokenstring(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tokenstring();
  PROTOBUF_NODISCARD std::string* release_tokenstring();
  void set_allocated_tokenstring(std::string* tokenstring);
  private:
  const std::string& _internal_tokenstring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tokenstring(const std::string& value);
  std::string* _internal_mutable_tokenstring();
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pw_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tokenstring_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_Login final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_Login) */ {
 public:
  inline S_Login() : S_Login(nullptr) {}
  ~S_Login() override;
  explicit constexpr S_Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Login(const S_Login& from);
  S_Login(S_Login&& from) noexcept
    : S_Login() {
    *this = ::std::move(from);
  }

  inline S_Login& operator=(const S_Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Login& operator=(S_Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Login* internal_default_instance() {
    return reinterpret_cast<const S_Login*>(
               &_S_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(S_Login& a, S_Login& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Login* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Login>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Login& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_Login& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Login* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_Login";
  }
  protected:
  explicit S_Login(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectinfosFieldNumber = 2,
    kLobbyplayerinfosFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // repeated .PROTOCOL.ObjectInfo objectinfos = 2;
  int objectinfos_size() const;
  private:
  int _internal_objectinfos_size() const;
  public:
  void clear_objectinfos();
  ::PROTOCOL::ObjectInfo* mutable_objectinfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo >*
      mutable_objectinfos();
  private:
  const ::PROTOCOL::ObjectInfo& _internal_objectinfos(int index) const;
  ::PROTOCOL::ObjectInfo* _internal_add_objectinfos();
  public:
  const ::PROTOCOL::ObjectInfo& objectinfos(int index) const;
  ::PROTOCOL::ObjectInfo* add_objectinfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo >&
      objectinfos() const;

  // repeated .PROTOCOL.LobbyPlayerInfo lobbyplayerinfos = 3;
  int lobbyplayerinfos_size() const;
  private:
  int _internal_lobbyplayerinfos_size() const;
  public:
  void clear_lobbyplayerinfos();
  ::PROTOCOL::LobbyPlayerInfo* mutable_lobbyplayerinfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::LobbyPlayerInfo >*
      mutable_lobbyplayerinfos();
  private:
  const ::PROTOCOL::LobbyPlayerInfo& _internal_lobbyplayerinfos(int index) const;
  ::PROTOCOL::LobbyPlayerInfo* _internal_add_lobbyplayerinfos();
  public:
  const ::PROTOCOL::LobbyPlayerInfo& lobbyplayerinfos(int index) const;
  ::PROTOCOL::LobbyPlayerInfo* add_lobbyplayerinfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::LobbyPlayerInfo >&
      lobbyplayerinfos() const;

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo > objectinfos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::LobbyPlayerInfo > lobbyplayerinfos_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_Enter_Room final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_Enter_Room) */ {
 public:
  inline C_Enter_Room() : C_Enter_Room(nullptr) {}
  ~C_Enter_Room() override;
  explicit constexpr C_Enter_Room(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Enter_Room(const C_Enter_Room& from);
  C_Enter_Room(C_Enter_Room&& from) noexcept
    : C_Enter_Room() {
    *this = ::std::move(from);
  }

  inline C_Enter_Room& operator=(const C_Enter_Room& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Enter_Room& operator=(C_Enter_Room&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Enter_Room& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Enter_Room* internal_default_instance() {
    return reinterpret_cast<const C_Enter_Room*>(
               &_C_Enter_Room_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(C_Enter_Room& a, C_Enter_Room& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Enter_Room* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Enter_Room* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Enter_Room* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Enter_Room>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_Enter_Room& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_Enter_Room& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Enter_Room* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_Enter_Room";
  }
  protected:
  explicit C_Enter_Room(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 2,
    kRoomNumFieldNumber = 1,
  };
  // .PROTOCOL.ObjectInfo object = 2;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // uint64 roomNum = 1;
  void clear_roomnum();
  uint64_t roomnum() const;
  void set_roomnum(uint64_t value);
  private:
  uint64_t _internal_roomnum() const;
  void _internal_set_roomnum(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_Enter_Room)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ObjectInfo* object_;
  uint64_t roomnum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_Enter_Room final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_Enter_Room) */ {
 public:
  inline S_Enter_Room() : S_Enter_Room(nullptr) {}
  ~S_Enter_Room() override;
  explicit constexpr S_Enter_Room(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Enter_Room(const S_Enter_Room& from);
  S_Enter_Room(S_Enter_Room&& from) noexcept
    : S_Enter_Room() {
    *this = ::std::move(from);
  }

  inline S_Enter_Room& operator=(const S_Enter_Room& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Enter_Room& operator=(S_Enter_Room&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Enter_Room& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Enter_Room* internal_default_instance() {
    return reinterpret_cast<const S_Enter_Room*>(
               &_S_Enter_Room_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(S_Enter_Room& a, S_Enter_Room& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Enter_Room* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Enter_Room* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Enter_Room* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Enter_Room>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Enter_Room& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_Enter_Room& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Enter_Room* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_Enter_Room";
  }
  protected:
  explicit S_Enter_Room(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 3,
    kObjectFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated .PROTOCOL.ItemInfo items = 3;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::PROTOCOL::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
      mutable_items();
  private:
  const ::PROTOCOL::ItemInfo& _internal_items(int index) const;
  ::PROTOCOL::ItemInfo* _internal_add_items();
  public:
  const ::PROTOCOL::ItemInfo& items(int index) const;
  ::PROTOCOL::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
      items() const;

  // .PROTOCOL.ObjectInfo object = 2;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_Enter_Room)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo > items_;
  ::PROTOCOL::ObjectInfo* object_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_Leave_Room final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_Leave_Room) */ {
 public:
  inline C_Leave_Room() : C_Leave_Room(nullptr) {}
  ~C_Leave_Room() override;
  explicit constexpr C_Leave_Room(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Leave_Room(const C_Leave_Room& from);
  C_Leave_Room(C_Leave_Room&& from) noexcept
    : C_Leave_Room() {
    *this = ::std::move(from);
  }

  inline C_Leave_Room& operator=(const C_Leave_Room& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Leave_Room& operator=(C_Leave_Room&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Leave_Room& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Leave_Room* internal_default_instance() {
    return reinterpret_cast<const C_Leave_Room*>(
               &_C_Leave_Room_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(C_Leave_Room& a, C_Leave_Room& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Leave_Room* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Leave_Room* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Leave_Room* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Leave_Room>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_Leave_Room& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_Leave_Room& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Leave_Room* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_Leave_Room";
  }
  protected:
  explicit C_Leave_Room(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .PROTOCOL.ObjectInfo object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_Leave_Room)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ObjectInfo* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_Leave_Room final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_Leave_Room) */ {
 public:
  inline S_Leave_Room() : S_Leave_Room(nullptr) {}
  ~S_Leave_Room() override;
  explicit constexpr S_Leave_Room(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Leave_Room(const S_Leave_Room& from);
  S_Leave_Room(S_Leave_Room&& from) noexcept
    : S_Leave_Room() {
    *this = ::std::move(from);
  }

  inline S_Leave_Room& operator=(const S_Leave_Room& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Leave_Room& operator=(S_Leave_Room&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Leave_Room& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Leave_Room* internal_default_instance() {
    return reinterpret_cast<const S_Leave_Room*>(
               &_S_Leave_Room_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(S_Leave_Room& a, S_Leave_Room& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Leave_Room* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Leave_Room* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Leave_Room* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Leave_Room>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Leave_Room& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_Leave_Room& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Leave_Room* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_Leave_Room";
  }
  protected:
  explicit S_Leave_Room(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .PROTOCOL.ObjectInfo object = 2;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_Leave_Room)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ObjectInfo* object_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_Spawn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_Spawn) */ {
 public:
  inline C_Spawn() : C_Spawn(nullptr) {}
  ~C_Spawn() override;
  explicit constexpr C_Spawn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Spawn(const C_Spawn& from);
  C_Spawn(C_Spawn&& from) noexcept
    : C_Spawn() {
    *this = ::std::move(from);
  }

  inline C_Spawn& operator=(const C_Spawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Spawn& operator=(C_Spawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Spawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Spawn* internal_default_instance() {
    return reinterpret_cast<const C_Spawn*>(
               &_C_Spawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(C_Spawn& a, C_Spawn& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Spawn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Spawn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Spawn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Spawn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_Spawn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_Spawn& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Spawn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_Spawn";
  }
  protected:
  explicit C_Spawn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .PROTOCOL.ObjectInfo object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_Spawn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ObjectInfo* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_Spawn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_Spawn) */ {
 public:
  inline S_Spawn() : S_Spawn(nullptr) {}
  ~S_Spawn() override;
  explicit constexpr S_Spawn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Spawn(const S_Spawn& from);
  S_Spawn(S_Spawn&& from) noexcept
    : S_Spawn() {
    *this = ::std::move(from);
  }

  inline S_Spawn& operator=(const S_Spawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Spawn& operator=(S_Spawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Spawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Spawn* internal_default_instance() {
    return reinterpret_cast<const S_Spawn*>(
               &_S_Spawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(S_Spawn& a, S_Spawn& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Spawn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Spawn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Spawn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Spawn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Spawn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_Spawn& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Spawn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_Spawn";
  }
  protected:
  explicit S_Spawn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated .PROTOCOL.ObjectInfo object = 2;
  int object_size() const;
  private:
  int _internal_object_size() const;
  public:
  void clear_object();
  ::PROTOCOL::ObjectInfo* mutable_object(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo >*
      mutable_object();
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object(int index) const;
  ::PROTOCOL::ObjectInfo* _internal_add_object();
  public:
  const ::PROTOCOL::ObjectInfo& object(int index) const;
  ::PROTOCOL::ObjectInfo* add_object();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo >&
      object() const;

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_Spawn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo > object_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_DeSpawn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_DeSpawn) */ {
 public:
  inline S_DeSpawn() : S_DeSpawn(nullptr) {}
  ~S_DeSpawn() override;
  explicit constexpr S_DeSpawn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DeSpawn(const S_DeSpawn& from);
  S_DeSpawn(S_DeSpawn&& from) noexcept
    : S_DeSpawn() {
    *this = ::std::move(from);
  }

  inline S_DeSpawn& operator=(const S_DeSpawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DeSpawn& operator=(S_DeSpawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DeSpawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DeSpawn* internal_default_instance() {
    return reinterpret_cast<const S_DeSpawn*>(
               &_S_DeSpawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(S_DeSpawn& a, S_DeSpawn& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DeSpawn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DeSpawn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_DeSpawn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_DeSpawn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_DeSpawn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_DeSpawn& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DeSpawn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_DeSpawn";
  }
  protected:
  explicit S_DeSpawn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectidsFieldNumber = 1,
  };
  // repeated int32 objectids = 1;
  int objectids_size() const;
  private:
  int _internal_objectids_size() const;
  public:
  void clear_objectids();
  private:
  int32_t _internal_objectids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_objectids() const;
  void _internal_add_objectids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_objectids();
  public:
  int32_t objectids(int index) const;
  void set_objectids(int index, int32_t value);
  void add_objectids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      objectids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_objectids();

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_DeSpawn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > objectids_;
  mutable std::atomic<int> _objectids_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_Move final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_Move) */ {
 public:
  inline C_Move() : C_Move(nullptr) {}
  ~C_Move() override;
  explicit constexpr C_Move(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Move(const C_Move& from);
  C_Move(C_Move&& from) noexcept
    : C_Move() {
    *this = ::std::move(from);
  }

  inline C_Move& operator=(const C_Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Move& operator=(C_Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Move* internal_default_instance() {
    return reinterpret_cast<const C_Move*>(
               &_C_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(C_Move& a, C_Move& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Move* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Move* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Move* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Move>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_Move& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_Move& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Move* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_Move";
  }
  protected:
  explicit C_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .PROTOCOL.ObjectInfo object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_Move)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ObjectInfo* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_Move final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_Move) */ {
 public:
  inline S_Move() : S_Move(nullptr) {}
  ~S_Move() override;
  explicit constexpr S_Move(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Move(const S_Move& from);
  S_Move(S_Move&& from) noexcept
    : S_Move() {
    *this = ::std::move(from);
  }

  inline S_Move& operator=(const S_Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Move& operator=(S_Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Move* internal_default_instance() {
    return reinterpret_cast<const S_Move*>(
               &_S_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(S_Move& a, S_Move& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Move* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Move* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Move* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Move>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Move& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_Move& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Move* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_Move";
  }
  protected:
  explicit S_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .PROTOCOL.ObjectInfo object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_Move)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ObjectInfo* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_Skill final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_Skill) */ {
 public:
  inline C_Skill() : C_Skill(nullptr) {}
  ~C_Skill() override;
  explicit constexpr C_Skill(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Skill(const C_Skill& from);
  C_Skill(C_Skill&& from) noexcept
    : C_Skill() {
    *this = ::std::move(from);
  }

  inline C_Skill& operator=(const C_Skill& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Skill& operator=(C_Skill&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Skill& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Skill* internal_default_instance() {
    return reinterpret_cast<const C_Skill*>(
               &_C_Skill_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(C_Skill& a, C_Skill& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Skill* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Skill* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Skill* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Skill>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_Skill& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_Skill& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Skill* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_Skill";
  }
  protected:
  explicit C_Skill(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVictimsFieldNumber = 3,
    kSkillidFieldNumber = 1,
    kAttackerFieldNumber = 2,
  };
  // repeated int32 victims = 3;
  int victims_size() const;
  private:
  int _internal_victims_size() const;
  public:
  void clear_victims();
  private:
  int32_t _internal_victims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_victims() const;
  void _internal_add_victims(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_victims();
  public:
  int32_t victims(int index) const;
  void set_victims(int index, int32_t value);
  void add_victims(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      victims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_victims();

  // int32 skillid = 1;
  void clear_skillid();
  int32_t skillid() const;
  void set_skillid(int32_t value);
  private:
  int32_t _internal_skillid() const;
  void _internal_set_skillid(int32_t value);
  public:

  // int32 attacker = 2;
  void clear_attacker();
  int32_t attacker() const;
  void set_attacker(int32_t value);
  private:
  int32_t _internal_attacker() const;
  void _internal_set_attacker(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_Skill)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > victims_;
  mutable std::atomic<int> _victims_cached_byte_size_;
  int32_t skillid_;
  int32_t attacker_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_Skill final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_Skill) */ {
 public:
  inline S_Skill() : S_Skill(nullptr) {}
  ~S_Skill() override;
  explicit constexpr S_Skill(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Skill(const S_Skill& from);
  S_Skill(S_Skill&& from) noexcept
    : S_Skill() {
    *this = ::std::move(from);
  }

  inline S_Skill& operator=(const S_Skill& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Skill& operator=(S_Skill&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Skill& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Skill* internal_default_instance() {
    return reinterpret_cast<const S_Skill*>(
               &_S_Skill_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(S_Skill& a, S_Skill& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Skill* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Skill* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Skill* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Skill>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Skill& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_Skill& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Skill* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_Skill";
  }
  protected:
  explicit S_Skill(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVictimsFieldNumber = 3,
    kSkillidFieldNumber = 1,
    kAttackerFieldNumber = 2,
  };
  // repeated int32 victims = 3;
  int victims_size() const;
  private:
  int _internal_victims_size() const;
  public:
  void clear_victims();
  private:
  int32_t _internal_victims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_victims() const;
  void _internal_add_victims(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_victims();
  public:
  int32_t victims(int index) const;
  void set_victims(int index, int32_t value);
  void add_victims(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      victims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_victims();

  // int32 skillid = 1;
  void clear_skillid();
  int32_t skillid() const;
  void set_skillid(int32_t value);
  private:
  int32_t _internal_skillid() const;
  void _internal_set_skillid(int32_t value);
  public:

  // int32 attacker = 2;
  void clear_attacker();
  int32_t attacker() const;
  void set_attacker(int32_t value);
  private:
  int32_t _internal_attacker() const;
  void _internal_set_attacker(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_Skill)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > victims_;
  mutable std::atomic<int> _victims_cached_byte_size_;
  int32_t skillid_;
  int32_t attacker_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_Chat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_Chat) */ {
 public:
  inline C_Chat() : C_Chat(nullptr) {}
  ~C_Chat() override;
  explicit constexpr C_Chat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Chat(const C_Chat& from);
  C_Chat(C_Chat&& from) noexcept
    : C_Chat() {
    *this = ::std::move(from);
  }

  inline C_Chat& operator=(const C_Chat& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Chat& operator=(C_Chat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Chat& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Chat* internal_default_instance() {
    return reinterpret_cast<const C_Chat*>(
               &_C_Chat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(C_Chat& a, C_Chat& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Chat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Chat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Chat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Chat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_Chat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_Chat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Chat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_Chat";
  }
  protected:
  explicit C_Chat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_Chat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_Chat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_Chat) */ {
 public:
  inline S_Chat() : S_Chat(nullptr) {}
  ~S_Chat() override;
  explicit constexpr S_Chat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Chat(const S_Chat& from);
  S_Chat(S_Chat&& from) noexcept
    : S_Chat() {
    *this = ::std::move(from);
  }

  inline S_Chat& operator=(const S_Chat& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Chat& operator=(S_Chat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Chat& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Chat* internal_default_instance() {
    return reinterpret_cast<const S_Chat*>(
               &_S_Chat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(S_Chat& a, S_Chat& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Chat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Chat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Chat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Chat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Chat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_Chat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Chat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_Chat";
  }
  protected:
  explicit S_Chat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 2,
    kObjectFieldNumber = 1,
  };
  // string text = 2;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .PROTOCOL.ObjectInfo object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_Chat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOCOL::ObjectInfo* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_ChangeHp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_ChangeHp) */ {
 public:
  inline S_ChangeHp() : S_ChangeHp(nullptr) {}
  ~S_ChangeHp() override;
  explicit constexpr S_ChangeHp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ChangeHp(const S_ChangeHp& from);
  S_ChangeHp(S_ChangeHp&& from) noexcept
    : S_ChangeHp() {
    *this = ::std::move(from);
  }

  inline S_ChangeHp& operator=(const S_ChangeHp& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ChangeHp& operator=(S_ChangeHp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ChangeHp& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ChangeHp* internal_default_instance() {
    return reinterpret_cast<const S_ChangeHp*>(
               &_S_ChangeHp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(S_ChangeHp& a, S_ChangeHp& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ChangeHp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ChangeHp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ChangeHp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ChangeHp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ChangeHp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_ChangeHp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ChangeHp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_ChangeHp";
  }
  protected:
  explicit S_ChangeHp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
    kHpFieldNumber = 2,
  };
  // int32 object = 1;
  void clear_object();
  int32_t object() const;
  void set_object(int32_t value);
  private:
  int32_t _internal_object() const;
  void _internal_set_object(int32_t value);
  public:

  // int32 hp = 2;
  void clear_hp();
  int32_t hp() const;
  void set_hp(int32_t value);
  private:
  int32_t _internal_hp() const;
  void _internal_set_hp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_ChangeHp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t object_;
  int32_t hp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_Die final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_Die) */ {
 public:
  inline S_Die() : S_Die(nullptr) {}
  ~S_Die() override;
  explicit constexpr S_Die(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Die(const S_Die& from);
  S_Die(S_Die&& from) noexcept
    : S_Die() {
    *this = ::std::move(from);
  }

  inline S_Die& operator=(const S_Die& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Die& operator=(S_Die&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Die& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Die* internal_default_instance() {
    return reinterpret_cast<const S_Die*>(
               &_S_Die_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(S_Die& a, S_Die& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Die* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Die* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Die* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Die>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Die& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_Die& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Die* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_Die";
  }
  protected:
  explicit S_Die(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVictimFieldNumber = 1,
    kAttackerFieldNumber = 2,
  };
  // int32 victim = 1;
  void clear_victim();
  int32_t victim() const;
  void set_victim(int32_t value);
  private:
  int32_t _internal_victim() const;
  void _internal_set_victim(int32_t value);
  public:

  // int32 attacker = 2;
  void clear_attacker();
  int32_t attacker() const;
  void set_attacker(int32_t value);
  private:
  int32_t _internal_attacker() const;
  void _internal_set_attacker(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_Die)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t victim_;
  int32_t attacker_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_ItemList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_ItemList) */ {
 public:
  inline S_ItemList() : S_ItemList(nullptr) {}
  ~S_ItemList() override;
  explicit constexpr S_ItemList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ItemList(const S_ItemList& from);
  S_ItemList(S_ItemList&& from) noexcept
    : S_ItemList() {
    *this = ::std::move(from);
  }

  inline S_ItemList& operator=(const S_ItemList& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ItemList& operator=(S_ItemList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ItemList& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ItemList* internal_default_instance() {
    return reinterpret_cast<const S_ItemList*>(
               &_S_ItemList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(S_ItemList& a, S_ItemList& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ItemList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ItemList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ItemList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ItemList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ItemList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_ItemList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ItemList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_ItemList";
  }
  protected:
  explicit S_ItemList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .PROTOCOL.ItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::PROTOCOL::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
      mutable_items();
  private:
  const ::PROTOCOL::ItemInfo& _internal_items(int index) const;
  ::PROTOCOL::ItemInfo* _internal_add_items();
  public:
  const ::PROTOCOL::ItemInfo& items(int index) const;
  ::PROTOCOL::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_ItemList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_AddItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_AddItem) */ {
 public:
  inline C_AddItem() : C_AddItem(nullptr) {}
  ~C_AddItem() override;
  explicit constexpr C_AddItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_AddItem(const C_AddItem& from);
  C_AddItem(C_AddItem&& from) noexcept
    : C_AddItem() {
    *this = ::std::move(from);
  }

  inline C_AddItem& operator=(const C_AddItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_AddItem& operator=(C_AddItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_AddItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_AddItem* internal_default_instance() {
    return reinterpret_cast<const C_AddItem*>(
               &_C_AddItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(C_AddItem& a, C_AddItem& b) {
    a.Swap(&b);
  }
  inline void Swap(C_AddItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_AddItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_AddItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_AddItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_AddItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_AddItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_AddItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_AddItem";
  }
  protected:
  explicit C_AddItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .PROTOCOL.ItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::PROTOCOL::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
      mutable_items();
  private:
  const ::PROTOCOL::ItemInfo& _internal_items(int index) const;
  ::PROTOCOL::ItemInfo* _internal_add_items();
  public:
  const ::PROTOCOL::ItemInfo& items(int index) const;
  ::PROTOCOL::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_AddItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_AddItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_AddItem) */ {
 public:
  inline S_AddItem() : S_AddItem(nullptr) {}
  ~S_AddItem() override;
  explicit constexpr S_AddItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AddItem(const S_AddItem& from);
  S_AddItem(S_AddItem&& from) noexcept
    : S_AddItem() {
    *this = ::std::move(from);
  }

  inline S_AddItem& operator=(const S_AddItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AddItem& operator=(S_AddItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AddItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AddItem* internal_default_instance() {
    return reinterpret_cast<const S_AddItem*>(
               &_S_AddItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(S_AddItem& a, S_AddItem& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AddItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AddItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AddItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AddItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AddItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_AddItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AddItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_AddItem";
  }
  protected:
  explicit S_AddItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .PROTOCOL.ItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::PROTOCOL::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
      mutable_items();
  private:
  const ::PROTOCOL::ItemInfo& _internal_items(int index) const;
  ::PROTOCOL::ItemInfo* _internal_add_items();
  public:
  const ::PROTOCOL::ItemInfo& items(int index) const;
  ::PROTOCOL::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_AddItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_UpdateItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_UpdateItem) */ {
 public:
  inline S_UpdateItem() : S_UpdateItem(nullptr) {}
  ~S_UpdateItem() override;
  explicit constexpr S_UpdateItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_UpdateItem(const S_UpdateItem& from);
  S_UpdateItem(S_UpdateItem&& from) noexcept
    : S_UpdateItem() {
    *this = ::std::move(from);
  }

  inline S_UpdateItem& operator=(const S_UpdateItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_UpdateItem& operator=(S_UpdateItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_UpdateItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_UpdateItem* internal_default_instance() {
    return reinterpret_cast<const S_UpdateItem*>(
               &_S_UpdateItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(S_UpdateItem& a, S_UpdateItem& b) {
    a.Swap(&b);
  }
  inline void Swap(S_UpdateItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_UpdateItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_UpdateItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_UpdateItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_UpdateItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_UpdateItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_UpdateItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_UpdateItem";
  }
  protected:
  explicit S_UpdateItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .PROTOCOL.ItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::PROTOCOL::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
      mutable_items();
  private:
  const ::PROTOCOL::ItemInfo& _internal_items(int index) const;
  ::PROTOCOL::ItemInfo* _internal_add_items();
  public:
  const ::PROTOCOL::ItemInfo& items(int index) const;
  ::PROTOCOL::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_UpdateItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_RemoveItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_RemoveItem) */ {
 public:
  inline S_RemoveItem() : S_RemoveItem(nullptr) {}
  ~S_RemoveItem() override;
  explicit constexpr S_RemoveItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_RemoveItem(const S_RemoveItem& from);
  S_RemoveItem(S_RemoveItem&& from) noexcept
    : S_RemoveItem() {
    *this = ::std::move(from);
  }

  inline S_RemoveItem& operator=(const S_RemoveItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_RemoveItem& operator=(S_RemoveItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_RemoveItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_RemoveItem* internal_default_instance() {
    return reinterpret_cast<const S_RemoveItem*>(
               &_S_RemoveItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(S_RemoveItem& a, S_RemoveItem& b) {
    a.Swap(&b);
  }
  inline void Swap(S_RemoveItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_RemoveItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_RemoveItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_RemoveItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_RemoveItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_RemoveItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_RemoveItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_RemoveItem";
  }
  protected:
  explicit S_RemoveItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotsFieldNumber = 1,
  };
  // repeated int32 slots = 1;
  int slots_size() const;
  private:
  int _internal_slots_size() const;
  public:
  void clear_slots();
  private:
  int32_t _internal_slots(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_slots() const;
  void _internal_add_slots(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_slots();
  public:
  int32_t slots(int index) const;
  void set_slots(int index, int32_t value);
  void add_slots(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      slots() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_slots();

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_RemoveItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > slots_;
  mutable std::atomic<int> _slots_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_EquipItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_EquipItem) */ {
 public:
  inline C_EquipItem() : C_EquipItem(nullptr) {}
  ~C_EquipItem() override;
  explicit constexpr C_EquipItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EquipItem(const C_EquipItem& from);
  C_EquipItem(C_EquipItem&& from) noexcept
    : C_EquipItem() {
    *this = ::std::move(from);
  }

  inline C_EquipItem& operator=(const C_EquipItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EquipItem& operator=(C_EquipItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EquipItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EquipItem* internal_default_instance() {
    return reinterpret_cast<const C_EquipItem*>(
               &_C_EquipItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(C_EquipItem& a, C_EquipItem& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EquipItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EquipItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_EquipItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_EquipItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_EquipItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_EquipItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_EquipItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_EquipItem";
  }
  protected:
  explicit C_EquipItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemdbidFieldNumber = 1,
    kSlotFieldNumber = 2,
    kEquipFieldNumber = 3,
  };
  // int32 itemdbid = 1;
  void clear_itemdbid();
  int32_t itemdbid() const;
  void set_itemdbid(int32_t value);
  private:
  int32_t _internal_itemdbid() const;
  void _internal_set_itemdbid(int32_t value);
  public:

  // int32 slot = 2;
  void clear_slot();
  int32_t slot() const;
  void set_slot(int32_t value);
  private:
  int32_t _internal_slot() const;
  void _internal_set_slot(int32_t value);
  public:

  // bool equip = 3;
  void clear_equip();
  bool equip() const;
  void set_equip(bool value);
  private:
  bool _internal_equip() const;
  void _internal_set_equip(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_EquipItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t itemdbid_;
  int32_t slot_;
  bool equip_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_EquipItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_EquipItem) */ {
 public:
  inline S_EquipItem() : S_EquipItem(nullptr) {}
  ~S_EquipItem() override;
  explicit constexpr S_EquipItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EquipItem(const S_EquipItem& from);
  S_EquipItem(S_EquipItem&& from) noexcept
    : S_EquipItem() {
    *this = ::std::move(from);
  }

  inline S_EquipItem& operator=(const S_EquipItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EquipItem& operator=(S_EquipItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EquipItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EquipItem* internal_default_instance() {
    return reinterpret_cast<const S_EquipItem*>(
               &_S_EquipItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(S_EquipItem& a, S_EquipItem& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EquipItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EquipItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EquipItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_EquipItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_EquipItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_EquipItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EquipItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_EquipItem";
  }
  protected:
  explicit S_EquipItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemdbidFieldNumber = 1,
    kSlotFieldNumber = 2,
    kEquipFieldNumber = 3,
  };
  // int32 itemdbid = 1;
  void clear_itemdbid();
  int32_t itemdbid() const;
  void set_itemdbid(int32_t value);
  private:
  int32_t _internal_itemdbid() const;
  void _internal_set_itemdbid(int32_t value);
  public:

  // int32 slot = 2;
  void clear_slot();
  int32_t slot() const;
  void set_slot(int32_t value);
  private:
  int32_t _internal_slot() const;
  void _internal_set_slot(int32_t value);
  public:

  // bool equip = 3;
  void clear_equip();
  bool equip() const;
  void set_equip(bool value);
  private:
  bool _internal_equip() const;
  void _internal_set_equip(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_EquipItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t itemdbid_;
  int32_t slot_;
  bool equip_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_UseItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_UseItem) */ {
 public:
  inline C_UseItem() : C_UseItem(nullptr) {}
  ~C_UseItem() override;
  explicit constexpr C_UseItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_UseItem(const C_UseItem& from);
  C_UseItem(C_UseItem&& from) noexcept
    : C_UseItem() {
    *this = ::std::move(from);
  }

  inline C_UseItem& operator=(const C_UseItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_UseItem& operator=(C_UseItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_UseItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_UseItem* internal_default_instance() {
    return reinterpret_cast<const C_UseItem*>(
               &_C_UseItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(C_UseItem& a, C_UseItem& b) {
    a.Swap(&b);
  }
  inline void Swap(C_UseItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_UseItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_UseItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_UseItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_UseItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_UseItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_UseItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_UseItem";
  }
  protected:
  explicit C_UseItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemdbidFieldNumber = 1,
    kSlotFieldNumber = 2,
    kUseFieldNumber = 3,
  };
  // int32 itemdbid = 1;
  void clear_itemdbid();
  int32_t itemdbid() const;
  void set_itemdbid(int32_t value);
  private:
  int32_t _internal_itemdbid() const;
  void _internal_set_itemdbid(int32_t value);
  public:

  // int32 slot = 2;
  void clear_slot();
  int32_t slot() const;
  void set_slot(int32_t value);
  private:
  int32_t _internal_slot() const;
  void _internal_set_slot(int32_t value);
  public:

  // bool use = 3;
  void clear_use();
  bool use() const;
  void set_use(bool value);
  private:
  bool _internal_use() const;
  void _internal_set_use(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_UseItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t itemdbid_;
  int32_t slot_;
  bool use_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_UseItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_UseItem) */ {
 public:
  inline S_UseItem() : S_UseItem(nullptr) {}
  ~S_UseItem() override;
  explicit constexpr S_UseItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_UseItem(const S_UseItem& from);
  S_UseItem(S_UseItem&& from) noexcept
    : S_UseItem() {
    *this = ::std::move(from);
  }

  inline S_UseItem& operator=(const S_UseItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_UseItem& operator=(S_UseItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_UseItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_UseItem* internal_default_instance() {
    return reinterpret_cast<const S_UseItem*>(
               &_S_UseItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(S_UseItem& a, S_UseItem& b) {
    a.Swap(&b);
  }
  inline void Swap(S_UseItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_UseItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_UseItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_UseItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_UseItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_UseItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_UseItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_UseItem";
  }
  protected:
  explicit S_UseItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // .PROTOCOL.ItemInfo item = 1;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::PROTOCOL::ItemInfo& item() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ItemInfo* release_item();
  ::PROTOCOL::ItemInfo* mutable_item();
  void set_allocated_item(::PROTOCOL::ItemInfo* item);
  private:
  const ::PROTOCOL::ItemInfo& _internal_item() const;
  ::PROTOCOL::ItemInfo* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::PROTOCOL::ItemInfo* item);
  ::PROTOCOL::ItemInfo* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_UseItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ItemInfo* item_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_ChangeStat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_ChangeStat) */ {
 public:
  inline S_ChangeStat() : S_ChangeStat(nullptr) {}
  ~S_ChangeStat() override;
  explicit constexpr S_ChangeStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ChangeStat(const S_ChangeStat& from);
  S_ChangeStat(S_ChangeStat&& from) noexcept
    : S_ChangeStat() {
    *this = ::std::move(from);
  }

  inline S_ChangeStat& operator=(const S_ChangeStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ChangeStat& operator=(S_ChangeStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ChangeStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ChangeStat* internal_default_instance() {
    return reinterpret_cast<const S_ChangeStat*>(
               &_S_ChangeStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(S_ChangeStat& a, S_ChangeStat& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ChangeStat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ChangeStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ChangeStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ChangeStat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ChangeStat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_ChangeStat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ChangeStat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_ChangeStat";
  }
  protected:
  explicit S_ChangeStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .PROTOCOL.ObjectInfo object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_ChangeStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ObjectInfo* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_CreatePlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_CreatePlayer) */ {
 public:
  inline C_CreatePlayer() : C_CreatePlayer(nullptr) {}
  ~C_CreatePlayer() override;
  explicit constexpr C_CreatePlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CreatePlayer(const C_CreatePlayer& from);
  C_CreatePlayer(C_CreatePlayer&& from) noexcept
    : C_CreatePlayer() {
    *this = ::std::move(from);
  }

  inline C_CreatePlayer& operator=(const C_CreatePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CreatePlayer& operator=(C_CreatePlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CreatePlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CreatePlayer* internal_default_instance() {
    return reinterpret_cast<const C_CreatePlayer*>(
               &_C_CreatePlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(C_CreatePlayer& a, C_CreatePlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CreatePlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CreatePlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CreatePlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CreatePlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CreatePlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_CreatePlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CreatePlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_CreatePlayer";
  }
  protected:
  explicit C_CreatePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_CreatePlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_CreatePlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_CreatePlayer) */ {
 public:
  inline S_CreatePlayer() : S_CreatePlayer(nullptr) {}
  ~S_CreatePlayer() override;
  explicit constexpr S_CreatePlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CreatePlayer(const S_CreatePlayer& from);
  S_CreatePlayer(S_CreatePlayer&& from) noexcept
    : S_CreatePlayer() {
    *this = ::std::move(from);
  }

  inline S_CreatePlayer& operator=(const S_CreatePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CreatePlayer& operator=(S_CreatePlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CreatePlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CreatePlayer* internal_default_instance() {
    return reinterpret_cast<const S_CreatePlayer*>(
               &_S_CreatePlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(S_CreatePlayer& a, S_CreatePlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CreatePlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CreatePlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CreatePlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CreatePlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CreatePlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_CreatePlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CreatePlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_CreatePlayer";
  }
  protected:
  explicit S_CreatePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .PROTOCOL.ObjectInfo object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_CreatePlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ObjectInfo* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_AddExp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_AddExp) */ {
 public:
  inline S_AddExp() : S_AddExp(nullptr) {}
  ~S_AddExp() override;
  explicit constexpr S_AddExp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AddExp(const S_AddExp& from);
  S_AddExp(S_AddExp&& from) noexcept
    : S_AddExp() {
    *this = ::std::move(from);
  }

  inline S_AddExp& operator=(const S_AddExp& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AddExp& operator=(S_AddExp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AddExp& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AddExp* internal_default_instance() {
    return reinterpret_cast<const S_AddExp*>(
               &_S_AddExp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(S_AddExp& a, S_AddExp& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AddExp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AddExp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AddExp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AddExp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AddExp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_AddExp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AddExp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_AddExp";
  }
  protected:
  explicit S_AddExp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpFieldNumber = 1,
  };
  // int32 exp = 1;
  void clear_exp();
  int32_t exp() const;
  void set_exp(int32_t value);
  private:
  int32_t _internal_exp() const;
  void _internal_set_exp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_AddExp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t exp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_LevelUp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_LevelUp) */ {
 public:
  inline S_LevelUp() : S_LevelUp(nullptr) {}
  ~S_LevelUp() override;
  explicit constexpr S_LevelUp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LevelUp(const S_LevelUp& from);
  S_LevelUp(S_LevelUp&& from) noexcept
    : S_LevelUp() {
    *this = ::std::move(from);
  }

  inline S_LevelUp& operator=(const S_LevelUp& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LevelUp& operator=(S_LevelUp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LevelUp& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LevelUp* internal_default_instance() {
    return reinterpret_cast<const S_LevelUp*>(
               &_S_LevelUp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(S_LevelUp& a, S_LevelUp& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LevelUp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LevelUp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LevelUp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LevelUp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LevelUp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_LevelUp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LevelUp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_LevelUp";
  }
  protected:
  explicit S_LevelUp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .PROTOCOL.ObjectInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::PROTOCOL::ObjectInfo& info() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_info();
  ::PROTOCOL::ObjectInfo* mutable_info();
  void set_allocated_info(::PROTOCOL::ObjectInfo* info);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_info() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::PROTOCOL::ObjectInfo* info);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_LevelUp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ObjectInfo* info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_AddQuest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_AddQuest) */ {
 public:
  inline C_AddQuest() : C_AddQuest(nullptr) {}
  ~C_AddQuest() override;
  explicit constexpr C_AddQuest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_AddQuest(const C_AddQuest& from);
  C_AddQuest(C_AddQuest&& from) noexcept
    : C_AddQuest() {
    *this = ::std::move(from);
  }

  inline C_AddQuest& operator=(const C_AddQuest& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_AddQuest& operator=(C_AddQuest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_AddQuest& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_AddQuest* internal_default_instance() {
    return reinterpret_cast<const C_AddQuest*>(
               &_C_AddQuest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(C_AddQuest& a, C_AddQuest& b) {
    a.Swap(&b);
  }
  inline void Swap(C_AddQuest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_AddQuest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_AddQuest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_AddQuest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_AddQuest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_AddQuest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_AddQuest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_AddQuest";
  }
  protected:
  explicit C_AddQuest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestFieldNumber = 1,
  };
  // .PROTOCOL.QuestInfo quest = 1;
  bool has_quest() const;
  private:
  bool _internal_has_quest() const;
  public:
  void clear_quest();
  const ::PROTOCOL::QuestInfo& quest() const;
  PROTOBUF_NODISCARD ::PROTOCOL::QuestInfo* release_quest();
  ::PROTOCOL::QuestInfo* mutable_quest();
  void set_allocated_quest(::PROTOCOL::QuestInfo* quest);
  private:
  const ::PROTOCOL::QuestInfo& _internal_quest() const;
  ::PROTOCOL::QuestInfo* _internal_mutable_quest();
  public:
  void unsafe_arena_set_allocated_quest(
      ::PROTOCOL::QuestInfo* quest);
  ::PROTOCOL::QuestInfo* unsafe_arena_release_quest();

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_AddQuest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::QuestInfo* quest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_AddQuest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_AddQuest) */ {
 public:
  inline S_AddQuest() : S_AddQuest(nullptr) {}
  ~S_AddQuest() override;
  explicit constexpr S_AddQuest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AddQuest(const S_AddQuest& from);
  S_AddQuest(S_AddQuest&& from) noexcept
    : S_AddQuest() {
    *this = ::std::move(from);
  }

  inline S_AddQuest& operator=(const S_AddQuest& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AddQuest& operator=(S_AddQuest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AddQuest& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AddQuest* internal_default_instance() {
    return reinterpret_cast<const S_AddQuest*>(
               &_S_AddQuest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(S_AddQuest& a, S_AddQuest& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AddQuest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AddQuest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AddQuest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AddQuest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AddQuest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_AddQuest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AddQuest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_AddQuest";
  }
  protected:
  explicit S_AddQuest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // .PROTOCOL.QuestInfo quest = 2;
  bool has_quest() const;
  private:
  bool _internal_has_quest() const;
  public:
  void clear_quest();
  const ::PROTOCOL::QuestInfo& quest() const;
  PROTOBUF_NODISCARD ::PROTOCOL::QuestInfo* release_quest();
  ::PROTOCOL::QuestInfo* mutable_quest();
  void set_allocated_quest(::PROTOCOL::QuestInfo* quest);
  private:
  const ::PROTOCOL::QuestInfo& _internal_quest() const;
  ::PROTOCOL::QuestInfo* _internal_mutable_quest();
  public:
  void unsafe_arena_set_allocated_quest(
      ::PROTOCOL::QuestInfo* quest);
  ::PROTOCOL::QuestInfo* unsafe_arena_release_quest();

  // bool result = 1;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_AddQuest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::QuestInfo* quest_;
  bool result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_QuestList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_QuestList) */ {
 public:
  inline S_QuestList() : S_QuestList(nullptr) {}
  ~S_QuestList() override;
  explicit constexpr S_QuestList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_QuestList(const S_QuestList& from);
  S_QuestList(S_QuestList&& from) noexcept
    : S_QuestList() {
    *this = ::std::move(from);
  }

  inline S_QuestList& operator=(const S_QuestList& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_QuestList& operator=(S_QuestList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_QuestList& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_QuestList* internal_default_instance() {
    return reinterpret_cast<const S_QuestList*>(
               &_S_QuestList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(S_QuestList& a, S_QuestList& b) {
    a.Swap(&b);
  }
  inline void Swap(S_QuestList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_QuestList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_QuestList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_QuestList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_QuestList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_QuestList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_QuestList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_QuestList";
  }
  protected:
  explicit S_QuestList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestsFieldNumber = 1,
  };
  // repeated .PROTOCOL.QuestInfo quests = 1;
  int quests_size() const;
  private:
  int _internal_quests_size() const;
  public:
  void clear_quests();
  ::PROTOCOL::QuestInfo* mutable_quests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::QuestInfo >*
      mutable_quests();
  private:
  const ::PROTOCOL::QuestInfo& _internal_quests(int index) const;
  ::PROTOCOL::QuestInfo* _internal_add_quests();
  public:
  const ::PROTOCOL::QuestInfo& quests(int index) const;
  ::PROTOCOL::QuestInfo* add_quests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::QuestInfo >&
      quests() const;

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_QuestList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::QuestInfo > quests_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_RemoveQuest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_RemoveQuest) */ {
 public:
  inline C_RemoveQuest() : C_RemoveQuest(nullptr) {}
  ~C_RemoveQuest() override;
  explicit constexpr C_RemoveQuest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_RemoveQuest(const C_RemoveQuest& from);
  C_RemoveQuest(C_RemoveQuest&& from) noexcept
    : C_RemoveQuest() {
    *this = ::std::move(from);
  }

  inline C_RemoveQuest& operator=(const C_RemoveQuest& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_RemoveQuest& operator=(C_RemoveQuest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_RemoveQuest& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_RemoveQuest* internal_default_instance() {
    return reinterpret_cast<const C_RemoveQuest*>(
               &_C_RemoveQuest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(C_RemoveQuest& a, C_RemoveQuest& b) {
    a.Swap(&b);
  }
  inline void Swap(C_RemoveQuest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_RemoveQuest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_RemoveQuest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_RemoveQuest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_RemoveQuest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_RemoveQuest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_RemoveQuest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_RemoveQuest";
  }
  protected:
  explicit C_RemoveQuest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestdbidFieldNumber = 1,
  };
  // int32 questdbid = 1;
  void clear_questdbid();
  int32_t questdbid() const;
  void set_questdbid(int32_t value);
  private:
  int32_t _internal_questdbid() const;
  void _internal_set_questdbid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_RemoveQuest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t questdbid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_RemoveQuest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_RemoveQuest) */ {
 public:
  inline S_RemoveQuest() : S_RemoveQuest(nullptr) {}
  ~S_RemoveQuest() override;
  explicit constexpr S_RemoveQuest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_RemoveQuest(const S_RemoveQuest& from);
  S_RemoveQuest(S_RemoveQuest&& from) noexcept
    : S_RemoveQuest() {
    *this = ::std::move(from);
  }

  inline S_RemoveQuest& operator=(const S_RemoveQuest& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_RemoveQuest& operator=(S_RemoveQuest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_RemoveQuest& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_RemoveQuest* internal_default_instance() {
    return reinterpret_cast<const S_RemoveQuest*>(
               &_S_RemoveQuest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(S_RemoveQuest& a, S_RemoveQuest& b) {
    a.Swap(&b);
  }
  inline void Swap(S_RemoveQuest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_RemoveQuest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_RemoveQuest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_RemoveQuest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_RemoveQuest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_RemoveQuest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_RemoveQuest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_RemoveQuest";
  }
  protected:
  explicit S_RemoveQuest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kQuestidFieldNumber = 2,
  };
  // bool result = 1;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // int32 questid = 2;
  void clear_questid();
  int32_t questid() const;
  void set_questid(int32_t value);
  private:
  int32_t _internal_questid() const;
  void _internal_set_questid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_RemoveQuest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool result_;
  int32_t questid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_CompleteQuest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_CompleteQuest) */ {
 public:
  inline C_CompleteQuest() : C_CompleteQuest(nullptr) {}
  ~C_CompleteQuest() override;
  explicit constexpr C_CompleteQuest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CompleteQuest(const C_CompleteQuest& from);
  C_CompleteQuest(C_CompleteQuest&& from) noexcept
    : C_CompleteQuest() {
    *this = ::std::move(from);
  }

  inline C_CompleteQuest& operator=(const C_CompleteQuest& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CompleteQuest& operator=(C_CompleteQuest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CompleteQuest& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CompleteQuest* internal_default_instance() {
    return reinterpret_cast<const C_CompleteQuest*>(
               &_C_CompleteQuest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(C_CompleteQuest& a, C_CompleteQuest& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CompleteQuest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CompleteQuest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CompleteQuest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CompleteQuest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CompleteQuest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_CompleteQuest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CompleteQuest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_CompleteQuest";
  }
  protected:
  explicit C_CompleteQuest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestdbidFieldNumber = 1,
  };
  // int32 questdbid = 1;
  void clear_questdbid();
  int32_t questdbid() const;
  void set_questdbid(int32_t value);
  private:
  int32_t _internal_questdbid() const;
  void _internal_set_questdbid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_CompleteQuest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t questdbid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_CompleteQuest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_CompleteQuest) */ {
 public:
  inline S_CompleteQuest() : S_CompleteQuest(nullptr) {}
  ~S_CompleteQuest() override;
  explicit constexpr S_CompleteQuest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CompleteQuest(const S_CompleteQuest& from);
  S_CompleteQuest(S_CompleteQuest&& from) noexcept
    : S_CompleteQuest() {
    *this = ::std::move(from);
  }

  inline S_CompleteQuest& operator=(const S_CompleteQuest& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CompleteQuest& operator=(S_CompleteQuest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CompleteQuest& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CompleteQuest* internal_default_instance() {
    return reinterpret_cast<const S_CompleteQuest*>(
               &_S_CompleteQuest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(S_CompleteQuest& a, S_CompleteQuest& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CompleteQuest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CompleteQuest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CompleteQuest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CompleteQuest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CompleteQuest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_CompleteQuest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CompleteQuest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_CompleteQuest";
  }
  protected:
  explicit S_CompleteQuest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kQuestidFieldNumber = 2,
  };
  // bool result = 1;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // int32 questid = 2;
  void clear_questid();
  int32_t questid() const;
  void set_questid(int32_t value);
  private:
  int32_t _internal_questid() const;
  void _internal_set_questid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_CompleteQuest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool result_;
  int32_t questid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_UpdateQuest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_UpdateQuest) */ {
 public:
  inline C_UpdateQuest() : C_UpdateQuest(nullptr) {}
  ~C_UpdateQuest() override;
  explicit constexpr C_UpdateQuest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_UpdateQuest(const C_UpdateQuest& from);
  C_UpdateQuest(C_UpdateQuest&& from) noexcept
    : C_UpdateQuest() {
    *this = ::std::move(from);
  }

  inline C_UpdateQuest& operator=(const C_UpdateQuest& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_UpdateQuest& operator=(C_UpdateQuest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_UpdateQuest& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_UpdateQuest* internal_default_instance() {
    return reinterpret_cast<const C_UpdateQuest*>(
               &_C_UpdateQuest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(C_UpdateQuest& a, C_UpdateQuest& b) {
    a.Swap(&b);
  }
  inline void Swap(C_UpdateQuest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_UpdateQuest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_UpdateQuest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_UpdateQuest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_UpdateQuest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_UpdateQuest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_UpdateQuest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_UpdateQuest";
  }
  protected:
  explicit C_UpdateQuest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestinfoFieldNumber = 1,
    kObjectidFieldNumber = 2,
  };
  // .PROTOCOL.QuestInfo questinfo = 1;
  bool has_questinfo() const;
  private:
  bool _internal_has_questinfo() const;
  public:
  void clear_questinfo();
  const ::PROTOCOL::QuestInfo& questinfo() const;
  PROTOBUF_NODISCARD ::PROTOCOL::QuestInfo* release_questinfo();
  ::PROTOCOL::QuestInfo* mutable_questinfo();
  void set_allocated_questinfo(::PROTOCOL::QuestInfo* questinfo);
  private:
  const ::PROTOCOL::QuestInfo& _internal_questinfo() const;
  ::PROTOCOL::QuestInfo* _internal_mutable_questinfo();
  public:
  void unsafe_arena_set_allocated_questinfo(
      ::PROTOCOL::QuestInfo* questinfo);
  ::PROTOCOL::QuestInfo* unsafe_arena_release_questinfo();

  // int32 objectid = 2;
  void clear_objectid();
  int32_t objectid() const;
  void set_objectid(int32_t value);
  private:
  int32_t _internal_objectid() const;
  void _internal_set_objectid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_UpdateQuest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::QuestInfo* questinfo_;
  int32_t objectid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_UpdateQuest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_UpdateQuest) */ {
 public:
  inline S_UpdateQuest() : S_UpdateQuest(nullptr) {}
  ~S_UpdateQuest() override;
  explicit constexpr S_UpdateQuest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_UpdateQuest(const S_UpdateQuest& from);
  S_UpdateQuest(S_UpdateQuest&& from) noexcept
    : S_UpdateQuest() {
    *this = ::std::move(from);
  }

  inline S_UpdateQuest& operator=(const S_UpdateQuest& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_UpdateQuest& operator=(S_UpdateQuest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_UpdateQuest& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_UpdateQuest* internal_default_instance() {
    return reinterpret_cast<const S_UpdateQuest*>(
               &_S_UpdateQuest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(S_UpdateQuest& a, S_UpdateQuest& b) {
    a.Swap(&b);
  }
  inline void Swap(S_UpdateQuest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_UpdateQuest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_UpdateQuest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_UpdateQuest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_UpdateQuest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_UpdateQuest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_UpdateQuest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_UpdateQuest";
  }
  protected:
  explicit S_UpdateQuest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestInfoFieldNumber = 1,
  };
  // .PROTOCOL.QuestInfo questInfo = 1;
  bool has_questinfo() const;
  private:
  bool _internal_has_questinfo() const;
  public:
  void clear_questinfo();
  const ::PROTOCOL::QuestInfo& questinfo() const;
  PROTOBUF_NODISCARD ::PROTOCOL::QuestInfo* release_questinfo();
  ::PROTOCOL::QuestInfo* mutable_questinfo();
  void set_allocated_questinfo(::PROTOCOL::QuestInfo* questinfo);
  private:
  const ::PROTOCOL::QuestInfo& _internal_questinfo() const;
  ::PROTOCOL::QuestInfo* _internal_mutable_questinfo();
  public:
  void unsafe_arena_set_allocated_questinfo(
      ::PROTOCOL::QuestInfo* questinfo);
  ::PROTOCOL::QuestInfo* unsafe_arena_release_questinfo();

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_UpdateQuest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::QuestInfo* questinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_Test final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_Test) */ {
 public:
  inline C_Test() : C_Test(nullptr) {}
  ~C_Test() override;
  explicit constexpr C_Test(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Test(const C_Test& from);
  C_Test(C_Test&& from) noexcept
    : C_Test() {
    *this = ::std::move(from);
  }

  inline C_Test& operator=(const C_Test& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Test& operator=(C_Test&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Test& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Test* internal_default_instance() {
    return reinterpret_cast<const C_Test*>(
               &_C_Test_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(C_Test& a, C_Test& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Test* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Test* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Test* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Test>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_Test& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_Test& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Test* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_Test";
  }
  protected:
  explicit C_Test(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestintFieldNumber = 1,
    kTestboolFieldNumber = 2,
  };
  // int32 testint = 1;
  void clear_testint();
  int32_t testint() const;
  void set_testint(int32_t value);
  private:
  int32_t _internal_testint() const;
  void _internal_set_testint(int32_t value);
  public:

  // bool testbool = 2;
  void clear_testbool();
  bool testbool() const;
  void set_testbool(bool value);
  private:
  bool _internal_testbool() const;
  void _internal_set_testbool(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_Test)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t testint_;
  bool testbool_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_Test final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_Test) */ {
 public:
  inline S_Test() : S_Test(nullptr) {}
  ~S_Test() override;
  explicit constexpr S_Test(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Test(const S_Test& from);
  S_Test(S_Test&& from) noexcept
    : S_Test() {
    *this = ::std::move(from);
  }

  inline S_Test& operator=(const S_Test& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Test& operator=(S_Test&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Test& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Test* internal_default_instance() {
    return reinterpret_cast<const S_Test*>(
               &_S_Test_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(S_Test& a, S_Test& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Test* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Test* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Test* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Test>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Test& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_Test& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Test* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_Test";
  }
  protected:
  explicit S_Test(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestintFieldNumber = 1,
    kTestboolFieldNumber = 2,
  };
  // int32 testint = 1;
  void clear_testint();
  int32_t testint() const;
  void set_testint(int32_t value);
  private:
  int32_t _internal_testint() const;
  void _internal_set_testint(int32_t value);
  public:

  // bool testbool = 2;
  void clear_testbool();
  bool testbool() const;
  void set_testbool(bool value);
  private:
  bool _internal_testbool() const;
  void _internal_set_testbool(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_Test)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t testint_;
  bool testbool_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Position

// float locationx = 1;
inline void Position::clear_locationx() {
  locationx_ = 0;
}
inline float Position::_internal_locationx() const {
  return locationx_;
}
inline float Position::locationx() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Position.locationx)
  return _internal_locationx();
}
inline void Position::_internal_set_locationx(float value) {
  
  locationx_ = value;
}
inline void Position::set_locationx(float value) {
  _internal_set_locationx(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Position.locationx)
}

// float locationy = 2;
inline void Position::clear_locationy() {
  locationy_ = 0;
}
inline float Position::_internal_locationy() const {
  return locationy_;
}
inline float Position::locationy() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Position.locationy)
  return _internal_locationy();
}
inline void Position::_internal_set_locationy(float value) {
  
  locationy_ = value;
}
inline void Position::set_locationy(float value) {
  _internal_set_locationy(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Position.locationy)
}

// float locationz = 3;
inline void Position::clear_locationz() {
  locationz_ = 0;
}
inline float Position::_internal_locationz() const {
  return locationz_;
}
inline float Position::locationz() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Position.locationz)
  return _internal_locationz();
}
inline void Position::_internal_set_locationz(float value) {
  
  locationz_ = value;
}
inline void Position::set_locationz(float value) {
  _internal_set_locationz(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Position.locationz)
}

// float rotationyaw = 4;
inline void Position::clear_rotationyaw() {
  rotationyaw_ = 0;
}
inline float Position::_internal_rotationyaw() const {
  return rotationyaw_;
}
inline float Position::rotationyaw() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Position.rotationyaw)
  return _internal_rotationyaw();
}
inline void Position::_internal_set_rotationyaw(float value) {
  
  rotationyaw_ = value;
}
inline void Position::set_rotationyaw(float value) {
  _internal_set_rotationyaw(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Position.rotationyaw)
}

// float rotationpitch = 5;
inline void Position::clear_rotationpitch() {
  rotationpitch_ = 0;
}
inline float Position::_internal_rotationpitch() const {
  return rotationpitch_;
}
inline float Position::rotationpitch() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Position.rotationpitch)
  return _internal_rotationpitch();
}
inline void Position::_internal_set_rotationpitch(float value) {
  
  rotationpitch_ = value;
}
inline void Position::set_rotationpitch(float value) {
  _internal_set_rotationpitch(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Position.rotationpitch)
}

// float rotationroll = 6;
inline void Position::clear_rotationroll() {
  rotationroll_ = 0;
}
inline float Position::_internal_rotationroll() const {
  return rotationroll_;
}
inline float Position::rotationroll() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Position.rotationroll)
  return _internal_rotationroll();
}
inline void Position::_internal_set_rotationroll(float value) {
  
  rotationroll_ = value;
}
inline void Position::set_rotationroll(float value) {
  _internal_set_rotationroll(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Position.rotationroll)
}

// float velocityx = 7;
inline void Position::clear_velocityx() {
  velocityx_ = 0;
}
inline float Position::_internal_velocityx() const {
  return velocityx_;
}
inline float Position::velocityx() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Position.velocityx)
  return _internal_velocityx();
}
inline void Position::_internal_set_velocityx(float value) {
  
  velocityx_ = value;
}
inline void Position::set_velocityx(float value) {
  _internal_set_velocityx(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Position.velocityx)
}

// float velocityy = 8;
inline void Position::clear_velocityy() {
  velocityy_ = 0;
}
inline float Position::_internal_velocityy() const {
  return velocityy_;
}
inline float Position::velocityy() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Position.velocityy)
  return _internal_velocityy();
}
inline void Position::_internal_set_velocityy(float value) {
  
  velocityy_ = value;
}
inline void Position::set_velocityy(float value) {
  _internal_set_velocityy(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Position.velocityy)
}

// float velocityz = 9;
inline void Position::clear_velocityz() {
  velocityz_ = 0;
}
inline float Position::_internal_velocityz() const {
  return velocityz_;
}
inline float Position::velocityz() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Position.velocityz)
  return _internal_velocityz();
}
inline void Position::_internal_set_velocityz(float value) {
  
  velocityz_ = value;
}
inline void Position::set_velocityz(float value) {
  _internal_set_velocityz(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Position.velocityz)
}

// -------------------------------------------------------------------

// Stat

// int32 level = 1;
inline void Stat::clear_level() {
  level_ = 0;
}
inline int32_t Stat::_internal_level() const {
  return level_;
}
inline int32_t Stat::level() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.level)
  return _internal_level();
}
inline void Stat::_internal_set_level(int32_t value) {
  
  level_ = value;
}
inline void Stat::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.level)
}

// int32 totalExp = 2;
inline void Stat::clear_totalexp() {
  totalexp_ = 0;
}
inline int32_t Stat::_internal_totalexp() const {
  return totalexp_;
}
inline int32_t Stat::totalexp() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.totalExp)
  return _internal_totalexp();
}
inline void Stat::_internal_set_totalexp(int32_t value) {
  
  totalexp_ = value;
}
inline void Stat::set_totalexp(int32_t value) {
  _internal_set_totalexp(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.totalExp)
}

// int32 exp = 3;
inline void Stat::clear_exp() {
  exp_ = 0;
}
inline int32_t Stat::_internal_exp() const {
  return exp_;
}
inline int32_t Stat::exp() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.exp)
  return _internal_exp();
}
inline void Stat::_internal_set_exp(int32_t value) {
  
  exp_ = value;
}
inline void Stat::set_exp(int32_t value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.exp)
}

// int32 maxhp = 4;
inline void Stat::clear_maxhp() {
  maxhp_ = 0;
}
inline int32_t Stat::_internal_maxhp() const {
  return maxhp_;
}
inline int32_t Stat::maxhp() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.maxhp)
  return _internal_maxhp();
}
inline void Stat::_internal_set_maxhp(int32_t value) {
  
  maxhp_ = value;
}
inline void Stat::set_maxhp(int32_t value) {
  _internal_set_maxhp(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.maxhp)
}

// int32 hp = 5;
inline void Stat::clear_hp() {
  hp_ = 0;
}
inline int32_t Stat::_internal_hp() const {
  return hp_;
}
inline int32_t Stat::hp() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.hp)
  return _internal_hp();
}
inline void Stat::_internal_set_hp(int32_t value) {
  
  hp_ = value;
}
inline void Stat::set_hp(int32_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.hp)
}

// int32 damage = 6;
inline void Stat::clear_damage() {
  damage_ = 0;
}
inline int32_t Stat::_internal_damage() const {
  return damage_;
}
inline int32_t Stat::damage() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.damage)
  return _internal_damage();
}
inline void Stat::_internal_set_damage(int32_t value) {
  
  damage_ = value;
}
inline void Stat::set_damage(int32_t value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.damage)
}

// int32 defence = 7;
inline void Stat::clear_defence() {
  defence_ = 0;
}
inline int32_t Stat::_internal_defence() const {
  return defence_;
}
inline int32_t Stat::defence() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.defence)
  return _internal_defence();
}
inline void Stat::_internal_set_defence(int32_t value) {
  
  defence_ = value;
}
inline void Stat::set_defence(int32_t value) {
  _internal_set_defence(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.defence)
}

// float speed = 8;
inline void Stat::clear_speed() {
  speed_ = 0;
}
inline float Stat::_internal_speed() const {
  return speed_;
}
inline float Stat::speed() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.speed)
  return _internal_speed();
}
inline void Stat::_internal_set_speed(float value) {
  
  speed_ = value;
}
inline void Stat::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.speed)
}

// float attackdistance = 9;
inline void Stat::clear_attackdistance() {
  attackdistance_ = 0;
}
inline float Stat::_internal_attackdistance() const {
  return attackdistance_;
}
inline float Stat::attackdistance() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.attackdistance)
  return _internal_attackdistance();
}
inline void Stat::_internal_set_attackdistance(float value) {
  
  attackdistance_ = value;
}
inline void Stat::set_attackdistance(float value) {
  _internal_set_attackdistance(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.attackdistance)
}

// float noticedistance = 10;
inline void Stat::clear_noticedistance() {
  noticedistance_ = 0;
}
inline float Stat::_internal_noticedistance() const {
  return noticedistance_;
}
inline float Stat::noticedistance() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.noticedistance)
  return _internal_noticedistance();
}
inline void Stat::_internal_set_noticedistance(float value) {
  
  noticedistance_ = value;
}
inline void Stat::set_noticedistance(float value) {
  _internal_set_noticedistance(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.noticedistance)
}

// float returndistance = 11;
inline void Stat::clear_returndistance() {
  returndistance_ = 0;
}
inline float Stat::_internal_returndistance() const {
  return returndistance_;
}
inline float Stat::returndistance() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.returndistance)
  return _internal_returndistance();
}
inline void Stat::_internal_set_returndistance(float value) {
  
  returndistance_ = value;
}
inline void Stat::set_returndistance(float value) {
  _internal_set_returndistance(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.returndistance)
}

// float attackcooltime = 12;
inline void Stat::clear_attackcooltime() {
  attackcooltime_ = 0;
}
inline float Stat::_internal_attackcooltime() const {
  return attackcooltime_;
}
inline float Stat::attackcooltime() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.attackcooltime)
  return _internal_attackcooltime();
}
inline void Stat::_internal_set_attackcooltime(float value) {
  
  attackcooltime_ = value;
}
inline void Stat::set_attackcooltime(float value) {
  _internal_set_attackcooltime(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.attackcooltime)
}

// -------------------------------------------------------------------

// ObjectInfo

// int32 objectId = 1;
inline void ObjectInfo::clear_objectid() {
  objectid_ = 0;
}
inline int32_t ObjectInfo::_internal_objectid() const {
  return objectid_;
}
inline int32_t ObjectInfo::objectid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ObjectInfo.objectId)
  return _internal_objectid();
}
inline void ObjectInfo::_internal_set_objectid(int32_t value) {
  
  objectid_ = value;
}
inline void ObjectInfo::set_objectid(int32_t value) {
  _internal_set_objectid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ObjectInfo.objectId)
}

// int32 playerdbid = 2;
inline void ObjectInfo::clear_playerdbid() {
  playerdbid_ = 0;
}
inline int32_t ObjectInfo::_internal_playerdbid() const {
  return playerdbid_;
}
inline int32_t ObjectInfo::playerdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ObjectInfo.playerdbid)
  return _internal_playerdbid();
}
inline void ObjectInfo::_internal_set_playerdbid(int32_t value) {
  
  playerdbid_ = value;
}
inline void ObjectInfo::set_playerdbid(int32_t value) {
  _internal_set_playerdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ObjectInfo.playerdbid)
}

// string name = 3;
inline void ObjectInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ObjectInfo::name() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ObjectInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PROTOCOL.ObjectInfo.name)
}
inline std::string* ObjectInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.ObjectInfo.name)
  return _s;
}
inline const std::string& ObjectInfo::_internal_name() const {
  return name_.Get();
}
inline void ObjectInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ObjectInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ObjectInfo::release_name() {
  // @@protoc_insertion_point(field_release:PROTOCOL.ObjectInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ObjectInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.ObjectInfo.name)
}

// .PROTOCOL.GameObjectType objecttype = 4;
inline void ObjectInfo::clear_objecttype() {
  objecttype_ = 0;
}
inline ::PROTOCOL::GameObjectType ObjectInfo::_internal_objecttype() const {
  return static_cast< ::PROTOCOL::GameObjectType >(objecttype_);
}
inline ::PROTOCOL::GameObjectType ObjectInfo::objecttype() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ObjectInfo.objecttype)
  return _internal_objecttype();
}
inline void ObjectInfo::_internal_set_objecttype(::PROTOCOL::GameObjectType value) {
  
  objecttype_ = value;
}
inline void ObjectInfo::set_objecttype(::PROTOCOL::GameObjectType value) {
  _internal_set_objecttype(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ObjectInfo.objecttype)
}

// int32 typetemplateid = 5;
inline void ObjectInfo::clear_typetemplateid() {
  typetemplateid_ = 0;
}
inline int32_t ObjectInfo::_internal_typetemplateid() const {
  return typetemplateid_;
}
inline int32_t ObjectInfo::typetemplateid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ObjectInfo.typetemplateid)
  return _internal_typetemplateid();
}
inline void ObjectInfo::_internal_set_typetemplateid(int32_t value) {
  
  typetemplateid_ = value;
}
inline void ObjectInfo::set_typetemplateid(int32_t value) {
  _internal_set_typetemplateid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ObjectInfo.typetemplateid)
}

// .PROTOCOL.Position pos = 6;
inline bool ObjectInfo::_internal_has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline bool ObjectInfo::has_pos() const {
  return _internal_has_pos();
}
inline void ObjectInfo::clear_pos() {
  if (GetArenaForAllocation() == nullptr && pos_ != nullptr) {
    delete pos_;
  }
  pos_ = nullptr;
}
inline const ::PROTOCOL::Position& ObjectInfo::_internal_pos() const {
  const ::PROTOCOL::Position* p = pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::Position&>(
      ::PROTOCOL::_Position_default_instance_);
}
inline const ::PROTOCOL::Position& ObjectInfo::pos() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ObjectInfo.pos)
  return _internal_pos();
}
inline void ObjectInfo::unsafe_arena_set_allocated_pos(
    ::PROTOCOL::Position* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.ObjectInfo.pos)
}
inline ::PROTOCOL::Position* ObjectInfo::release_pos() {
  
  ::PROTOCOL::Position* temp = pos_;
  pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::Position* ObjectInfo::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:PROTOCOL.ObjectInfo.pos)
  
  ::PROTOCOL::Position* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::PROTOCOL::Position* ObjectInfo::_internal_mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::Position>(GetArenaForAllocation());
    pos_ = p;
  }
  return pos_;
}
inline ::PROTOCOL::Position* ObjectInfo::mutable_pos() {
  ::PROTOCOL::Position* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.ObjectInfo.pos)
  return _msg;
}
inline void ObjectInfo::set_allocated_pos(::PROTOCOL::Position* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::Position>::GetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.ObjectInfo.pos)
}

// .PROTOCOL.Stat stat = 7;
inline bool ObjectInfo::_internal_has_stat() const {
  return this != internal_default_instance() && stat_ != nullptr;
}
inline bool ObjectInfo::has_stat() const {
  return _internal_has_stat();
}
inline void ObjectInfo::clear_stat() {
  if (GetArenaForAllocation() == nullptr && stat_ != nullptr) {
    delete stat_;
  }
  stat_ = nullptr;
}
inline const ::PROTOCOL::Stat& ObjectInfo::_internal_stat() const {
  const ::PROTOCOL::Stat* p = stat_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::Stat&>(
      ::PROTOCOL::_Stat_default_instance_);
}
inline const ::PROTOCOL::Stat& ObjectInfo::stat() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ObjectInfo.stat)
  return _internal_stat();
}
inline void ObjectInfo::unsafe_arena_set_allocated_stat(
    ::PROTOCOL::Stat* stat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stat_);
  }
  stat_ = stat;
  if (stat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.ObjectInfo.stat)
}
inline ::PROTOCOL::Stat* ObjectInfo::release_stat() {
  
  ::PROTOCOL::Stat* temp = stat_;
  stat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::Stat* ObjectInfo::unsafe_arena_release_stat() {
  // @@protoc_insertion_point(field_release:PROTOCOL.ObjectInfo.stat)
  
  ::PROTOCOL::Stat* temp = stat_;
  stat_ = nullptr;
  return temp;
}
inline ::PROTOCOL::Stat* ObjectInfo::_internal_mutable_stat() {
  
  if (stat_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::Stat>(GetArenaForAllocation());
    stat_ = p;
  }
  return stat_;
}
inline ::PROTOCOL::Stat* ObjectInfo::mutable_stat() {
  ::PROTOCOL::Stat* _msg = _internal_mutable_stat();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.ObjectInfo.stat)
  return _msg;
}
inline void ObjectInfo::set_allocated_stat(::PROTOCOL::Stat* stat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete stat_;
  }
  if (stat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::Stat>::GetOwningArena(stat);
    if (message_arena != submessage_arena) {
      stat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stat, submessage_arena);
    }
    
  } else {
    
  }
  stat_ = stat;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.ObjectInfo.stat)
}

// -------------------------------------------------------------------

// LobbyPlayerInfo

// int32 playerdbid = 1;
inline void LobbyPlayerInfo::clear_playerdbid() {
  playerdbid_ = 0;
}
inline int32_t LobbyPlayerInfo::_internal_playerdbid() const {
  return playerdbid_;
}
inline int32_t LobbyPlayerInfo::playerdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.LobbyPlayerInfo.playerdbid)
  return _internal_playerdbid();
}
inline void LobbyPlayerInfo::_internal_set_playerdbid(int32_t value) {
  
  playerdbid_ = value;
}
inline void LobbyPlayerInfo::set_playerdbid(int32_t value) {
  _internal_set_playerdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.LobbyPlayerInfo.playerdbid)
}

// string name = 2;
inline void LobbyPlayerInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& LobbyPlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.LobbyPlayerInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LobbyPlayerInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PROTOCOL.LobbyPlayerInfo.name)
}
inline std::string* LobbyPlayerInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.LobbyPlayerInfo.name)
  return _s;
}
inline const std::string& LobbyPlayerInfo::_internal_name() const {
  return name_.Get();
}
inline void LobbyPlayerInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LobbyPlayerInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LobbyPlayerInfo::release_name() {
  // @@protoc_insertion_point(field_release:PROTOCOL.LobbyPlayerInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LobbyPlayerInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.LobbyPlayerInfo.name)
}

// .PROTOCOL.Stat stat = 3;
inline bool LobbyPlayerInfo::_internal_has_stat() const {
  return this != internal_default_instance() && stat_ != nullptr;
}
inline bool LobbyPlayerInfo::has_stat() const {
  return _internal_has_stat();
}
inline void LobbyPlayerInfo::clear_stat() {
  if (GetArenaForAllocation() == nullptr && stat_ != nullptr) {
    delete stat_;
  }
  stat_ = nullptr;
}
inline const ::PROTOCOL::Stat& LobbyPlayerInfo::_internal_stat() const {
  const ::PROTOCOL::Stat* p = stat_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::Stat&>(
      ::PROTOCOL::_Stat_default_instance_);
}
inline const ::PROTOCOL::Stat& LobbyPlayerInfo::stat() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.LobbyPlayerInfo.stat)
  return _internal_stat();
}
inline void LobbyPlayerInfo::unsafe_arena_set_allocated_stat(
    ::PROTOCOL::Stat* stat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stat_);
  }
  stat_ = stat;
  if (stat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.LobbyPlayerInfo.stat)
}
inline ::PROTOCOL::Stat* LobbyPlayerInfo::release_stat() {
  
  ::PROTOCOL::Stat* temp = stat_;
  stat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::Stat* LobbyPlayerInfo::unsafe_arena_release_stat() {
  // @@protoc_insertion_point(field_release:PROTOCOL.LobbyPlayerInfo.stat)
  
  ::PROTOCOL::Stat* temp = stat_;
  stat_ = nullptr;
  return temp;
}
inline ::PROTOCOL::Stat* LobbyPlayerInfo::_internal_mutable_stat() {
  
  if (stat_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::Stat>(GetArenaForAllocation());
    stat_ = p;
  }
  return stat_;
}
inline ::PROTOCOL::Stat* LobbyPlayerInfo::mutable_stat() {
  ::PROTOCOL::Stat* _msg = _internal_mutable_stat();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.LobbyPlayerInfo.stat)
  return _msg;
}
inline void LobbyPlayerInfo::set_allocated_stat(::PROTOCOL::Stat* stat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete stat_;
  }
  if (stat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::Stat>::GetOwningArena(stat);
    if (message_arena != submessage_arena) {
      stat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stat, submessage_arena);
    }
    
  } else {
    
  }
  stat_ = stat;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.LobbyPlayerInfo.stat)
}

// -------------------------------------------------------------------

// Skill

// int32 skillId = 1;
inline void Skill::clear_skillid() {
  skillid_ = 0;
}
inline int32_t Skill::_internal_skillid() const {
  return skillid_;
}
inline int32_t Skill::skillid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Skill.skillId)
  return _internal_skillid();
}
inline void Skill::_internal_set_skillid(int32_t value) {
  
  skillid_ = value;
}
inline void Skill::set_skillid(int32_t value) {
  _internal_set_skillid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Skill.skillId)
}

// -------------------------------------------------------------------

// ItemInfo

// int32 itemDbId = 1;
inline void ItemInfo::clear_itemdbid() {
  itemdbid_ = 0;
}
inline int32_t ItemInfo::_internal_itemdbid() const {
  return itemdbid_;
}
inline int32_t ItemInfo::itemdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ItemInfo.itemDbId)
  return _internal_itemdbid();
}
inline void ItemInfo::_internal_set_itemdbid(int32_t value) {
  
  itemdbid_ = value;
}
inline void ItemInfo::set_itemdbid(int32_t value) {
  _internal_set_itemdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ItemInfo.itemDbId)
}

// int32 templateId = 2;
inline void ItemInfo::clear_templateid() {
  templateid_ = 0;
}
inline int32_t ItemInfo::_internal_templateid() const {
  return templateid_;
}
inline int32_t ItemInfo::templateid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ItemInfo.templateId)
  return _internal_templateid();
}
inline void ItemInfo::_internal_set_templateid(int32_t value) {
  
  templateid_ = value;
}
inline void ItemInfo::set_templateid(int32_t value) {
  _internal_set_templateid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ItemInfo.templateId)
}

// int32 count = 3;
inline void ItemInfo::clear_count() {
  count_ = 0;
}
inline int32_t ItemInfo::_internal_count() const {
  return count_;
}
inline int32_t ItemInfo::count() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ItemInfo.count)
  return _internal_count();
}
inline void ItemInfo::_internal_set_count(int32_t value) {
  
  count_ = value;
}
inline void ItemInfo::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ItemInfo.count)
}

// int32 slot = 4;
inline void ItemInfo::clear_slot() {
  slot_ = 0;
}
inline int32_t ItemInfo::_internal_slot() const {
  return slot_;
}
inline int32_t ItemInfo::slot() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ItemInfo.slot)
  return _internal_slot();
}
inline void ItemInfo::_internal_set_slot(int32_t value) {
  
  slot_ = value;
}
inline void ItemInfo::set_slot(int32_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ItemInfo.slot)
}

// bool equipped = 5;
inline void ItemInfo::clear_equipped() {
  equipped_ = false;
}
inline bool ItemInfo::_internal_equipped() const {
  return equipped_;
}
inline bool ItemInfo::equipped() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ItemInfo.equipped)
  return _internal_equipped();
}
inline void ItemInfo::_internal_set_equipped(bool value) {
  
  equipped_ = value;
}
inline void ItemInfo::set_equipped(bool value) {
  _internal_set_equipped(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ItemInfo.equipped)
}

// int32 playerdbid = 6;
inline void ItemInfo::clear_playerdbid() {
  playerdbid_ = 0;
}
inline int32_t ItemInfo::_internal_playerdbid() const {
  return playerdbid_;
}
inline int32_t ItemInfo::playerdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ItemInfo.playerdbid)
  return _internal_playerdbid();
}
inline void ItemInfo::_internal_set_playerdbid(int32_t value) {
  
  playerdbid_ = value;
}
inline void ItemInfo::set_playerdbid(int32_t value) {
  _internal_set_playerdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ItemInfo.playerdbid)
}

// -------------------------------------------------------------------

// QuestInfo

// int32 questdbid = 1;
inline void QuestInfo::clear_questdbid() {
  questdbid_ = 0;
}
inline int32_t QuestInfo::_internal_questdbid() const {
  return questdbid_;
}
inline int32_t QuestInfo::questdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.QuestInfo.questdbid)
  return _internal_questdbid();
}
inline void QuestInfo::_internal_set_questdbid(int32_t value) {
  
  questdbid_ = value;
}
inline void QuestInfo::set_questdbid(int32_t value) {
  _internal_set_questdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.QuestInfo.questdbid)
}

// int32 templateid = 2;
inline void QuestInfo::clear_templateid() {
  templateid_ = 0;
}
inline int32_t QuestInfo::_internal_templateid() const {
  return templateid_;
}
inline int32_t QuestInfo::templateid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.QuestInfo.templateid)
  return _internal_templateid();
}
inline void QuestInfo::_internal_set_templateid(int32_t value) {
  
  templateid_ = value;
}
inline void QuestInfo::set_templateid(int32_t value) {
  _internal_set_templateid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.QuestInfo.templateid)
}

// int32 progress = 3;
inline void QuestInfo::clear_progress() {
  progress_ = 0;
}
inline int32_t QuestInfo::_internal_progress() const {
  return progress_;
}
inline int32_t QuestInfo::progress() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.QuestInfo.progress)
  return _internal_progress();
}
inline void QuestInfo::_internal_set_progress(int32_t value) {
  
  progress_ = value;
}
inline void QuestInfo::set_progress(int32_t value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.QuestInfo.progress)
}

// bool completed = 4;
inline void QuestInfo::clear_completed() {
  completed_ = false;
}
inline bool QuestInfo::_internal_completed() const {
  return completed_;
}
inline bool QuestInfo::completed() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.QuestInfo.completed)
  return _internal_completed();
}
inline void QuestInfo::_internal_set_completed(bool value) {
  
  completed_ = value;
}
inline void QuestInfo::set_completed(bool value) {
  _internal_set_completed(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.QuestInfo.completed)
}

// int32 playerdbid = 5;
inline void QuestInfo::clear_playerdbid() {
  playerdbid_ = 0;
}
inline int32_t QuestInfo::_internal_playerdbid() const {
  return playerdbid_;
}
inline int32_t QuestInfo::playerdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.QuestInfo.playerdbid)
  return _internal_playerdbid();
}
inline void QuestInfo::_internal_set_playerdbid(int32_t value) {
  
  playerdbid_ = value;
}
inline void QuestInfo::set_playerdbid(int32_t value) {
  _internal_set_playerdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.QuestInfo.playerdbid)
}

// -------------------------------------------------------------------

// C_Login

// string id = 1;
inline void C_Login::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& C_Login::id() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_Login.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_Login::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PROTOCOL.C_Login.id)
}
inline std::string* C_Login::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_Login.id)
  return _s;
}
inline const std::string& C_Login::_internal_id() const {
  return id_.Get();
}
inline void C_Login::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_Login::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_Login::release_id() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_Login.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_Login::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_Login.id)
}

// string pw = 2;
inline void C_Login::clear_pw() {
  pw_.ClearToEmpty();
}
inline const std::string& C_Login::pw() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_Login.pw)
  return _internal_pw();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_Login::set_pw(ArgT0&& arg0, ArgT... args) {
 
 pw_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PROTOCOL.C_Login.pw)
}
inline std::string* C_Login::mutable_pw() {
  std::string* _s = _internal_mutable_pw();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_Login.pw)
  return _s;
}
inline const std::string& C_Login::_internal_pw() const {
  return pw_.Get();
}
inline void C_Login::_internal_set_pw(const std::string& value) {
  
  pw_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_Login::_internal_mutable_pw() {
  
  return pw_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_Login::release_pw() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_Login.pw)
  return pw_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_Login::set_allocated_pw(std::string* pw) {
  if (pw != nullptr) {
    
  } else {
    
  }
  pw_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pw,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pw_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pw_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_Login.pw)
}

// string tokenstring = 3;
inline void C_Login::clear_tokenstring() {
  tokenstring_.ClearToEmpty();
}
inline const std::string& C_Login::tokenstring() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_Login.tokenstring)
  return _internal_tokenstring();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_Login::set_tokenstring(ArgT0&& arg0, ArgT... args) {
 
 tokenstring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PROTOCOL.C_Login.tokenstring)
}
inline std::string* C_Login::mutable_tokenstring() {
  std::string* _s = _internal_mutable_tokenstring();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_Login.tokenstring)
  return _s;
}
inline const std::string& C_Login::_internal_tokenstring() const {
  return tokenstring_.Get();
}
inline void C_Login::_internal_set_tokenstring(const std::string& value) {
  
  tokenstring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_Login::_internal_mutable_tokenstring() {
  
  return tokenstring_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_Login::release_tokenstring() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_Login.tokenstring)
  return tokenstring_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_Login::set_allocated_tokenstring(std::string* tokenstring) {
  if (tokenstring != nullptr) {
    
  } else {
    
  }
  tokenstring_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tokenstring,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tokenstring_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tokenstring_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_Login.tokenstring)
}

// -------------------------------------------------------------------

// S_Login

// bool success = 1;
inline void S_Login::clear_success() {
  success_ = false;
}
inline bool S_Login::_internal_success() const {
  return success_;
}
inline bool S_Login::success() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Login.success)
  return _internal_success();
}
inline void S_Login::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void S_Login::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_Login.success)
}

// repeated .PROTOCOL.ObjectInfo objectinfos = 2;
inline int S_Login::_internal_objectinfos_size() const {
  return objectinfos_.size();
}
inline int S_Login::objectinfos_size() const {
  return _internal_objectinfos_size();
}
inline void S_Login::clear_objectinfos() {
  objectinfos_.Clear();
}
inline ::PROTOCOL::ObjectInfo* S_Login::mutable_objectinfos(int index) {
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_Login.objectinfos)
  return objectinfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo >*
S_Login::mutable_objectinfos() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_Login.objectinfos)
  return &objectinfos_;
}
inline const ::PROTOCOL::ObjectInfo& S_Login::_internal_objectinfos(int index) const {
  return objectinfos_.Get(index);
}
inline const ::PROTOCOL::ObjectInfo& S_Login::objectinfos(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Login.objectinfos)
  return _internal_objectinfos(index);
}
inline ::PROTOCOL::ObjectInfo* S_Login::_internal_add_objectinfos() {
  return objectinfos_.Add();
}
inline ::PROTOCOL::ObjectInfo* S_Login::add_objectinfos() {
  ::PROTOCOL::ObjectInfo* _add = _internal_add_objectinfos();
  // @@protoc_insertion_point(field_add:PROTOCOL.S_Login.objectinfos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo >&
S_Login::objectinfos() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_Login.objectinfos)
  return objectinfos_;
}

// repeated .PROTOCOL.LobbyPlayerInfo lobbyplayerinfos = 3;
inline int S_Login::_internal_lobbyplayerinfos_size() const {
  return lobbyplayerinfos_.size();
}
inline int S_Login::lobbyplayerinfos_size() const {
  return _internal_lobbyplayerinfos_size();
}
inline void S_Login::clear_lobbyplayerinfos() {
  lobbyplayerinfos_.Clear();
}
inline ::PROTOCOL::LobbyPlayerInfo* S_Login::mutable_lobbyplayerinfos(int index) {
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_Login.lobbyplayerinfos)
  return lobbyplayerinfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::LobbyPlayerInfo >*
S_Login::mutable_lobbyplayerinfos() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_Login.lobbyplayerinfos)
  return &lobbyplayerinfos_;
}
inline const ::PROTOCOL::LobbyPlayerInfo& S_Login::_internal_lobbyplayerinfos(int index) const {
  return lobbyplayerinfos_.Get(index);
}
inline const ::PROTOCOL::LobbyPlayerInfo& S_Login::lobbyplayerinfos(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Login.lobbyplayerinfos)
  return _internal_lobbyplayerinfos(index);
}
inline ::PROTOCOL::LobbyPlayerInfo* S_Login::_internal_add_lobbyplayerinfos() {
  return lobbyplayerinfos_.Add();
}
inline ::PROTOCOL::LobbyPlayerInfo* S_Login::add_lobbyplayerinfos() {
  ::PROTOCOL::LobbyPlayerInfo* _add = _internal_add_lobbyplayerinfos();
  // @@protoc_insertion_point(field_add:PROTOCOL.S_Login.lobbyplayerinfos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::LobbyPlayerInfo >&
S_Login::lobbyplayerinfos() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_Login.lobbyplayerinfos)
  return lobbyplayerinfos_;
}

// -------------------------------------------------------------------

// C_Enter_Room

// uint64 roomNum = 1;
inline void C_Enter_Room::clear_roomnum() {
  roomnum_ = uint64_t{0u};
}
inline uint64_t C_Enter_Room::_internal_roomnum() const {
  return roomnum_;
}
inline uint64_t C_Enter_Room::roomnum() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_Enter_Room.roomNum)
  return _internal_roomnum();
}
inline void C_Enter_Room::_internal_set_roomnum(uint64_t value) {
  
  roomnum_ = value;
}
inline void C_Enter_Room::set_roomnum(uint64_t value) {
  _internal_set_roomnum(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_Enter_Room.roomNum)
}

// .PROTOCOL.ObjectInfo object = 2;
inline bool C_Enter_Room::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool C_Enter_Room::has_object() const {
  return _internal_has_object();
}
inline void C_Enter_Room::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& C_Enter_Room::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& C_Enter_Room::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_Enter_Room.object)
  return _internal_object();
}
inline void C_Enter_Room::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.C_Enter_Room.object)
}
inline ::PROTOCOL::ObjectInfo* C_Enter_Room::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* C_Enter_Room::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_Enter_Room.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* C_Enter_Room::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* C_Enter_Room::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_Enter_Room.object)
  return _msg;
}
inline void C_Enter_Room::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_Enter_Room.object)
}

// -------------------------------------------------------------------

// S_Enter_Room

// bool success = 1;
inline void S_Enter_Room::clear_success() {
  success_ = false;
}
inline bool S_Enter_Room::_internal_success() const {
  return success_;
}
inline bool S_Enter_Room::success() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Enter_Room.success)
  return _internal_success();
}
inline void S_Enter_Room::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void S_Enter_Room::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_Enter_Room.success)
}

// .PROTOCOL.ObjectInfo object = 2;
inline bool S_Enter_Room::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool S_Enter_Room::has_object() const {
  return _internal_has_object();
}
inline void S_Enter_Room::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& S_Enter_Room::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& S_Enter_Room::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Enter_Room.object)
  return _internal_object();
}
inline void S_Enter_Room::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_Enter_Room.object)
}
inline ::PROTOCOL::ObjectInfo* S_Enter_Room::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_Enter_Room::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_Enter_Room.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_Enter_Room::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* S_Enter_Room::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_Enter_Room.object)
  return _msg;
}
inline void S_Enter_Room::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_Enter_Room.object)
}

// repeated .PROTOCOL.ItemInfo items = 3;
inline int S_Enter_Room::_internal_items_size() const {
  return items_.size();
}
inline int S_Enter_Room::items_size() const {
  return _internal_items_size();
}
inline void S_Enter_Room::clear_items() {
  items_.Clear();
}
inline ::PROTOCOL::ItemInfo* S_Enter_Room::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_Enter_Room.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
S_Enter_Room::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_Enter_Room.items)
  return &items_;
}
inline const ::PROTOCOL::ItemInfo& S_Enter_Room::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::PROTOCOL::ItemInfo& S_Enter_Room::items(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Enter_Room.items)
  return _internal_items(index);
}
inline ::PROTOCOL::ItemInfo* S_Enter_Room::_internal_add_items() {
  return items_.Add();
}
inline ::PROTOCOL::ItemInfo* S_Enter_Room::add_items() {
  ::PROTOCOL::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:PROTOCOL.S_Enter_Room.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
S_Enter_Room::items() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_Enter_Room.items)
  return items_;
}

// -------------------------------------------------------------------

// C_Leave_Room

// .PROTOCOL.ObjectInfo object = 1;
inline bool C_Leave_Room::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool C_Leave_Room::has_object() const {
  return _internal_has_object();
}
inline void C_Leave_Room::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& C_Leave_Room::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& C_Leave_Room::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_Leave_Room.object)
  return _internal_object();
}
inline void C_Leave_Room::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.C_Leave_Room.object)
}
inline ::PROTOCOL::ObjectInfo* C_Leave_Room::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* C_Leave_Room::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_Leave_Room.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* C_Leave_Room::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* C_Leave_Room::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_Leave_Room.object)
  return _msg;
}
inline void C_Leave_Room::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_Leave_Room.object)
}

// -------------------------------------------------------------------

// S_Leave_Room

// bool success = 1;
inline void S_Leave_Room::clear_success() {
  success_ = false;
}
inline bool S_Leave_Room::_internal_success() const {
  return success_;
}
inline bool S_Leave_Room::success() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Leave_Room.success)
  return _internal_success();
}
inline void S_Leave_Room::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void S_Leave_Room::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_Leave_Room.success)
}

// .PROTOCOL.ObjectInfo object = 2;
inline bool S_Leave_Room::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool S_Leave_Room::has_object() const {
  return _internal_has_object();
}
inline void S_Leave_Room::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& S_Leave_Room::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& S_Leave_Room::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Leave_Room.object)
  return _internal_object();
}
inline void S_Leave_Room::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_Leave_Room.object)
}
inline ::PROTOCOL::ObjectInfo* S_Leave_Room::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_Leave_Room::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_Leave_Room.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_Leave_Room::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* S_Leave_Room::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_Leave_Room.object)
  return _msg;
}
inline void S_Leave_Room::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_Leave_Room.object)
}

// -------------------------------------------------------------------

// C_Spawn

// .PROTOCOL.ObjectInfo object = 1;
inline bool C_Spawn::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool C_Spawn::has_object() const {
  return _internal_has_object();
}
inline void C_Spawn::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& C_Spawn::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& C_Spawn::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_Spawn.object)
  return _internal_object();
}
inline void C_Spawn::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.C_Spawn.object)
}
inline ::PROTOCOL::ObjectInfo* C_Spawn::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* C_Spawn::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_Spawn.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* C_Spawn::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* C_Spawn::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_Spawn.object)
  return _msg;
}
inline void C_Spawn::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_Spawn.object)
}

// -------------------------------------------------------------------

// S_Spawn

// bool success = 1;
inline void S_Spawn::clear_success() {
  success_ = false;
}
inline bool S_Spawn::_internal_success() const {
  return success_;
}
inline bool S_Spawn::success() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Spawn.success)
  return _internal_success();
}
inline void S_Spawn::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void S_Spawn::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_Spawn.success)
}

// repeated .PROTOCOL.ObjectInfo object = 2;
inline int S_Spawn::_internal_object_size() const {
  return object_.size();
}
inline int S_Spawn::object_size() const {
  return _internal_object_size();
}
inline void S_Spawn::clear_object() {
  object_.Clear();
}
inline ::PROTOCOL::ObjectInfo* S_Spawn::mutable_object(int index) {
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_Spawn.object)
  return object_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo >*
S_Spawn::mutable_object() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_Spawn.object)
  return &object_;
}
inline const ::PROTOCOL::ObjectInfo& S_Spawn::_internal_object(int index) const {
  return object_.Get(index);
}
inline const ::PROTOCOL::ObjectInfo& S_Spawn::object(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Spawn.object)
  return _internal_object(index);
}
inline ::PROTOCOL::ObjectInfo* S_Spawn::_internal_add_object() {
  return object_.Add();
}
inline ::PROTOCOL::ObjectInfo* S_Spawn::add_object() {
  ::PROTOCOL::ObjectInfo* _add = _internal_add_object();
  // @@protoc_insertion_point(field_add:PROTOCOL.S_Spawn.object)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo >&
S_Spawn::object() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_Spawn.object)
  return object_;
}

// -------------------------------------------------------------------

// S_DeSpawn

// repeated int32 objectids = 1;
inline int S_DeSpawn::_internal_objectids_size() const {
  return objectids_.size();
}
inline int S_DeSpawn::objectids_size() const {
  return _internal_objectids_size();
}
inline void S_DeSpawn::clear_objectids() {
  objectids_.Clear();
}
inline int32_t S_DeSpawn::_internal_objectids(int index) const {
  return objectids_.Get(index);
}
inline int32_t S_DeSpawn::objectids(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_DeSpawn.objectids)
  return _internal_objectids(index);
}
inline void S_DeSpawn::set_objectids(int index, int32_t value) {
  objectids_.Set(index, value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_DeSpawn.objectids)
}
inline void S_DeSpawn::_internal_add_objectids(int32_t value) {
  objectids_.Add(value);
}
inline void S_DeSpawn::add_objectids(int32_t value) {
  _internal_add_objectids(value);
  // @@protoc_insertion_point(field_add:PROTOCOL.S_DeSpawn.objectids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_DeSpawn::_internal_objectids() const {
  return objectids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_DeSpawn::objectids() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_DeSpawn.objectids)
  return _internal_objectids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_DeSpawn::_internal_mutable_objectids() {
  return &objectids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_DeSpawn::mutable_objectids() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_DeSpawn.objectids)
  return _internal_mutable_objectids();
}

// -------------------------------------------------------------------

// C_Move

// .PROTOCOL.ObjectInfo object = 1;
inline bool C_Move::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool C_Move::has_object() const {
  return _internal_has_object();
}
inline void C_Move::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& C_Move::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& C_Move::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_Move.object)
  return _internal_object();
}
inline void C_Move::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.C_Move.object)
}
inline ::PROTOCOL::ObjectInfo* C_Move::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* C_Move::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_Move.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* C_Move::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* C_Move::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_Move.object)
  return _msg;
}
inline void C_Move::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_Move.object)
}

// -------------------------------------------------------------------

// S_Move

// .PROTOCOL.ObjectInfo object = 1;
inline bool S_Move::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool S_Move::has_object() const {
  return _internal_has_object();
}
inline void S_Move::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& S_Move::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& S_Move::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Move.object)
  return _internal_object();
}
inline void S_Move::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_Move.object)
}
inline ::PROTOCOL::ObjectInfo* S_Move::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_Move::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_Move.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_Move::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* S_Move::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_Move.object)
  return _msg;
}
inline void S_Move::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_Move.object)
}

// -------------------------------------------------------------------

// C_Skill

// int32 skillid = 1;
inline void C_Skill::clear_skillid() {
  skillid_ = 0;
}
inline int32_t C_Skill::_internal_skillid() const {
  return skillid_;
}
inline int32_t C_Skill::skillid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_Skill.skillid)
  return _internal_skillid();
}
inline void C_Skill::_internal_set_skillid(int32_t value) {
  
  skillid_ = value;
}
inline void C_Skill::set_skillid(int32_t value) {
  _internal_set_skillid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_Skill.skillid)
}

// int32 attacker = 2;
inline void C_Skill::clear_attacker() {
  attacker_ = 0;
}
inline int32_t C_Skill::_internal_attacker() const {
  return attacker_;
}
inline int32_t C_Skill::attacker() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_Skill.attacker)
  return _internal_attacker();
}
inline void C_Skill::_internal_set_attacker(int32_t value) {
  
  attacker_ = value;
}
inline void C_Skill::set_attacker(int32_t value) {
  _internal_set_attacker(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_Skill.attacker)
}

// repeated int32 victims = 3;
inline int C_Skill::_internal_victims_size() const {
  return victims_.size();
}
inline int C_Skill::victims_size() const {
  return _internal_victims_size();
}
inline void C_Skill::clear_victims() {
  victims_.Clear();
}
inline int32_t C_Skill::_internal_victims(int index) const {
  return victims_.Get(index);
}
inline int32_t C_Skill::victims(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_Skill.victims)
  return _internal_victims(index);
}
inline void C_Skill::set_victims(int index, int32_t value) {
  victims_.Set(index, value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_Skill.victims)
}
inline void C_Skill::_internal_add_victims(int32_t value) {
  victims_.Add(value);
}
inline void C_Skill::add_victims(int32_t value) {
  _internal_add_victims(value);
  // @@protoc_insertion_point(field_add:PROTOCOL.C_Skill.victims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
C_Skill::_internal_victims() const {
  return victims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
C_Skill::victims() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.C_Skill.victims)
  return _internal_victims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
C_Skill::_internal_mutable_victims() {
  return &victims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
C_Skill::mutable_victims() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.C_Skill.victims)
  return _internal_mutable_victims();
}

// -------------------------------------------------------------------

// S_Skill

// int32 skillid = 1;
inline void S_Skill::clear_skillid() {
  skillid_ = 0;
}
inline int32_t S_Skill::_internal_skillid() const {
  return skillid_;
}
inline int32_t S_Skill::skillid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Skill.skillid)
  return _internal_skillid();
}
inline void S_Skill::_internal_set_skillid(int32_t value) {
  
  skillid_ = value;
}
inline void S_Skill::set_skillid(int32_t value) {
  _internal_set_skillid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_Skill.skillid)
}

// int32 attacker = 2;
inline void S_Skill::clear_attacker() {
  attacker_ = 0;
}
inline int32_t S_Skill::_internal_attacker() const {
  return attacker_;
}
inline int32_t S_Skill::attacker() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Skill.attacker)
  return _internal_attacker();
}
inline void S_Skill::_internal_set_attacker(int32_t value) {
  
  attacker_ = value;
}
inline void S_Skill::set_attacker(int32_t value) {
  _internal_set_attacker(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_Skill.attacker)
}

// repeated int32 victims = 3;
inline int S_Skill::_internal_victims_size() const {
  return victims_.size();
}
inline int S_Skill::victims_size() const {
  return _internal_victims_size();
}
inline void S_Skill::clear_victims() {
  victims_.Clear();
}
inline int32_t S_Skill::_internal_victims(int index) const {
  return victims_.Get(index);
}
inline int32_t S_Skill::victims(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Skill.victims)
  return _internal_victims(index);
}
inline void S_Skill::set_victims(int index, int32_t value) {
  victims_.Set(index, value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_Skill.victims)
}
inline void S_Skill::_internal_add_victims(int32_t value) {
  victims_.Add(value);
}
inline void S_Skill::add_victims(int32_t value) {
  _internal_add_victims(value);
  // @@protoc_insertion_point(field_add:PROTOCOL.S_Skill.victims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_Skill::_internal_victims() const {
  return victims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_Skill::victims() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_Skill.victims)
  return _internal_victims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_Skill::_internal_mutable_victims() {
  return &victims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_Skill::mutable_victims() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_Skill.victims)
  return _internal_mutable_victims();
}

// -------------------------------------------------------------------

// C_Chat

// string text = 1;
inline void C_Chat::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& C_Chat::text() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_Chat.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_Chat::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PROTOCOL.C_Chat.text)
}
inline std::string* C_Chat::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_Chat.text)
  return _s;
}
inline const std::string& C_Chat::_internal_text() const {
  return text_.Get();
}
inline void C_Chat::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_Chat::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_Chat::release_text() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_Chat.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_Chat::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_Chat.text)
}

// -------------------------------------------------------------------

// S_Chat

// .PROTOCOL.ObjectInfo object = 1;
inline bool S_Chat::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool S_Chat::has_object() const {
  return _internal_has_object();
}
inline void S_Chat::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& S_Chat::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& S_Chat::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Chat.object)
  return _internal_object();
}
inline void S_Chat::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_Chat.object)
}
inline ::PROTOCOL::ObjectInfo* S_Chat::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_Chat::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_Chat.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_Chat::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* S_Chat::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_Chat.object)
  return _msg;
}
inline void S_Chat::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_Chat.object)
}

// string text = 2;
inline void S_Chat::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& S_Chat::text() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Chat.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_Chat::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PROTOCOL.S_Chat.text)
}
inline std::string* S_Chat::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_Chat.text)
  return _s;
}
inline const std::string& S_Chat::_internal_text() const {
  return text_.Get();
}
inline void S_Chat::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* S_Chat::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* S_Chat::release_text() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_Chat.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void S_Chat::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_Chat.text)
}

// -------------------------------------------------------------------

// S_ChangeHp

// int32 object = 1;
inline void S_ChangeHp::clear_object() {
  object_ = 0;
}
inline int32_t S_ChangeHp::_internal_object() const {
  return object_;
}
inline int32_t S_ChangeHp::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_ChangeHp.object)
  return _internal_object();
}
inline void S_ChangeHp::_internal_set_object(int32_t value) {
  
  object_ = value;
}
inline void S_ChangeHp::set_object(int32_t value) {
  _internal_set_object(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_ChangeHp.object)
}

// int32 hp = 2;
inline void S_ChangeHp::clear_hp() {
  hp_ = 0;
}
inline int32_t S_ChangeHp::_internal_hp() const {
  return hp_;
}
inline int32_t S_ChangeHp::hp() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_ChangeHp.hp)
  return _internal_hp();
}
inline void S_ChangeHp::_internal_set_hp(int32_t value) {
  
  hp_ = value;
}
inline void S_ChangeHp::set_hp(int32_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_ChangeHp.hp)
}

// -------------------------------------------------------------------

// S_Die

// int32 victim = 1;
inline void S_Die::clear_victim() {
  victim_ = 0;
}
inline int32_t S_Die::_internal_victim() const {
  return victim_;
}
inline int32_t S_Die::victim() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Die.victim)
  return _internal_victim();
}
inline void S_Die::_internal_set_victim(int32_t value) {
  
  victim_ = value;
}
inline void S_Die::set_victim(int32_t value) {
  _internal_set_victim(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_Die.victim)
}

// int32 attacker = 2;
inline void S_Die::clear_attacker() {
  attacker_ = 0;
}
inline int32_t S_Die::_internal_attacker() const {
  return attacker_;
}
inline int32_t S_Die::attacker() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Die.attacker)
  return _internal_attacker();
}
inline void S_Die::_internal_set_attacker(int32_t value) {
  
  attacker_ = value;
}
inline void S_Die::set_attacker(int32_t value) {
  _internal_set_attacker(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_Die.attacker)
}

// -------------------------------------------------------------------

// S_ItemList

// repeated .PROTOCOL.ItemInfo items = 1;
inline int S_ItemList::_internal_items_size() const {
  return items_.size();
}
inline int S_ItemList::items_size() const {
  return _internal_items_size();
}
inline void S_ItemList::clear_items() {
  items_.Clear();
}
inline ::PROTOCOL::ItemInfo* S_ItemList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_ItemList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
S_ItemList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_ItemList.items)
  return &items_;
}
inline const ::PROTOCOL::ItemInfo& S_ItemList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::PROTOCOL::ItemInfo& S_ItemList::items(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_ItemList.items)
  return _internal_items(index);
}
inline ::PROTOCOL::ItemInfo* S_ItemList::_internal_add_items() {
  return items_.Add();
}
inline ::PROTOCOL::ItemInfo* S_ItemList::add_items() {
  ::PROTOCOL::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:PROTOCOL.S_ItemList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
S_ItemList::items() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_ItemList.items)
  return items_;
}

// -------------------------------------------------------------------

// C_AddItem

// repeated .PROTOCOL.ItemInfo items = 1;
inline int C_AddItem::_internal_items_size() const {
  return items_.size();
}
inline int C_AddItem::items_size() const {
  return _internal_items_size();
}
inline void C_AddItem::clear_items() {
  items_.Clear();
}
inline ::PROTOCOL::ItemInfo* C_AddItem::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_AddItem.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
C_AddItem::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.C_AddItem.items)
  return &items_;
}
inline const ::PROTOCOL::ItemInfo& C_AddItem::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::PROTOCOL::ItemInfo& C_AddItem::items(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_AddItem.items)
  return _internal_items(index);
}
inline ::PROTOCOL::ItemInfo* C_AddItem::_internal_add_items() {
  return items_.Add();
}
inline ::PROTOCOL::ItemInfo* C_AddItem::add_items() {
  ::PROTOCOL::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:PROTOCOL.C_AddItem.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
C_AddItem::items() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.C_AddItem.items)
  return items_;
}

// -------------------------------------------------------------------

// S_AddItem

// repeated .PROTOCOL.ItemInfo items = 1;
inline int S_AddItem::_internal_items_size() const {
  return items_.size();
}
inline int S_AddItem::items_size() const {
  return _internal_items_size();
}
inline void S_AddItem::clear_items() {
  items_.Clear();
}
inline ::PROTOCOL::ItemInfo* S_AddItem::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_AddItem.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
S_AddItem::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_AddItem.items)
  return &items_;
}
inline const ::PROTOCOL::ItemInfo& S_AddItem::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::PROTOCOL::ItemInfo& S_AddItem::items(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_AddItem.items)
  return _internal_items(index);
}
inline ::PROTOCOL::ItemInfo* S_AddItem::_internal_add_items() {
  return items_.Add();
}
inline ::PROTOCOL::ItemInfo* S_AddItem::add_items() {
  ::PROTOCOL::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:PROTOCOL.S_AddItem.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
S_AddItem::items() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_AddItem.items)
  return items_;
}

// -------------------------------------------------------------------

// S_UpdateItem

// repeated .PROTOCOL.ItemInfo items = 1;
inline int S_UpdateItem::_internal_items_size() const {
  return items_.size();
}
inline int S_UpdateItem::items_size() const {
  return _internal_items_size();
}
inline void S_UpdateItem::clear_items() {
  items_.Clear();
}
inline ::PROTOCOL::ItemInfo* S_UpdateItem::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_UpdateItem.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
S_UpdateItem::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_UpdateItem.items)
  return &items_;
}
inline const ::PROTOCOL::ItemInfo& S_UpdateItem::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::PROTOCOL::ItemInfo& S_UpdateItem::items(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_UpdateItem.items)
  return _internal_items(index);
}
inline ::PROTOCOL::ItemInfo* S_UpdateItem::_internal_add_items() {
  return items_.Add();
}
inline ::PROTOCOL::ItemInfo* S_UpdateItem::add_items() {
  ::PROTOCOL::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:PROTOCOL.S_UpdateItem.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
S_UpdateItem::items() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_UpdateItem.items)
  return items_;
}

// -------------------------------------------------------------------

// S_RemoveItem

// repeated int32 slots = 1;
inline int S_RemoveItem::_internal_slots_size() const {
  return slots_.size();
}
inline int S_RemoveItem::slots_size() const {
  return _internal_slots_size();
}
inline void S_RemoveItem::clear_slots() {
  slots_.Clear();
}
inline int32_t S_RemoveItem::_internal_slots(int index) const {
  return slots_.Get(index);
}
inline int32_t S_RemoveItem::slots(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_RemoveItem.slots)
  return _internal_slots(index);
}
inline void S_RemoveItem::set_slots(int index, int32_t value) {
  slots_.Set(index, value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_RemoveItem.slots)
}
inline void S_RemoveItem::_internal_add_slots(int32_t value) {
  slots_.Add(value);
}
inline void S_RemoveItem::add_slots(int32_t value) {
  _internal_add_slots(value);
  // @@protoc_insertion_point(field_add:PROTOCOL.S_RemoveItem.slots)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_RemoveItem::_internal_slots() const {
  return slots_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_RemoveItem::slots() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_RemoveItem.slots)
  return _internal_slots();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_RemoveItem::_internal_mutable_slots() {
  return &slots_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_RemoveItem::mutable_slots() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_RemoveItem.slots)
  return _internal_mutable_slots();
}

// -------------------------------------------------------------------

// C_EquipItem

// int32 itemdbid = 1;
inline void C_EquipItem::clear_itemdbid() {
  itemdbid_ = 0;
}
inline int32_t C_EquipItem::_internal_itemdbid() const {
  return itemdbid_;
}
inline int32_t C_EquipItem::itemdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_EquipItem.itemdbid)
  return _internal_itemdbid();
}
inline void C_EquipItem::_internal_set_itemdbid(int32_t value) {
  
  itemdbid_ = value;
}
inline void C_EquipItem::set_itemdbid(int32_t value) {
  _internal_set_itemdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_EquipItem.itemdbid)
}

// int32 slot = 2;
inline void C_EquipItem::clear_slot() {
  slot_ = 0;
}
inline int32_t C_EquipItem::_internal_slot() const {
  return slot_;
}
inline int32_t C_EquipItem::slot() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_EquipItem.slot)
  return _internal_slot();
}
inline void C_EquipItem::_internal_set_slot(int32_t value) {
  
  slot_ = value;
}
inline void C_EquipItem::set_slot(int32_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_EquipItem.slot)
}

// bool equip = 3;
inline void C_EquipItem::clear_equip() {
  equip_ = false;
}
inline bool C_EquipItem::_internal_equip() const {
  return equip_;
}
inline bool C_EquipItem::equip() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_EquipItem.equip)
  return _internal_equip();
}
inline void C_EquipItem::_internal_set_equip(bool value) {
  
  equip_ = value;
}
inline void C_EquipItem::set_equip(bool value) {
  _internal_set_equip(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_EquipItem.equip)
}

// -------------------------------------------------------------------

// S_EquipItem

// int32 itemdbid = 1;
inline void S_EquipItem::clear_itemdbid() {
  itemdbid_ = 0;
}
inline int32_t S_EquipItem::_internal_itemdbid() const {
  return itemdbid_;
}
inline int32_t S_EquipItem::itemdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_EquipItem.itemdbid)
  return _internal_itemdbid();
}
inline void S_EquipItem::_internal_set_itemdbid(int32_t value) {
  
  itemdbid_ = value;
}
inline void S_EquipItem::set_itemdbid(int32_t value) {
  _internal_set_itemdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_EquipItem.itemdbid)
}

// int32 slot = 2;
inline void S_EquipItem::clear_slot() {
  slot_ = 0;
}
inline int32_t S_EquipItem::_internal_slot() const {
  return slot_;
}
inline int32_t S_EquipItem::slot() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_EquipItem.slot)
  return _internal_slot();
}
inline void S_EquipItem::_internal_set_slot(int32_t value) {
  
  slot_ = value;
}
inline void S_EquipItem::set_slot(int32_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_EquipItem.slot)
}

// bool equip = 3;
inline void S_EquipItem::clear_equip() {
  equip_ = false;
}
inline bool S_EquipItem::_internal_equip() const {
  return equip_;
}
inline bool S_EquipItem::equip() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_EquipItem.equip)
  return _internal_equip();
}
inline void S_EquipItem::_internal_set_equip(bool value) {
  
  equip_ = value;
}
inline void S_EquipItem::set_equip(bool value) {
  _internal_set_equip(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_EquipItem.equip)
}

// -------------------------------------------------------------------

// C_UseItem

// int32 itemdbid = 1;
inline void C_UseItem::clear_itemdbid() {
  itemdbid_ = 0;
}
inline int32_t C_UseItem::_internal_itemdbid() const {
  return itemdbid_;
}
inline int32_t C_UseItem::itemdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_UseItem.itemdbid)
  return _internal_itemdbid();
}
inline void C_UseItem::_internal_set_itemdbid(int32_t value) {
  
  itemdbid_ = value;
}
inline void C_UseItem::set_itemdbid(int32_t value) {
  _internal_set_itemdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_UseItem.itemdbid)
}

// int32 slot = 2;
inline void C_UseItem::clear_slot() {
  slot_ = 0;
}
inline int32_t C_UseItem::_internal_slot() const {
  return slot_;
}
inline int32_t C_UseItem::slot() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_UseItem.slot)
  return _internal_slot();
}
inline void C_UseItem::_internal_set_slot(int32_t value) {
  
  slot_ = value;
}
inline void C_UseItem::set_slot(int32_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_UseItem.slot)
}

// bool use = 3;
inline void C_UseItem::clear_use() {
  use_ = false;
}
inline bool C_UseItem::_internal_use() const {
  return use_;
}
inline bool C_UseItem::use() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_UseItem.use)
  return _internal_use();
}
inline void C_UseItem::_internal_set_use(bool value) {
  
  use_ = value;
}
inline void C_UseItem::set_use(bool value) {
  _internal_set_use(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_UseItem.use)
}

// -------------------------------------------------------------------

// S_UseItem

// .PROTOCOL.ItemInfo item = 1;
inline bool S_UseItem::_internal_has_item() const {
  return this != internal_default_instance() && item_ != nullptr;
}
inline bool S_UseItem::has_item() const {
  return _internal_has_item();
}
inline void S_UseItem::clear_item() {
  if (GetArenaForAllocation() == nullptr && item_ != nullptr) {
    delete item_;
  }
  item_ = nullptr;
}
inline const ::PROTOCOL::ItemInfo& S_UseItem::_internal_item() const {
  const ::PROTOCOL::ItemInfo* p = item_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ItemInfo&>(
      ::PROTOCOL::_ItemInfo_default_instance_);
}
inline const ::PROTOCOL::ItemInfo& S_UseItem::item() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_UseItem.item)
  return _internal_item();
}
inline void S_UseItem::unsafe_arena_set_allocated_item(
    ::PROTOCOL::ItemInfo* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_);
  }
  item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_UseItem.item)
}
inline ::PROTOCOL::ItemInfo* S_UseItem::release_item() {
  
  ::PROTOCOL::ItemInfo* temp = item_;
  item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ItemInfo* S_UseItem::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_UseItem.item)
  
  ::PROTOCOL::ItemInfo* temp = item_;
  item_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ItemInfo* S_UseItem::_internal_mutable_item() {
  
  if (item_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ItemInfo>(GetArenaForAllocation());
    item_ = p;
  }
  return item_;
}
inline ::PROTOCOL::ItemInfo* S_UseItem::mutable_item() {
  ::PROTOCOL::ItemInfo* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_UseItem.item)
  return _msg;
}
inline void S_UseItem::set_allocated_item(::PROTOCOL::ItemInfo* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ItemInfo>::GetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  item_ = item;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_UseItem.item)
}

// -------------------------------------------------------------------

// S_ChangeStat

// .PROTOCOL.ObjectInfo object = 1;
inline bool S_ChangeStat::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool S_ChangeStat::has_object() const {
  return _internal_has_object();
}
inline void S_ChangeStat::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& S_ChangeStat::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& S_ChangeStat::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_ChangeStat.object)
  return _internal_object();
}
inline void S_ChangeStat::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_ChangeStat.object)
}
inline ::PROTOCOL::ObjectInfo* S_ChangeStat::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_ChangeStat::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_ChangeStat.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_ChangeStat::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* S_ChangeStat::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_ChangeStat.object)
  return _msg;
}
inline void S_ChangeStat::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_ChangeStat.object)
}

// -------------------------------------------------------------------

// C_CreatePlayer

// string name = 1;
inline void C_CreatePlayer::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& C_CreatePlayer::name() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_CreatePlayer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CreatePlayer::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PROTOCOL.C_CreatePlayer.name)
}
inline std::string* C_CreatePlayer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_CreatePlayer.name)
  return _s;
}
inline const std::string& C_CreatePlayer::_internal_name() const {
  return name_.Get();
}
inline void C_CreatePlayer::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_CreatePlayer::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_CreatePlayer::release_name() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_CreatePlayer.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_CreatePlayer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_CreatePlayer.name)
}

// -------------------------------------------------------------------

// S_CreatePlayer

// .PROTOCOL.ObjectInfo object = 1;
inline bool S_CreatePlayer::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool S_CreatePlayer::has_object() const {
  return _internal_has_object();
}
inline void S_CreatePlayer::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& S_CreatePlayer::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& S_CreatePlayer::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_CreatePlayer.object)
  return _internal_object();
}
inline void S_CreatePlayer::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_CreatePlayer.object)
}
inline ::PROTOCOL::ObjectInfo* S_CreatePlayer::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_CreatePlayer::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_CreatePlayer.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_CreatePlayer::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* S_CreatePlayer::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_CreatePlayer.object)
  return _msg;
}
inline void S_CreatePlayer::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_CreatePlayer.object)
}

// -------------------------------------------------------------------

// S_AddExp

// int32 exp = 1;
inline void S_AddExp::clear_exp() {
  exp_ = 0;
}
inline int32_t S_AddExp::_internal_exp() const {
  return exp_;
}
inline int32_t S_AddExp::exp() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_AddExp.exp)
  return _internal_exp();
}
inline void S_AddExp::_internal_set_exp(int32_t value) {
  
  exp_ = value;
}
inline void S_AddExp::set_exp(int32_t value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_AddExp.exp)
}

// -------------------------------------------------------------------

// S_LevelUp

// .PROTOCOL.ObjectInfo info = 1;
inline bool S_LevelUp::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool S_LevelUp::has_info() const {
  return _internal_has_info();
}
inline void S_LevelUp::clear_info() {
  if (GetArenaForAllocation() == nullptr && info_ != nullptr) {
    delete info_;
  }
  info_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& S_LevelUp::_internal_info() const {
  const ::PROTOCOL::ObjectInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& S_LevelUp::info() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_LevelUp.info)
  return _internal_info();
}
inline void S_LevelUp::unsafe_arena_set_allocated_info(
    ::PROTOCOL::ObjectInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_LevelUp.info)
}
inline ::PROTOCOL::ObjectInfo* S_LevelUp::release_info() {
  
  ::PROTOCOL::ObjectInfo* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_LevelUp::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_LevelUp.info)
  
  ::PROTOCOL::ObjectInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_LevelUp::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::PROTOCOL::ObjectInfo* S_LevelUp::mutable_info() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_LevelUp.info)
  return _msg;
}
inline void S_LevelUp::set_allocated_info(::PROTOCOL::ObjectInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_LevelUp.info)
}

// -------------------------------------------------------------------

// C_AddQuest

// .PROTOCOL.QuestInfo quest = 1;
inline bool C_AddQuest::_internal_has_quest() const {
  return this != internal_default_instance() && quest_ != nullptr;
}
inline bool C_AddQuest::has_quest() const {
  return _internal_has_quest();
}
inline void C_AddQuest::clear_quest() {
  if (GetArenaForAllocation() == nullptr && quest_ != nullptr) {
    delete quest_;
  }
  quest_ = nullptr;
}
inline const ::PROTOCOL::QuestInfo& C_AddQuest::_internal_quest() const {
  const ::PROTOCOL::QuestInfo* p = quest_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::QuestInfo&>(
      ::PROTOCOL::_QuestInfo_default_instance_);
}
inline const ::PROTOCOL::QuestInfo& C_AddQuest::quest() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_AddQuest.quest)
  return _internal_quest();
}
inline void C_AddQuest::unsafe_arena_set_allocated_quest(
    ::PROTOCOL::QuestInfo* quest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(quest_);
  }
  quest_ = quest;
  if (quest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.C_AddQuest.quest)
}
inline ::PROTOCOL::QuestInfo* C_AddQuest::release_quest() {
  
  ::PROTOCOL::QuestInfo* temp = quest_;
  quest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::QuestInfo* C_AddQuest::unsafe_arena_release_quest() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_AddQuest.quest)
  
  ::PROTOCOL::QuestInfo* temp = quest_;
  quest_ = nullptr;
  return temp;
}
inline ::PROTOCOL::QuestInfo* C_AddQuest::_internal_mutable_quest() {
  
  if (quest_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::QuestInfo>(GetArenaForAllocation());
    quest_ = p;
  }
  return quest_;
}
inline ::PROTOCOL::QuestInfo* C_AddQuest::mutable_quest() {
  ::PROTOCOL::QuestInfo* _msg = _internal_mutable_quest();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_AddQuest.quest)
  return _msg;
}
inline void C_AddQuest::set_allocated_quest(::PROTOCOL::QuestInfo* quest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete quest_;
  }
  if (quest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::QuestInfo>::GetOwningArena(quest);
    if (message_arena != submessage_arena) {
      quest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quest, submessage_arena);
    }
    
  } else {
    
  }
  quest_ = quest;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_AddQuest.quest)
}

// -------------------------------------------------------------------

// S_AddQuest

// bool result = 1;
inline void S_AddQuest::clear_result() {
  result_ = false;
}
inline bool S_AddQuest::_internal_result() const {
  return result_;
}
inline bool S_AddQuest::result() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_AddQuest.result)
  return _internal_result();
}
inline void S_AddQuest::_internal_set_result(bool value) {
  
  result_ = value;
}
inline void S_AddQuest::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_AddQuest.result)
}

// .PROTOCOL.QuestInfo quest = 2;
inline bool S_AddQuest::_internal_has_quest() const {
  return this != internal_default_instance() && quest_ != nullptr;
}
inline bool S_AddQuest::has_quest() const {
  return _internal_has_quest();
}
inline void S_AddQuest::clear_quest() {
  if (GetArenaForAllocation() == nullptr && quest_ != nullptr) {
    delete quest_;
  }
  quest_ = nullptr;
}
inline const ::PROTOCOL::QuestInfo& S_AddQuest::_internal_quest() const {
  const ::PROTOCOL::QuestInfo* p = quest_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::QuestInfo&>(
      ::PROTOCOL::_QuestInfo_default_instance_);
}
inline const ::PROTOCOL::QuestInfo& S_AddQuest::quest() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_AddQuest.quest)
  return _internal_quest();
}
inline void S_AddQuest::unsafe_arena_set_allocated_quest(
    ::PROTOCOL::QuestInfo* quest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(quest_);
  }
  quest_ = quest;
  if (quest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_AddQuest.quest)
}
inline ::PROTOCOL::QuestInfo* S_AddQuest::release_quest() {
  
  ::PROTOCOL::QuestInfo* temp = quest_;
  quest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::QuestInfo* S_AddQuest::unsafe_arena_release_quest() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_AddQuest.quest)
  
  ::PROTOCOL::QuestInfo* temp = quest_;
  quest_ = nullptr;
  return temp;
}
inline ::PROTOCOL::QuestInfo* S_AddQuest::_internal_mutable_quest() {
  
  if (quest_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::QuestInfo>(GetArenaForAllocation());
    quest_ = p;
  }
  return quest_;
}
inline ::PROTOCOL::QuestInfo* S_AddQuest::mutable_quest() {
  ::PROTOCOL::QuestInfo* _msg = _internal_mutable_quest();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_AddQuest.quest)
  return _msg;
}
inline void S_AddQuest::set_allocated_quest(::PROTOCOL::QuestInfo* quest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete quest_;
  }
  if (quest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::QuestInfo>::GetOwningArena(quest);
    if (message_arena != submessage_arena) {
      quest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quest, submessage_arena);
    }
    
  } else {
    
  }
  quest_ = quest;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_AddQuest.quest)
}

// -------------------------------------------------------------------

// S_QuestList

// repeated .PROTOCOL.QuestInfo quests = 1;
inline int S_QuestList::_internal_quests_size() const {
  return quests_.size();
}
inline int S_QuestList::quests_size() const {
  return _internal_quests_size();
}
inline void S_QuestList::clear_quests() {
  quests_.Clear();
}
inline ::PROTOCOL::QuestInfo* S_QuestList::mutable_quests(int index) {
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_QuestList.quests)
  return quests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::QuestInfo >*
S_QuestList::mutable_quests() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_QuestList.quests)
  return &quests_;
}
inline const ::PROTOCOL::QuestInfo& S_QuestList::_internal_quests(int index) const {
  return quests_.Get(index);
}
inline const ::PROTOCOL::QuestInfo& S_QuestList::quests(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_QuestList.quests)
  return _internal_quests(index);
}
inline ::PROTOCOL::QuestInfo* S_QuestList::_internal_add_quests() {
  return quests_.Add();
}
inline ::PROTOCOL::QuestInfo* S_QuestList::add_quests() {
  ::PROTOCOL::QuestInfo* _add = _internal_add_quests();
  // @@protoc_insertion_point(field_add:PROTOCOL.S_QuestList.quests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::QuestInfo >&
S_QuestList::quests() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_QuestList.quests)
  return quests_;
}

// -------------------------------------------------------------------

// C_RemoveQuest

// int32 questdbid = 1;
inline void C_RemoveQuest::clear_questdbid() {
  questdbid_ = 0;
}
inline int32_t C_RemoveQuest::_internal_questdbid() const {
  return questdbid_;
}
inline int32_t C_RemoveQuest::questdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_RemoveQuest.questdbid)
  return _internal_questdbid();
}
inline void C_RemoveQuest::_internal_set_questdbid(int32_t value) {
  
  questdbid_ = value;
}
inline void C_RemoveQuest::set_questdbid(int32_t value) {
  _internal_set_questdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_RemoveQuest.questdbid)
}

// -------------------------------------------------------------------

// S_RemoveQuest

// bool result = 1;
inline void S_RemoveQuest::clear_result() {
  result_ = false;
}
inline bool S_RemoveQuest::_internal_result() const {
  return result_;
}
inline bool S_RemoveQuest::result() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_RemoveQuest.result)
  return _internal_result();
}
inline void S_RemoveQuest::_internal_set_result(bool value) {
  
  result_ = value;
}
inline void S_RemoveQuest::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_RemoveQuest.result)
}

// int32 questid = 2;
inline void S_RemoveQuest::clear_questid() {
  questid_ = 0;
}
inline int32_t S_RemoveQuest::_internal_questid() const {
  return questid_;
}
inline int32_t S_RemoveQuest::questid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_RemoveQuest.questid)
  return _internal_questid();
}
inline void S_RemoveQuest::_internal_set_questid(int32_t value) {
  
  questid_ = value;
}
inline void S_RemoveQuest::set_questid(int32_t value) {
  _internal_set_questid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_RemoveQuest.questid)
}

// -------------------------------------------------------------------

// C_CompleteQuest

// int32 questdbid = 1;
inline void C_CompleteQuest::clear_questdbid() {
  questdbid_ = 0;
}
inline int32_t C_CompleteQuest::_internal_questdbid() const {
  return questdbid_;
}
inline int32_t C_CompleteQuest::questdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_CompleteQuest.questdbid)
  return _internal_questdbid();
}
inline void C_CompleteQuest::_internal_set_questdbid(int32_t value) {
  
  questdbid_ = value;
}
inline void C_CompleteQuest::set_questdbid(int32_t value) {
  _internal_set_questdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_CompleteQuest.questdbid)
}

// -------------------------------------------------------------------

// S_CompleteQuest

// bool result = 1;
inline void S_CompleteQuest::clear_result() {
  result_ = false;
}
inline bool S_CompleteQuest::_internal_result() const {
  return result_;
}
inline bool S_CompleteQuest::result() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_CompleteQuest.result)
  return _internal_result();
}
inline void S_CompleteQuest::_internal_set_result(bool value) {
  
  result_ = value;
}
inline void S_CompleteQuest::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_CompleteQuest.result)
}

// int32 questid = 2;
inline void S_CompleteQuest::clear_questid() {
  questid_ = 0;
}
inline int32_t S_CompleteQuest::_internal_questid() const {
  return questid_;
}
inline int32_t S_CompleteQuest::questid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_CompleteQuest.questid)
  return _internal_questid();
}
inline void S_CompleteQuest::_internal_set_questid(int32_t value) {
  
  questid_ = value;
}
inline void S_CompleteQuest::set_questid(int32_t value) {
  _internal_set_questid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_CompleteQuest.questid)
}

// -------------------------------------------------------------------

// C_UpdateQuest

// .PROTOCOL.QuestInfo questinfo = 1;
inline bool C_UpdateQuest::_internal_has_questinfo() const {
  return this != internal_default_instance() && questinfo_ != nullptr;
}
inline bool C_UpdateQuest::has_questinfo() const {
  return _internal_has_questinfo();
}
inline void C_UpdateQuest::clear_questinfo() {
  if (GetArenaForAllocation() == nullptr && questinfo_ != nullptr) {
    delete questinfo_;
  }
  questinfo_ = nullptr;
}
inline const ::PROTOCOL::QuestInfo& C_UpdateQuest::_internal_questinfo() const {
  const ::PROTOCOL::QuestInfo* p = questinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::QuestInfo&>(
      ::PROTOCOL::_QuestInfo_default_instance_);
}
inline const ::PROTOCOL::QuestInfo& C_UpdateQuest::questinfo() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_UpdateQuest.questinfo)
  return _internal_questinfo();
}
inline void C_UpdateQuest::unsafe_arena_set_allocated_questinfo(
    ::PROTOCOL::QuestInfo* questinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(questinfo_);
  }
  questinfo_ = questinfo;
  if (questinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.C_UpdateQuest.questinfo)
}
inline ::PROTOCOL::QuestInfo* C_UpdateQuest::release_questinfo() {
  
  ::PROTOCOL::QuestInfo* temp = questinfo_;
  questinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::QuestInfo* C_UpdateQuest::unsafe_arena_release_questinfo() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_UpdateQuest.questinfo)
  
  ::PROTOCOL::QuestInfo* temp = questinfo_;
  questinfo_ = nullptr;
  return temp;
}
inline ::PROTOCOL::QuestInfo* C_UpdateQuest::_internal_mutable_questinfo() {
  
  if (questinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::QuestInfo>(GetArenaForAllocation());
    questinfo_ = p;
  }
  return questinfo_;
}
inline ::PROTOCOL::QuestInfo* C_UpdateQuest::mutable_questinfo() {
  ::PROTOCOL::QuestInfo* _msg = _internal_mutable_questinfo();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_UpdateQuest.questinfo)
  return _msg;
}
inline void C_UpdateQuest::set_allocated_questinfo(::PROTOCOL::QuestInfo* questinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete questinfo_;
  }
  if (questinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::QuestInfo>::GetOwningArena(questinfo);
    if (message_arena != submessage_arena) {
      questinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, questinfo, submessage_arena);
    }
    
  } else {
    
  }
  questinfo_ = questinfo;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_UpdateQuest.questinfo)
}

// int32 objectid = 2;
inline void C_UpdateQuest::clear_objectid() {
  objectid_ = 0;
}
inline int32_t C_UpdateQuest::_internal_objectid() const {
  return objectid_;
}
inline int32_t C_UpdateQuest::objectid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_UpdateQuest.objectid)
  return _internal_objectid();
}
inline void C_UpdateQuest::_internal_set_objectid(int32_t value) {
  
  objectid_ = value;
}
inline void C_UpdateQuest::set_objectid(int32_t value) {
  _internal_set_objectid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_UpdateQuest.objectid)
}

// -------------------------------------------------------------------

// S_UpdateQuest

// .PROTOCOL.QuestInfo questInfo = 1;
inline bool S_UpdateQuest::_internal_has_questinfo() const {
  return this != internal_default_instance() && questinfo_ != nullptr;
}
inline bool S_UpdateQuest::has_questinfo() const {
  return _internal_has_questinfo();
}
inline void S_UpdateQuest::clear_questinfo() {
  if (GetArenaForAllocation() == nullptr && questinfo_ != nullptr) {
    delete questinfo_;
  }
  questinfo_ = nullptr;
}
inline const ::PROTOCOL::QuestInfo& S_UpdateQuest::_internal_questinfo() const {
  const ::PROTOCOL::QuestInfo* p = questinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::QuestInfo&>(
      ::PROTOCOL::_QuestInfo_default_instance_);
}
inline const ::PROTOCOL::QuestInfo& S_UpdateQuest::questinfo() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_UpdateQuest.questInfo)
  return _internal_questinfo();
}
inline void S_UpdateQuest::unsafe_arena_set_allocated_questinfo(
    ::PROTOCOL::QuestInfo* questinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(questinfo_);
  }
  questinfo_ = questinfo;
  if (questinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_UpdateQuest.questInfo)
}
inline ::PROTOCOL::QuestInfo* S_UpdateQuest::release_questinfo() {
  
  ::PROTOCOL::QuestInfo* temp = questinfo_;
  questinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::QuestInfo* S_UpdateQuest::unsafe_arena_release_questinfo() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_UpdateQuest.questInfo)
  
  ::PROTOCOL::QuestInfo* temp = questinfo_;
  questinfo_ = nullptr;
  return temp;
}
inline ::PROTOCOL::QuestInfo* S_UpdateQuest::_internal_mutable_questinfo() {
  
  if (questinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::QuestInfo>(GetArenaForAllocation());
    questinfo_ = p;
  }
  return questinfo_;
}
inline ::PROTOCOL::QuestInfo* S_UpdateQuest::mutable_questinfo() {
  ::PROTOCOL::QuestInfo* _msg = _internal_mutable_questinfo();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_UpdateQuest.questInfo)
  return _msg;
}
inline void S_UpdateQuest::set_allocated_questinfo(::PROTOCOL::QuestInfo* questinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete questinfo_;
  }
  if (questinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::QuestInfo>::GetOwningArena(questinfo);
    if (message_arena != submessage_arena) {
      questinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, questinfo, submessage_arena);
    }
    
  } else {
    
  }
  questinfo_ = questinfo;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_UpdateQuest.questInfo)
}

// -------------------------------------------------------------------

// C_Test

// int32 testint = 1;
inline void C_Test::clear_testint() {
  testint_ = 0;
}
inline int32_t C_Test::_internal_testint() const {
  return testint_;
}
inline int32_t C_Test::testint() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_Test.testint)
  return _internal_testint();
}
inline void C_Test::_internal_set_testint(int32_t value) {
  
  testint_ = value;
}
inline void C_Test::set_testint(int32_t value) {
  _internal_set_testint(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_Test.testint)
}

// bool testbool = 2;
inline void C_Test::clear_testbool() {
  testbool_ = false;
}
inline bool C_Test::_internal_testbool() const {
  return testbool_;
}
inline bool C_Test::testbool() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_Test.testbool)
  return _internal_testbool();
}
inline void C_Test::_internal_set_testbool(bool value) {
  
  testbool_ = value;
}
inline void C_Test::set_testbool(bool value) {
  _internal_set_testbool(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_Test.testbool)
}

// -------------------------------------------------------------------

// S_Test

// int32 testint = 1;
inline void S_Test::clear_testint() {
  testint_ = 0;
}
inline int32_t S_Test::_internal_testint() const {
  return testint_;
}
inline int32_t S_Test::testint() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Test.testint)
  return _internal_testint();
}
inline void S_Test::_internal_set_testint(int32_t value) {
  
  testint_ = value;
}
inline void S_Test::set_testint(int32_t value) {
  _internal_set_testint(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_Test.testint)
}

// bool testbool = 2;
inline void S_Test::clear_testbool() {
  testbool_ = false;
}
inline bool S_Test::_internal_testbool() const {
  return testbool_;
}
inline bool S_Test::testbool() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_Test.testbool)
  return _internal_testbool();
}
inline void S_Test::_internal_set_testbool(bool value) {
  
  testbool_ = value;
}
inline void S_Test::set_testbool(bool value) {
  _internal_set_testbool(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_Test.testbool)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace PROTOCOL

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::PROTOCOL::MsgId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PROTOCOL::MsgId>() {
  return ::PROTOCOL::MsgId_descriptor();
}
template <> struct is_proto_enum< ::PROTOCOL::PlayerServerState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PROTOCOL::PlayerServerState>() {
  return ::PROTOCOL::PlayerServerState_descriptor();
}
template <> struct is_proto_enum< ::PROTOCOL::GameObjectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PROTOCOL::GameObjectType>() {
  return ::PROTOCOL::GameObjectType_descriptor();
}
template <> struct is_proto_enum< ::PROTOCOL::SkillType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PROTOCOL::SkillType>() {
  return ::PROTOCOL::SkillType_descriptor();
}
template <> struct is_proto_enum< ::PROTOCOL::ItemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PROTOCOL::ItemType>() {
  return ::PROTOCOL::ItemType_descriptor();
}
template <> struct is_proto_enum< ::PROTOCOL::WeaponType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PROTOCOL::WeaponType>() {
  return ::PROTOCOL::WeaponType_descriptor();
}
template <> struct is_proto_enum< ::PROTOCOL::ArmorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PROTOCOL::ArmorType>() {
  return ::PROTOCOL::ArmorType_descriptor();
}
template <> struct is_proto_enum< ::PROTOCOL::ConsumableType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PROTOCOL::ConsumableType>() {
  return ::PROTOCOL::ConsumableType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol3_2eproto
