// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol3.proto

#pragma warning(disable:4800)

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol3_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol3_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol3_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol3_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[54]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol3_2eproto;
namespace PROTOCOL {
class AI_C_PATHFIND;
struct AI_C_PATHFINDDefaultTypeInternal;
extern AI_C_PATHFINDDefaultTypeInternal _AI_C_PATHFIND_default_instance_;
class AI_S_PATHFIND;
struct AI_S_PATHFINDDefaultTypeInternal;
extern AI_S_PATHFINDDefaultTypeInternal _AI_S_PATHFIND_default_instance_;
class C_ADD_ITEM;
struct C_ADD_ITEMDefaultTypeInternal;
extern C_ADD_ITEMDefaultTypeInternal _C_ADD_ITEM_default_instance_;
class C_ADD_QUEST;
struct C_ADD_QUESTDefaultTypeInternal;
extern C_ADD_QUESTDefaultTypeInternal _C_ADD_QUEST_default_instance_;
class C_BOT_LOGIN;
struct C_BOT_LOGINDefaultTypeInternal;
extern C_BOT_LOGINDefaultTypeInternal _C_BOT_LOGIN_default_instance_;
class C_CHAT;
struct C_CHATDefaultTypeInternal;
extern C_CHATDefaultTypeInternal _C_CHAT_default_instance_;
class C_COMPLETE_QUEST;
struct C_COMPLETE_QUESTDefaultTypeInternal;
extern C_COMPLETE_QUESTDefaultTypeInternal _C_COMPLETE_QUEST_default_instance_;
class C_CREATE_PLAYER;
struct C_CREATE_PLAYERDefaultTypeInternal;
extern C_CREATE_PLAYERDefaultTypeInternal _C_CREATE_PLAYER_default_instance_;
class C_DESPAWN;
struct C_DESPAWNDefaultTypeInternal;
extern C_DESPAWNDefaultTypeInternal _C_DESPAWN_default_instance_;
class C_ENTER_ROOM;
struct C_ENTER_ROOMDefaultTypeInternal;
extern C_ENTER_ROOMDefaultTypeInternal _C_ENTER_ROOM_default_instance_;
class C_EQUIP_ITEM;
struct C_EQUIP_ITEMDefaultTypeInternal;
extern C_EQUIP_ITEMDefaultTypeInternal _C_EQUIP_ITEM_default_instance_;
class C_LEAVE_ROOM;
struct C_LEAVE_ROOMDefaultTypeInternal;
extern C_LEAVE_ROOMDefaultTypeInternal _C_LEAVE_ROOM_default_instance_;
class C_LOGIN;
struct C_LOGINDefaultTypeInternal;
extern C_LOGINDefaultTypeInternal _C_LOGIN_default_instance_;
class C_MOVE;
struct C_MOVEDefaultTypeInternal;
extern C_MOVEDefaultTypeInternal _C_MOVE_default_instance_;
class C_REMOVE_QUEST;
struct C_REMOVE_QUESTDefaultTypeInternal;
extern C_REMOVE_QUESTDefaultTypeInternal _C_REMOVE_QUEST_default_instance_;
class C_SKILL;
struct C_SKILLDefaultTypeInternal;
extern C_SKILLDefaultTypeInternal _C_SKILL_default_instance_;
class C_SPAWN;
struct C_SPAWNDefaultTypeInternal;
extern C_SPAWNDefaultTypeInternal _C_SPAWN_default_instance_;
class C_TEST;
struct C_TESTDefaultTypeInternal;
extern C_TESTDefaultTypeInternal _C_TEST_default_instance_;
class C_UPDATE_QUEST;
struct C_UPDATE_QUESTDefaultTypeInternal;
extern C_UPDATE_QUESTDefaultTypeInternal _C_UPDATE_QUEST_default_instance_;
class C_USE_ITEM;
struct C_USE_ITEMDefaultTypeInternal;
extern C_USE_ITEMDefaultTypeInternal _C_USE_ITEM_default_instance_;
class ItemInfo;
struct ItemInfoDefaultTypeInternal;
extern ItemInfoDefaultTypeInternal _ItemInfo_default_instance_;
class LobbyPlayerInfo;
struct LobbyPlayerInfoDefaultTypeInternal;
extern LobbyPlayerInfoDefaultTypeInternal _LobbyPlayerInfo_default_instance_;
class ObjectInfo;
struct ObjectInfoDefaultTypeInternal;
extern ObjectInfoDefaultTypeInternal _ObjectInfo_default_instance_;
class PFVector;
struct PFVectorDefaultTypeInternal;
extern PFVectorDefaultTypeInternal _PFVector_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class QuestInfo;
struct QuestInfoDefaultTypeInternal;
extern QuestInfoDefaultTypeInternal _QuestInfo_default_instance_;
class S_ADD_EXP;
struct S_ADD_EXPDefaultTypeInternal;
extern S_ADD_EXPDefaultTypeInternal _S_ADD_EXP_default_instance_;
class S_ADD_ITEM;
struct S_ADD_ITEMDefaultTypeInternal;
extern S_ADD_ITEMDefaultTypeInternal _S_ADD_ITEM_default_instance_;
class S_ADD_QUEST;
struct S_ADD_QUESTDefaultTypeInternal;
extern S_ADD_QUESTDefaultTypeInternal _S_ADD_QUEST_default_instance_;
class S_CHANGE_HP;
struct S_CHANGE_HPDefaultTypeInternal;
extern S_CHANGE_HPDefaultTypeInternal _S_CHANGE_HP_default_instance_;
class S_CHANGE_STAT;
struct S_CHANGE_STATDefaultTypeInternal;
extern S_CHANGE_STATDefaultTypeInternal _S_CHANGE_STAT_default_instance_;
class S_CHAT;
struct S_CHATDefaultTypeInternal;
extern S_CHATDefaultTypeInternal _S_CHAT_default_instance_;
class S_COMPLETE_QUEST;
struct S_COMPLETE_QUESTDefaultTypeInternal;
extern S_COMPLETE_QUESTDefaultTypeInternal _S_COMPLETE_QUEST_default_instance_;
class S_CREATE_PLAYER;
struct S_CREATE_PLAYERDefaultTypeInternal;
extern S_CREATE_PLAYERDefaultTypeInternal _S_CREATE_PLAYER_default_instance_;
class S_DESPAWN;
struct S_DESPAWNDefaultTypeInternal;
extern S_DESPAWNDefaultTypeInternal _S_DESPAWN_default_instance_;
class S_DIE;
struct S_DIEDefaultTypeInternal;
extern S_DIEDefaultTypeInternal _S_DIE_default_instance_;
class S_ENTER_ROOM;
struct S_ENTER_ROOMDefaultTypeInternal;
extern S_ENTER_ROOMDefaultTypeInternal _S_ENTER_ROOM_default_instance_;
class S_EQUIP_ITEM;
struct S_EQUIP_ITEMDefaultTypeInternal;
extern S_EQUIP_ITEMDefaultTypeInternal _S_EQUIP_ITEM_default_instance_;
class S_ITEMLIST;
struct S_ITEMLISTDefaultTypeInternal;
extern S_ITEMLISTDefaultTypeInternal _S_ITEMLIST_default_instance_;
class S_LEAVE_ROOM;
struct S_LEAVE_ROOMDefaultTypeInternal;
extern S_LEAVE_ROOMDefaultTypeInternal _S_LEAVE_ROOM_default_instance_;
class S_LEVEL_UP;
struct S_LEVEL_UPDefaultTypeInternal;
extern S_LEVEL_UPDefaultTypeInternal _S_LEVEL_UP_default_instance_;
class S_LOGIN;
struct S_LOGINDefaultTypeInternal;
extern S_LOGINDefaultTypeInternal _S_LOGIN_default_instance_;
class S_MOVE;
struct S_MOVEDefaultTypeInternal;
extern S_MOVEDefaultTypeInternal _S_MOVE_default_instance_;
class S_QUESTLIST;
struct S_QUESTLISTDefaultTypeInternal;
extern S_QUESTLISTDefaultTypeInternal _S_QUESTLIST_default_instance_;
class S_REMOVE_ITEM;
struct S_REMOVE_ITEMDefaultTypeInternal;
extern S_REMOVE_ITEMDefaultTypeInternal _S_REMOVE_ITEM_default_instance_;
class S_REMOVE_QUEST;
struct S_REMOVE_QUESTDefaultTypeInternal;
extern S_REMOVE_QUESTDefaultTypeInternal _S_REMOVE_QUEST_default_instance_;
class S_SKILL;
struct S_SKILLDefaultTypeInternal;
extern S_SKILLDefaultTypeInternal _S_SKILL_default_instance_;
class S_SPAWN;
struct S_SPAWNDefaultTypeInternal;
extern S_SPAWNDefaultTypeInternal _S_SPAWN_default_instance_;
class S_TEST;
struct S_TESTDefaultTypeInternal;
extern S_TESTDefaultTypeInternal _S_TEST_default_instance_;
class S_UPDATE_ITEM;
struct S_UPDATE_ITEMDefaultTypeInternal;
extern S_UPDATE_ITEMDefaultTypeInternal _S_UPDATE_ITEM_default_instance_;
class S_UPDATE_QUEST;
struct S_UPDATE_QUESTDefaultTypeInternal;
extern S_UPDATE_QUESTDefaultTypeInternal _S_UPDATE_QUEST_default_instance_;
class S_USE_ITEM;
struct S_USE_ITEMDefaultTypeInternal;
extern S_USE_ITEMDefaultTypeInternal _S_USE_ITEM_default_instance_;
class Skill;
struct SkillDefaultTypeInternal;
extern SkillDefaultTypeInternal _Skill_default_instance_;
class Stat;
struct StatDefaultTypeInternal;
extern StatDefaultTypeInternal _Stat_default_instance_;
}  // namespace PROTOCOL
PROTOBUF_NAMESPACE_OPEN
template<> ::PROTOCOL::AI_C_PATHFIND* Arena::CreateMaybeMessage<::PROTOCOL::AI_C_PATHFIND>(Arena*);
template<> ::PROTOCOL::AI_S_PATHFIND* Arena::CreateMaybeMessage<::PROTOCOL::AI_S_PATHFIND>(Arena*);
template<> ::PROTOCOL::C_ADD_ITEM* Arena::CreateMaybeMessage<::PROTOCOL::C_ADD_ITEM>(Arena*);
template<> ::PROTOCOL::C_ADD_QUEST* Arena::CreateMaybeMessage<::PROTOCOL::C_ADD_QUEST>(Arena*);
template<> ::PROTOCOL::C_BOT_LOGIN* Arena::CreateMaybeMessage<::PROTOCOL::C_BOT_LOGIN>(Arena*);
template<> ::PROTOCOL::C_CHAT* Arena::CreateMaybeMessage<::PROTOCOL::C_CHAT>(Arena*);
template<> ::PROTOCOL::C_COMPLETE_QUEST* Arena::CreateMaybeMessage<::PROTOCOL::C_COMPLETE_QUEST>(Arena*);
template<> ::PROTOCOL::C_CREATE_PLAYER* Arena::CreateMaybeMessage<::PROTOCOL::C_CREATE_PLAYER>(Arena*);
template<> ::PROTOCOL::C_DESPAWN* Arena::CreateMaybeMessage<::PROTOCOL::C_DESPAWN>(Arena*);
template<> ::PROTOCOL::C_ENTER_ROOM* Arena::CreateMaybeMessage<::PROTOCOL::C_ENTER_ROOM>(Arena*);
template<> ::PROTOCOL::C_EQUIP_ITEM* Arena::CreateMaybeMessage<::PROTOCOL::C_EQUIP_ITEM>(Arena*);
template<> ::PROTOCOL::C_LEAVE_ROOM* Arena::CreateMaybeMessage<::PROTOCOL::C_LEAVE_ROOM>(Arena*);
template<> ::PROTOCOL::C_LOGIN* Arena::CreateMaybeMessage<::PROTOCOL::C_LOGIN>(Arena*);
template<> ::PROTOCOL::C_MOVE* Arena::CreateMaybeMessage<::PROTOCOL::C_MOVE>(Arena*);
template<> ::PROTOCOL::C_REMOVE_QUEST* Arena::CreateMaybeMessage<::PROTOCOL::C_REMOVE_QUEST>(Arena*);
template<> ::PROTOCOL::C_SKILL* Arena::CreateMaybeMessage<::PROTOCOL::C_SKILL>(Arena*);
template<> ::PROTOCOL::C_SPAWN* Arena::CreateMaybeMessage<::PROTOCOL::C_SPAWN>(Arena*);
template<> ::PROTOCOL::C_TEST* Arena::CreateMaybeMessage<::PROTOCOL::C_TEST>(Arena*);
template<> ::PROTOCOL::C_UPDATE_QUEST* Arena::CreateMaybeMessage<::PROTOCOL::C_UPDATE_QUEST>(Arena*);
template<> ::PROTOCOL::C_USE_ITEM* Arena::CreateMaybeMessage<::PROTOCOL::C_USE_ITEM>(Arena*);
template<> ::PROTOCOL::ItemInfo* Arena::CreateMaybeMessage<::PROTOCOL::ItemInfo>(Arena*);
template<> ::PROTOCOL::LobbyPlayerInfo* Arena::CreateMaybeMessage<::PROTOCOL::LobbyPlayerInfo>(Arena*);
template<> ::PROTOCOL::ObjectInfo* Arena::CreateMaybeMessage<::PROTOCOL::ObjectInfo>(Arena*);
template<> ::PROTOCOL::PFVector* Arena::CreateMaybeMessage<::PROTOCOL::PFVector>(Arena*);
template<> ::PROTOCOL::Position* Arena::CreateMaybeMessage<::PROTOCOL::Position>(Arena*);
template<> ::PROTOCOL::QuestInfo* Arena::CreateMaybeMessage<::PROTOCOL::QuestInfo>(Arena*);
template<> ::PROTOCOL::S_ADD_EXP* Arena::CreateMaybeMessage<::PROTOCOL::S_ADD_EXP>(Arena*);
template<> ::PROTOCOL::S_ADD_ITEM* Arena::CreateMaybeMessage<::PROTOCOL::S_ADD_ITEM>(Arena*);
template<> ::PROTOCOL::S_ADD_QUEST* Arena::CreateMaybeMessage<::PROTOCOL::S_ADD_QUEST>(Arena*);
template<> ::PROTOCOL::S_CHANGE_HP* Arena::CreateMaybeMessage<::PROTOCOL::S_CHANGE_HP>(Arena*);
template<> ::PROTOCOL::S_CHANGE_STAT* Arena::CreateMaybeMessage<::PROTOCOL::S_CHANGE_STAT>(Arena*);
template<> ::PROTOCOL::S_CHAT* Arena::CreateMaybeMessage<::PROTOCOL::S_CHAT>(Arena*);
template<> ::PROTOCOL::S_COMPLETE_QUEST* Arena::CreateMaybeMessage<::PROTOCOL::S_COMPLETE_QUEST>(Arena*);
template<> ::PROTOCOL::S_CREATE_PLAYER* Arena::CreateMaybeMessage<::PROTOCOL::S_CREATE_PLAYER>(Arena*);
template<> ::PROTOCOL::S_DESPAWN* Arena::CreateMaybeMessage<::PROTOCOL::S_DESPAWN>(Arena*);
template<> ::PROTOCOL::S_DIE* Arena::CreateMaybeMessage<::PROTOCOL::S_DIE>(Arena*);
template<> ::PROTOCOL::S_ENTER_ROOM* Arena::CreateMaybeMessage<::PROTOCOL::S_ENTER_ROOM>(Arena*);
template<> ::PROTOCOL::S_EQUIP_ITEM* Arena::CreateMaybeMessage<::PROTOCOL::S_EQUIP_ITEM>(Arena*);
template<> ::PROTOCOL::S_ITEMLIST* Arena::CreateMaybeMessage<::PROTOCOL::S_ITEMLIST>(Arena*);
template<> ::PROTOCOL::S_LEAVE_ROOM* Arena::CreateMaybeMessage<::PROTOCOL::S_LEAVE_ROOM>(Arena*);
template<> ::PROTOCOL::S_LEVEL_UP* Arena::CreateMaybeMessage<::PROTOCOL::S_LEVEL_UP>(Arena*);
template<> ::PROTOCOL::S_LOGIN* Arena::CreateMaybeMessage<::PROTOCOL::S_LOGIN>(Arena*);
template<> ::PROTOCOL::S_MOVE* Arena::CreateMaybeMessage<::PROTOCOL::S_MOVE>(Arena*);
template<> ::PROTOCOL::S_QUESTLIST* Arena::CreateMaybeMessage<::PROTOCOL::S_QUESTLIST>(Arena*);
template<> ::PROTOCOL::S_REMOVE_ITEM* Arena::CreateMaybeMessage<::PROTOCOL::S_REMOVE_ITEM>(Arena*);
template<> ::PROTOCOL::S_REMOVE_QUEST* Arena::CreateMaybeMessage<::PROTOCOL::S_REMOVE_QUEST>(Arena*);
template<> ::PROTOCOL::S_SKILL* Arena::CreateMaybeMessage<::PROTOCOL::S_SKILL>(Arena*);
template<> ::PROTOCOL::S_SPAWN* Arena::CreateMaybeMessage<::PROTOCOL::S_SPAWN>(Arena*);
template<> ::PROTOCOL::S_TEST* Arena::CreateMaybeMessage<::PROTOCOL::S_TEST>(Arena*);
template<> ::PROTOCOL::S_UPDATE_ITEM* Arena::CreateMaybeMessage<::PROTOCOL::S_UPDATE_ITEM>(Arena*);
template<> ::PROTOCOL::S_UPDATE_QUEST* Arena::CreateMaybeMessage<::PROTOCOL::S_UPDATE_QUEST>(Arena*);
template<> ::PROTOCOL::S_USE_ITEM* Arena::CreateMaybeMessage<::PROTOCOL::S_USE_ITEM>(Arena*);
template<> ::PROTOCOL::Skill* Arena::CreateMaybeMessage<::PROTOCOL::Skill>(Arena*);
template<> ::PROTOCOL::Stat* Arena::CreateMaybeMessage<::PROTOCOL::Stat>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace PROTOCOL {

enum MsgId : int {
  c_login = 0,
  s_login = 1,
  c_enter_room = 2,
  s_enter_room = 3,
  c_leave_room = 4,
  s_leave_room = 5,
  c_spawn = 6,
  s_spawn = 7,
  c_despawn = 8,
  s_despawn = 9,
  c_move = 10,
  s_move = 11,
  c_skill = 12,
  s_skill = 13,
  c_chat = 14,
  s_chat = 15,
  s_change_hp = 16,
  s_die = 17,
  s_itemlist = 18,
  c_add_item = 19,
  s_add_item = 20,
  s_update_item = 21,
  s_remove_item = 22,
  c_equip_item = 23,
  s_equip_item = 24,
  c_use_item = 25,
  s_use_item = 26,
  s_change_stat = 27,
  c_create_player = 28,
  s_create_player = 29,
  s_add_exp = 30,
  s_level_up = 31,
  c_add_quest = 32,
  s_add_quest = 33,
  s_questlist = 34,
  c_remove_quest = 35,
  s_remove_quest = 36,
  c_complete_quest = 37,
  s_complete_quest = 38,
  c_update_quest = 39,
  s_update_quest = 40,
  c_test = 41,
  s_test = 42,
  c_bot_login = 43,
  ai_c_pathfind = 100,
  ai_s_pathfind = 101,
  MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MsgId_IsValid(int value);
constexpr MsgId MsgId_MIN = c_login;
constexpr MsgId MsgId_MAX = ai_s_pathfind;
constexpr int MsgId_ARRAYSIZE = MsgId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgId_descriptor();
template<typename T>
inline const std::string& MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgId_descriptor(), enum_t_value);
}
inline bool MsgId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgId>(
    MsgId_descriptor(), name, value);
}
enum PlayerServerState : int {
  SERVER_STATE_NONE = 0,
  SERVER_STATE_CONNECTED = 1,
  SERVER_STATE_LOGIN = 2,
  SERVER_STATE_LOBBY = 3,
  SERVER_STATE_GAME = 4,
  PlayerServerState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PlayerServerState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PlayerServerState_IsValid(int value);
constexpr PlayerServerState PlayerServerState_MIN = SERVER_STATE_NONE;
constexpr PlayerServerState PlayerServerState_MAX = SERVER_STATE_GAME;
constexpr int PlayerServerState_ARRAYSIZE = PlayerServerState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerServerState_descriptor();
template<typename T>
inline const std::string& PlayerServerState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerServerState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerServerState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerServerState_descriptor(), enum_t_value);
}
inline bool PlayerServerState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerServerState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerServerState>(
    PlayerServerState_descriptor(), name, value);
}
enum GameObjectType : int {
  NONE = 0,
  PLAYER = 1,
  MONSTER = 2,
  PROJECTILE = 3,
  NPC = 4,
  Object = 5,
  GameObjectType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GameObjectType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GameObjectType_IsValid(int value);
constexpr GameObjectType GameObjectType_MIN = NONE;
constexpr GameObjectType GameObjectType_MAX = Object;
constexpr int GameObjectType_ARRAYSIZE = GameObjectType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameObjectType_descriptor();
template<typename T>
inline const std::string& GameObjectType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GameObjectType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GameObjectType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GameObjectType_descriptor(), enum_t_value);
}
inline bool GameObjectType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GameObjectType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GameObjectType>(
    GameObjectType_descriptor(), name, value);
}
enum SkillType : int {
  SKILL_NONE = 0,
  SKILL_AUTO = 1,
  SKILL_PROJECTTILE = 2,
  SkillType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SkillType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SkillType_IsValid(int value);
constexpr SkillType SkillType_MIN = SKILL_NONE;
constexpr SkillType SkillType_MAX = SKILL_PROJECTTILE;
constexpr int SkillType_ARRAYSIZE = SkillType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SkillType_descriptor();
template<typename T>
inline const std::string& SkillType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SkillType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SkillType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SkillType_descriptor(), enum_t_value);
}
inline bool SkillType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SkillType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SkillType>(
    SkillType_descriptor(), name, value);
}
enum ItemType : int {
  ITEM_TYPE_NONE = 0,
  ITEM_TYPE_WEAPON = 1,
  ITEM_TYPE_ARMOR = 2,
  ITEM_TYPE_CONSUMABLE = 3,
  ItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ItemType_IsValid(int value);
constexpr ItemType ItemType_MIN = ITEM_TYPE_NONE;
constexpr ItemType ItemType_MAX = ITEM_TYPE_CONSUMABLE;
constexpr int ItemType_ARRAYSIZE = ItemType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemType_descriptor();
template<typename T>
inline const std::string& ItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemType_descriptor(), enum_t_value);
}
inline bool ItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemType>(
    ItemType_descriptor(), name, value);
}
enum WeaponType : int {
  WEAPON_TYPE_NONE = 0,
  WEAPON_TYPE_SWORD = 1,
  WEAPON_TYPE_AXE = 2,
  WeaponType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WeaponType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WeaponType_IsValid(int value);
constexpr WeaponType WeaponType_MIN = WEAPON_TYPE_NONE;
constexpr WeaponType WeaponType_MAX = WEAPON_TYPE_AXE;
constexpr int WeaponType_ARRAYSIZE = WeaponType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WeaponType_descriptor();
template<typename T>
inline const std::string& WeaponType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WeaponType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WeaponType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WeaponType_descriptor(), enum_t_value);
}
inline bool WeaponType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WeaponType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WeaponType>(
    WeaponType_descriptor(), name, value);
}
enum ArmorType : int {
  ARMOR_TYPE_NONE = 0,
  ARMOR_TYPE_HELMET = 1,
  ARMOR_TYPE_ARMOR = 2,
  ArmorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ArmorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ArmorType_IsValid(int value);
constexpr ArmorType ArmorType_MIN = ARMOR_TYPE_NONE;
constexpr ArmorType ArmorType_MAX = ARMOR_TYPE_ARMOR;
constexpr int ArmorType_ARRAYSIZE = ArmorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArmorType_descriptor();
template<typename T>
inline const std::string& ArmorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArmorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArmorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ArmorType_descriptor(), enum_t_value);
}
inline bool ArmorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ArmorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ArmorType>(
    ArmorType_descriptor(), name, value);
}
enum ConsumableType : int {
  CONSUMABLE_TYPE_NONE = 0,
  CONSUMABLE_TYPE_HP_POTION = 1,
  CONSUMABLE_TYPE_MP_POTION = 2,
  ConsumableType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConsumableType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConsumableType_IsValid(int value);
constexpr ConsumableType ConsumableType_MIN = CONSUMABLE_TYPE_NONE;
constexpr ConsumableType ConsumableType_MAX = CONSUMABLE_TYPE_MP_POTION;
constexpr int ConsumableType_ARRAYSIZE = ConsumableType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConsumableType_descriptor();
template<typename T>
inline const std::string& ConsumableType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConsumableType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConsumableType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConsumableType_descriptor(), enum_t_value);
}
inline bool ConsumableType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConsumableType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConsumableType>(
    ConsumableType_descriptor(), name, value);
}
// ===================================================================

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  explicit constexpr Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Position& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kRotationFieldNumber = 2,
    kVelocityFieldNumber = 3,
  };
  // .PROTOCOL.PFVector location = 1;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::PROTOCOL::PFVector& location() const;
  PROTOBUF_NODISCARD ::PROTOCOL::PFVector* release_location();
  ::PROTOCOL::PFVector* mutable_location();
  void set_allocated_location(::PROTOCOL::PFVector* location);
  private:
  const ::PROTOCOL::PFVector& _internal_location() const;
  ::PROTOCOL::PFVector* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::PROTOCOL::PFVector* location);
  ::PROTOCOL::PFVector* unsafe_arena_release_location();

  // .PROTOCOL.PFVector rotation = 2;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::PROTOCOL::PFVector& rotation() const;
  PROTOBUF_NODISCARD ::PROTOCOL::PFVector* release_rotation();
  ::PROTOCOL::PFVector* mutable_rotation();
  void set_allocated_rotation(::PROTOCOL::PFVector* rotation);
  private:
  const ::PROTOCOL::PFVector& _internal_rotation() const;
  ::PROTOCOL::PFVector* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::PROTOCOL::PFVector* rotation);
  ::PROTOCOL::PFVector* unsafe_arena_release_rotation();

  // .PROTOCOL.PFVector velocity = 3;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::PROTOCOL::PFVector& velocity() const;
  PROTOBUF_NODISCARD ::PROTOCOL::PFVector* release_velocity();
  ::PROTOCOL::PFVector* mutable_velocity();
  void set_allocated_velocity(::PROTOCOL::PFVector* velocity);
  private:
  const ::PROTOCOL::PFVector& _internal_velocity() const;
  ::PROTOCOL::PFVector* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::PROTOCOL::PFVector* velocity);
  ::PROTOCOL::PFVector* unsafe_arena_release_velocity();

  // @@protoc_insertion_point(class_scope:PROTOCOL.Position)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::PFVector* location_;
  ::PROTOCOL::PFVector* rotation_;
  ::PROTOCOL::PFVector* velocity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class Stat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.Stat) */ {
 public:
  inline Stat() : Stat(nullptr) {}
  ~Stat() override;
  explicit constexpr Stat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stat(const Stat& from);
  Stat(Stat&& from) noexcept
    : Stat() {
    *this = ::std::move(from);
  }

  inline Stat& operator=(const Stat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stat& operator=(Stat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stat* internal_default_instance() {
    return reinterpret_cast<const Stat*>(
               &_Stat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Stat& a, Stat& b) {
    a.Swap(&b);
  }
  inline void Swap(Stat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Stat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.Stat";
  }
  protected:
  explicit Stat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 1,
    kTotalExpFieldNumber = 2,
    kExpFieldNumber = 3,
    kMaxhpFieldNumber = 4,
    kHpFieldNumber = 5,
    kDamageFieldNumber = 6,
    kDefenceFieldNumber = 7,
    kSpeedFieldNumber = 8,
    kAttackdistanceFieldNumber = 9,
    kNoticedistanceFieldNumber = 10,
    kReturndistanceFieldNumber = 11,
    kAttackcooltimeFieldNumber = 12,
  };
  // int32 level = 1;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // int32 totalExp = 2;
  void clear_totalexp();
  int32_t totalexp() const;
  void set_totalexp(int32_t value);
  private:
  int32_t _internal_totalexp() const;
  void _internal_set_totalexp(int32_t value);
  public:

  // int32 exp = 3;
  void clear_exp();
  int32_t exp() const;
  void set_exp(int32_t value);
  private:
  int32_t _internal_exp() const;
  void _internal_set_exp(int32_t value);
  public:

  // int32 maxhp = 4;
  void clear_maxhp();
  int32_t maxhp() const;
  void set_maxhp(int32_t value);
  private:
  int32_t _internal_maxhp() const;
  void _internal_set_maxhp(int32_t value);
  public:

  // int32 hp = 5;
  void clear_hp();
  int32_t hp() const;
  void set_hp(int32_t value);
  private:
  int32_t _internal_hp() const;
  void _internal_set_hp(int32_t value);
  public:

  // int32 damage = 6;
  void clear_damage();
  int32_t damage() const;
  void set_damage(int32_t value);
  private:
  int32_t _internal_damage() const;
  void _internal_set_damage(int32_t value);
  public:

  // int32 defence = 7;
  void clear_defence();
  int32_t defence() const;
  void set_defence(int32_t value);
  private:
  int32_t _internal_defence() const;
  void _internal_set_defence(int32_t value);
  public:

  // float speed = 8;
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // float attackdistance = 9;
  void clear_attackdistance();
  float attackdistance() const;
  void set_attackdistance(float value);
  private:
  float _internal_attackdistance() const;
  void _internal_set_attackdistance(float value);
  public:

  // float noticedistance = 10;
  void clear_noticedistance();
  float noticedistance() const;
  void set_noticedistance(float value);
  private:
  float _internal_noticedistance() const;
  void _internal_set_noticedistance(float value);
  public:

  // float returndistance = 11;
  void clear_returndistance();
  float returndistance() const;
  void set_returndistance(float value);
  private:
  float _internal_returndistance() const;
  void _internal_set_returndistance(float value);
  public:

  // float attackcooltime = 12;
  void clear_attackcooltime();
  float attackcooltime() const;
  void set_attackcooltime(float value);
  private:
  float _internal_attackcooltime() const;
  void _internal_set_attackcooltime(float value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.Stat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t level_;
  int32_t totalexp_;
  int32_t exp_;
  int32_t maxhp_;
  int32_t hp_;
  int32_t damage_;
  int32_t defence_;
  float speed_;
  float attackdistance_;
  float noticedistance_;
  float returndistance_;
  float attackcooltime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class ObjectInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.ObjectInfo) */ {
 public:
  inline ObjectInfo() : ObjectInfo(nullptr) {}
  ~ObjectInfo() override;
  explicit constexpr ObjectInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectInfo(const ObjectInfo& from);
  ObjectInfo(ObjectInfo&& from) noexcept
    : ObjectInfo() {
    *this = ::std::move(from);
  }

  inline ObjectInfo& operator=(const ObjectInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectInfo& operator=(ObjectInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectInfo* internal_default_instance() {
    return reinterpret_cast<const ObjectInfo*>(
               &_ObjectInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ObjectInfo& a, ObjectInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObjectInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.ObjectInfo";
  }
  protected:
  explicit ObjectInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kPosFieldNumber = 6,
    kStatFieldNumber = 7,
    kObjectIdFieldNumber = 1,
    kPlayerdbidFieldNumber = 2,
    kObjecttypeFieldNumber = 4,
    kTypetemplateidFieldNumber = 5,
  };
  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .PROTOCOL.Position pos = 6;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::PROTOCOL::Position& pos() const;
  PROTOBUF_NODISCARD ::PROTOCOL::Position* release_pos();
  ::PROTOCOL::Position* mutable_pos();
  void set_allocated_pos(::PROTOCOL::Position* pos);
  private:
  const ::PROTOCOL::Position& _internal_pos() const;
  ::PROTOCOL::Position* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::PROTOCOL::Position* pos);
  ::PROTOCOL::Position* unsafe_arena_release_pos();

  // .PROTOCOL.Stat stat = 7;
  bool has_stat() const;
  private:
  bool _internal_has_stat() const;
  public:
  void clear_stat();
  const ::PROTOCOL::Stat& stat() const;
  PROTOBUF_NODISCARD ::PROTOCOL::Stat* release_stat();
  ::PROTOCOL::Stat* mutable_stat();
  void set_allocated_stat(::PROTOCOL::Stat* stat);
  private:
  const ::PROTOCOL::Stat& _internal_stat() const;
  ::PROTOCOL::Stat* _internal_mutable_stat();
  public:
  void unsafe_arena_set_allocated_stat(
      ::PROTOCOL::Stat* stat);
  ::PROTOCOL::Stat* unsafe_arena_release_stat();

  // int32 objectId = 1;
  void clear_objectid();
  int32_t objectid() const;
  void set_objectid(int32_t value);
  private:
  int32_t _internal_objectid() const;
  void _internal_set_objectid(int32_t value);
  public:

  // int32 playerdbid = 2;
  void clear_playerdbid();
  int32_t playerdbid() const;
  void set_playerdbid(int32_t value);
  private:
  int32_t _internal_playerdbid() const;
  void _internal_set_playerdbid(int32_t value);
  public:

  // .PROTOCOL.GameObjectType objecttype = 4;
  void clear_objecttype();
  ::PROTOCOL::GameObjectType objecttype() const;
  void set_objecttype(::PROTOCOL::GameObjectType value);
  private:
  ::PROTOCOL::GameObjectType _internal_objecttype() const;
  void _internal_set_objecttype(::PROTOCOL::GameObjectType value);
  public:

  // int32 typetemplateid = 5;
  void clear_typetemplateid();
  int32_t typetemplateid() const;
  void set_typetemplateid(int32_t value);
  private:
  int32_t _internal_typetemplateid() const;
  void _internal_set_typetemplateid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.ObjectInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOCOL::Position* pos_;
  ::PROTOCOL::Stat* stat_;
  int32_t objectid_;
  int32_t playerdbid_;
  int objecttype_;
  int32_t typetemplateid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class LobbyPlayerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.LobbyPlayerInfo) */ {
 public:
  inline LobbyPlayerInfo() : LobbyPlayerInfo(nullptr) {}
  ~LobbyPlayerInfo() override;
  explicit constexpr LobbyPlayerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LobbyPlayerInfo(const LobbyPlayerInfo& from);
  LobbyPlayerInfo(LobbyPlayerInfo&& from) noexcept
    : LobbyPlayerInfo() {
    *this = ::std::move(from);
  }

  inline LobbyPlayerInfo& operator=(const LobbyPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LobbyPlayerInfo& operator=(LobbyPlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LobbyPlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LobbyPlayerInfo* internal_default_instance() {
    return reinterpret_cast<const LobbyPlayerInfo*>(
               &_LobbyPlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LobbyPlayerInfo& a, LobbyPlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LobbyPlayerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LobbyPlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LobbyPlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LobbyPlayerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LobbyPlayerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LobbyPlayerInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LobbyPlayerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.LobbyPlayerInfo";
  }
  protected:
  explicit LobbyPlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kStatFieldNumber = 3,
    kPlayerdbidFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .PROTOCOL.Stat stat = 3;
  bool has_stat() const;
  private:
  bool _internal_has_stat() const;
  public:
  void clear_stat();
  const ::PROTOCOL::Stat& stat() const;
  PROTOBUF_NODISCARD ::PROTOCOL::Stat* release_stat();
  ::PROTOCOL::Stat* mutable_stat();
  void set_allocated_stat(::PROTOCOL::Stat* stat);
  private:
  const ::PROTOCOL::Stat& _internal_stat() const;
  ::PROTOCOL::Stat* _internal_mutable_stat();
  public:
  void unsafe_arena_set_allocated_stat(
      ::PROTOCOL::Stat* stat);
  ::PROTOCOL::Stat* unsafe_arena_release_stat();

  // int32 playerdbid = 1;
  void clear_playerdbid();
  int32_t playerdbid() const;
  void set_playerdbid(int32_t value);
  private:
  int32_t _internal_playerdbid() const;
  void _internal_set_playerdbid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.LobbyPlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOCOL::Stat* stat_;
  int32_t playerdbid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class Skill final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.Skill) */ {
 public:
  inline Skill() : Skill(nullptr) {}
  ~Skill() override;
  explicit constexpr Skill(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Skill(const Skill& from);
  Skill(Skill&& from) noexcept
    : Skill() {
    *this = ::std::move(from);
  }

  inline Skill& operator=(const Skill& from) {
    CopyFrom(from);
    return *this;
  }
  inline Skill& operator=(Skill&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Skill& default_instance() {
    return *internal_default_instance();
  }
  static inline const Skill* internal_default_instance() {
    return reinterpret_cast<const Skill*>(
               &_Skill_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Skill& a, Skill& b) {
    a.Swap(&b);
  }
  inline void Swap(Skill* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Skill* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Skill* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Skill>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Skill& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Skill& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Skill* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.Skill";
  }
  protected:
  explicit Skill(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkillIdFieldNumber = 1,
  };
  // int32 skillId = 1;
  void clear_skillid();
  int32_t skillid() const;
  void set_skillid(int32_t value);
  private:
  int32_t _internal_skillid() const;
  void _internal_set_skillid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.Skill)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t skillid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class ItemInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.ItemInfo) */ {
 public:
  inline ItemInfo() : ItemInfo(nullptr) {}
  ~ItemInfo() override;
  explicit constexpr ItemInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemInfo(const ItemInfo& from);
  ItemInfo(ItemInfo&& from) noexcept
    : ItemInfo() {
    *this = ::std::move(from);
  }

  inline ItemInfo& operator=(const ItemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemInfo& operator=(ItemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemInfo* internal_default_instance() {
    return reinterpret_cast<const ItemInfo*>(
               &_ItemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ItemInfo& a, ItemInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ItemInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.ItemInfo";
  }
  protected:
  explicit ItemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemDbIdFieldNumber = 1,
    kTemplateIdFieldNumber = 2,
    kCountFieldNumber = 3,
    kSlotFieldNumber = 4,
    kEquippedFieldNumber = 5,
    kPlayerdbidFieldNumber = 6,
  };
  // int32 itemDbId = 1;
  void clear_itemdbid();
  int32_t itemdbid() const;
  void set_itemdbid(int32_t value);
  private:
  int32_t _internal_itemdbid() const;
  void _internal_set_itemdbid(int32_t value);
  public:

  // int32 templateId = 2;
  void clear_templateid();
  int32_t templateid() const;
  void set_templateid(int32_t value);
  private:
  int32_t _internal_templateid() const;
  void _internal_set_templateid(int32_t value);
  public:

  // int32 count = 3;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // int32 slot = 4;
  void clear_slot();
  int32_t slot() const;
  void set_slot(int32_t value);
  private:
  int32_t _internal_slot() const;
  void _internal_set_slot(int32_t value);
  public:

  // bool equipped = 5;
  void clear_equipped();
  bool equipped() const;
  void set_equipped(bool value);
  private:
  bool _internal_equipped() const;
  void _internal_set_equipped(bool value);
  public:

  // int32 playerdbid = 6;
  void clear_playerdbid();
  int32_t playerdbid() const;
  void set_playerdbid(int32_t value);
  private:
  int32_t _internal_playerdbid() const;
  void _internal_set_playerdbid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.ItemInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t itemdbid_;
  int32_t templateid_;
  int32_t count_;
  int32_t slot_;
  bool equipped_;
  int32_t playerdbid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class QuestInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.QuestInfo) */ {
 public:
  inline QuestInfo() : QuestInfo(nullptr) {}
  ~QuestInfo() override;
  explicit constexpr QuestInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuestInfo(const QuestInfo& from);
  QuestInfo(QuestInfo&& from) noexcept
    : QuestInfo() {
    *this = ::std::move(from);
  }

  inline QuestInfo& operator=(const QuestInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuestInfo& operator=(QuestInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuestInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuestInfo* internal_default_instance() {
    return reinterpret_cast<const QuestInfo*>(
               &_QuestInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(QuestInfo& a, QuestInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(QuestInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuestInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuestInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuestInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuestInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QuestInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuestInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.QuestInfo";
  }
  protected:
  explicit QuestInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestdbidFieldNumber = 1,
    kTemplateidFieldNumber = 2,
    kProgressFieldNumber = 3,
    kCompletedFieldNumber = 4,
    kPlayerdbidFieldNumber = 5,
  };
  // int32 questdbid = 1;
  void clear_questdbid();
  int32_t questdbid() const;
  void set_questdbid(int32_t value);
  private:
  int32_t _internal_questdbid() const;
  void _internal_set_questdbid(int32_t value);
  public:

  // int32 templateid = 2;
  void clear_templateid();
  int32_t templateid() const;
  void set_templateid(int32_t value);
  private:
  int32_t _internal_templateid() const;
  void _internal_set_templateid(int32_t value);
  public:

  // int32 progress = 3;
  void clear_progress();
  int32_t progress() const;
  void set_progress(int32_t value);
  private:
  int32_t _internal_progress() const;
  void _internal_set_progress(int32_t value);
  public:

  // bool completed = 4;
  void clear_completed();
  bool completed() const;
  void set_completed(bool value);
  private:
  bool _internal_completed() const;
  void _internal_set_completed(bool value);
  public:

  // int32 playerdbid = 5;
  void clear_playerdbid();
  int32_t playerdbid() const;
  void set_playerdbid(int32_t value);
  private:
  int32_t _internal_playerdbid() const;
  void _internal_set_playerdbid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.QuestInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t questdbid_;
  int32_t templateid_;
  int32_t progress_;
  bool completed_;
  int32_t playerdbid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_LOGIN) */ {
 public:
  inline C_LOGIN() : C_LOGIN(nullptr) {}
  ~C_LOGIN() override;
  explicit constexpr C_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LOGIN(const C_LOGIN& from);
  C_LOGIN(C_LOGIN&& from) noexcept
    : C_LOGIN() {
    *this = ::std::move(from);
  }

  inline C_LOGIN& operator=(const C_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LOGIN& operator=(C_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LOGIN* internal_default_instance() {
    return reinterpret_cast<const C_LOGIN*>(
               &_C_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(C_LOGIN& a, C_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_LOGIN& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_LOGIN";
  }
  protected:
  explicit C_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPwFieldNumber = 2,
    kTokenstringFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string pw = 2;
  void clear_pw();
  const std::string& pw() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pw(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pw();
  PROTOBUF_NODISCARD std::string* release_pw();
  void set_allocated_pw(std::string* pw);
  private:
  const std::string& _internal_pw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pw(const std::string& value);
  std::string* _internal_mutable_pw();
  public:

  // string tokenstring = 3;
  void clear_tokenstring();
  const std::string& tokenstring() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tokenstring(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tokenstring();
  PROTOBUF_NODISCARD std::string* release_tokenstring();
  void set_allocated_tokenstring(std::string* tokenstring);
  private:
  const std::string& _internal_tokenstring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tokenstring(const std::string& value);
  std::string* _internal_mutable_tokenstring();
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pw_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tokenstring_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_LOGIN) */ {
 public:
  inline S_LOGIN() : S_LOGIN(nullptr) {}
  ~S_LOGIN() override;
  explicit constexpr S_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LOGIN(const S_LOGIN& from);
  S_LOGIN(S_LOGIN&& from) noexcept
    : S_LOGIN() {
    *this = ::std::move(from);
  }

  inline S_LOGIN& operator=(const S_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LOGIN& operator=(S_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LOGIN* internal_default_instance() {
    return reinterpret_cast<const S_LOGIN*>(
               &_S_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(S_LOGIN& a, S_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_LOGIN& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_LOGIN";
  }
  protected:
  explicit S_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectinfosFieldNumber = 2,
    kLobbyplayerinfosFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // repeated .PROTOCOL.ObjectInfo objectinfos = 2;
  int objectinfos_size() const;
  private:
  int _internal_objectinfos_size() const;
  public:
  void clear_objectinfos();
  ::PROTOCOL::ObjectInfo* mutable_objectinfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo >*
      mutable_objectinfos();
  private:
  const ::PROTOCOL::ObjectInfo& _internal_objectinfos(int index) const;
  ::PROTOCOL::ObjectInfo* _internal_add_objectinfos();
  public:
  const ::PROTOCOL::ObjectInfo& objectinfos(int index) const;
  ::PROTOCOL::ObjectInfo* add_objectinfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo >&
      objectinfos() const;

  // repeated .PROTOCOL.LobbyPlayerInfo lobbyplayerinfos = 3;
  int lobbyplayerinfos_size() const;
  private:
  int _internal_lobbyplayerinfos_size() const;
  public:
  void clear_lobbyplayerinfos();
  ::PROTOCOL::LobbyPlayerInfo* mutable_lobbyplayerinfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::LobbyPlayerInfo >*
      mutable_lobbyplayerinfos();
  private:
  const ::PROTOCOL::LobbyPlayerInfo& _internal_lobbyplayerinfos(int index) const;
  ::PROTOCOL::LobbyPlayerInfo* _internal_add_lobbyplayerinfos();
  public:
  const ::PROTOCOL::LobbyPlayerInfo& lobbyplayerinfos(int index) const;
  ::PROTOCOL::LobbyPlayerInfo* add_lobbyplayerinfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::LobbyPlayerInfo >&
      lobbyplayerinfos() const;

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo > objectinfos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::LobbyPlayerInfo > lobbyplayerinfos_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_ENTER_ROOM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_ENTER_ROOM) */ {
 public:
  inline C_ENTER_ROOM() : C_ENTER_ROOM(nullptr) {}
  ~C_ENTER_ROOM() override;
  explicit constexpr C_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ENTER_ROOM(const C_ENTER_ROOM& from);
  C_ENTER_ROOM(C_ENTER_ROOM&& from) noexcept
    : C_ENTER_ROOM() {
    *this = ::std::move(from);
  }

  inline C_ENTER_ROOM& operator=(const C_ENTER_ROOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ENTER_ROOM& operator=(C_ENTER_ROOM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ENTER_ROOM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ENTER_ROOM* internal_default_instance() {
    return reinterpret_cast<const C_ENTER_ROOM*>(
               &_C_ENTER_ROOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(C_ENTER_ROOM& a, C_ENTER_ROOM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ENTER_ROOM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ENTER_ROOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ENTER_ROOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ENTER_ROOM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ENTER_ROOM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_ENTER_ROOM& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ENTER_ROOM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_ENTER_ROOM";
  }
  protected:
  explicit C_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 2,
    kRoomNumFieldNumber = 1,
    kIsrespawnFieldNumber = 3,
  };
  // .PROTOCOL.ObjectInfo object = 2;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // uint64 roomNum = 1;
  void clear_roomnum();
  uint64_t roomnum() const;
  void set_roomnum(uint64_t value);
  private:
  uint64_t _internal_roomnum() const;
  void _internal_set_roomnum(uint64_t value);
  public:

  // bool isrespawn = 3;
  void clear_isrespawn();
  bool isrespawn() const;
  void set_isrespawn(bool value);
  private:
  bool _internal_isrespawn() const;
  void _internal_set_isrespawn(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_ENTER_ROOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ObjectInfo* object_;
  uint64_t roomnum_;
  bool isrespawn_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_ENTER_ROOM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_ENTER_ROOM) */ {
 public:
  inline S_ENTER_ROOM() : S_ENTER_ROOM(nullptr) {}
  ~S_ENTER_ROOM() override;
  explicit constexpr S_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ENTER_ROOM(const S_ENTER_ROOM& from);
  S_ENTER_ROOM(S_ENTER_ROOM&& from) noexcept
    : S_ENTER_ROOM() {
    *this = ::std::move(from);
  }

  inline S_ENTER_ROOM& operator=(const S_ENTER_ROOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ENTER_ROOM& operator=(S_ENTER_ROOM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ENTER_ROOM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ENTER_ROOM* internal_default_instance() {
    return reinterpret_cast<const S_ENTER_ROOM*>(
               &_S_ENTER_ROOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(S_ENTER_ROOM& a, S_ENTER_ROOM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ENTER_ROOM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ENTER_ROOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ENTER_ROOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ENTER_ROOM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ENTER_ROOM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_ENTER_ROOM& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ENTER_ROOM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_ENTER_ROOM";
  }
  protected:
  explicit S_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 3,
    kObjectFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated .PROTOCOL.ItemInfo items = 3;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::PROTOCOL::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
      mutable_items();
  private:
  const ::PROTOCOL::ItemInfo& _internal_items(int index) const;
  ::PROTOCOL::ItemInfo* _internal_add_items();
  public:
  const ::PROTOCOL::ItemInfo& items(int index) const;
  ::PROTOCOL::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
      items() const;

  // .PROTOCOL.ObjectInfo object = 2;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_ENTER_ROOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo > items_;
  ::PROTOCOL::ObjectInfo* object_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_LEAVE_ROOM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_LEAVE_ROOM) */ {
 public:
  inline C_LEAVE_ROOM() : C_LEAVE_ROOM(nullptr) {}
  ~C_LEAVE_ROOM() override;
  explicit constexpr C_LEAVE_ROOM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LEAVE_ROOM(const C_LEAVE_ROOM& from);
  C_LEAVE_ROOM(C_LEAVE_ROOM&& from) noexcept
    : C_LEAVE_ROOM() {
    *this = ::std::move(from);
  }

  inline C_LEAVE_ROOM& operator=(const C_LEAVE_ROOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LEAVE_ROOM& operator=(C_LEAVE_ROOM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LEAVE_ROOM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LEAVE_ROOM* internal_default_instance() {
    return reinterpret_cast<const C_LEAVE_ROOM*>(
               &_C_LEAVE_ROOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(C_LEAVE_ROOM& a, C_LEAVE_ROOM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LEAVE_ROOM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LEAVE_ROOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LEAVE_ROOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LEAVE_ROOM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_LEAVE_ROOM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_LEAVE_ROOM& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_LEAVE_ROOM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_LEAVE_ROOM";
  }
  protected:
  explicit C_LEAVE_ROOM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .PROTOCOL.ObjectInfo object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_LEAVE_ROOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ObjectInfo* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_LEAVE_ROOM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_LEAVE_ROOM) */ {
 public:
  inline S_LEAVE_ROOM() : S_LEAVE_ROOM(nullptr) {}
  ~S_LEAVE_ROOM() override;
  explicit constexpr S_LEAVE_ROOM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LEAVE_ROOM(const S_LEAVE_ROOM& from);
  S_LEAVE_ROOM(S_LEAVE_ROOM&& from) noexcept
    : S_LEAVE_ROOM() {
    *this = ::std::move(from);
  }

  inline S_LEAVE_ROOM& operator=(const S_LEAVE_ROOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LEAVE_ROOM& operator=(S_LEAVE_ROOM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LEAVE_ROOM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LEAVE_ROOM* internal_default_instance() {
    return reinterpret_cast<const S_LEAVE_ROOM*>(
               &_S_LEAVE_ROOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(S_LEAVE_ROOM& a, S_LEAVE_ROOM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LEAVE_ROOM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LEAVE_ROOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LEAVE_ROOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LEAVE_ROOM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LEAVE_ROOM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_LEAVE_ROOM& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LEAVE_ROOM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_LEAVE_ROOM";
  }
  protected:
  explicit S_LEAVE_ROOM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .PROTOCOL.ObjectInfo object = 2;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_LEAVE_ROOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ObjectInfo* object_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_SPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_SPAWN) */ {
 public:
  inline C_SPAWN() : C_SPAWN(nullptr) {}
  ~C_SPAWN() override;
  explicit constexpr C_SPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_SPAWN(const C_SPAWN& from);
  C_SPAWN(C_SPAWN&& from) noexcept
    : C_SPAWN() {
    *this = ::std::move(from);
  }

  inline C_SPAWN& operator=(const C_SPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_SPAWN& operator=(C_SPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_SPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_SPAWN* internal_default_instance() {
    return reinterpret_cast<const C_SPAWN*>(
               &_C_SPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(C_SPAWN& a, C_SPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(C_SPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_SPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_SPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_SPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_SPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_SPAWN& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_SPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_SPAWN";
  }
  protected:
  explicit C_SPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .PROTOCOL.ObjectInfo object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_SPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ObjectInfo* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_SPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_SPAWN) */ {
 public:
  inline S_SPAWN() : S_SPAWN(nullptr) {}
  ~S_SPAWN() override;
  explicit constexpr S_SPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SPAWN(const S_SPAWN& from);
  S_SPAWN(S_SPAWN&& from) noexcept
    : S_SPAWN() {
    *this = ::std::move(from);
  }

  inline S_SPAWN& operator=(const S_SPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SPAWN& operator=(S_SPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SPAWN* internal_default_instance() {
    return reinterpret_cast<const S_SPAWN*>(
               &_S_SPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(S_SPAWN& a, S_SPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_SPAWN& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_SPAWN";
  }
  protected:
  explicit S_SPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated .PROTOCOL.ObjectInfo object = 2;
  int object_size() const;
  private:
  int _internal_object_size() const;
  public:
  void clear_object();
  ::PROTOCOL::ObjectInfo* mutable_object(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo >*
      mutable_object();
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object(int index) const;
  ::PROTOCOL::ObjectInfo* _internal_add_object();
  public:
  const ::PROTOCOL::ObjectInfo& object(int index) const;
  ::PROTOCOL::ObjectInfo* add_object();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo >&
      object() const;

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_SPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo > object_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_DESPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:PROTOCOL.C_DESPAWN) */ {
 public:
  inline C_DESPAWN() : C_DESPAWN(nullptr) {}
  explicit constexpr C_DESPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_DESPAWN(const C_DESPAWN& from);
  C_DESPAWN(C_DESPAWN&& from) noexcept
    : C_DESPAWN() {
    *this = ::std::move(from);
  }

  inline C_DESPAWN& operator=(const C_DESPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_DESPAWN& operator=(C_DESPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_DESPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_DESPAWN* internal_default_instance() {
    return reinterpret_cast<const C_DESPAWN*>(
               &_C_DESPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(C_DESPAWN& a, C_DESPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(C_DESPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_DESPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_DESPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_DESPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_DESPAWN& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_DESPAWN& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_DESPAWN";
  }
  protected:
  explicit C_DESPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_DESPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_DESPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_DESPAWN) */ {
 public:
  inline S_DESPAWN() : S_DESPAWN(nullptr) {}
  ~S_DESPAWN() override;
  explicit constexpr S_DESPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DESPAWN(const S_DESPAWN& from);
  S_DESPAWN(S_DESPAWN&& from) noexcept
    : S_DESPAWN() {
    *this = ::std::move(from);
  }

  inline S_DESPAWN& operator=(const S_DESPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DESPAWN& operator=(S_DESPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DESPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DESPAWN* internal_default_instance() {
    return reinterpret_cast<const S_DESPAWN*>(
               &_S_DESPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(S_DESPAWN& a, S_DESPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DESPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DESPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_DESPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_DESPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_DESPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_DESPAWN& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DESPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_DESPAWN";
  }
  protected:
  explicit S_DESPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectidsFieldNumber = 1,
  };
  // repeated int32 objectids = 1;
  int objectids_size() const;
  private:
  int _internal_objectids_size() const;
  public:
  void clear_objectids();
  private:
  int32_t _internal_objectids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_objectids() const;
  void _internal_add_objectids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_objectids();
  public:
  int32_t objectids(int index) const;
  void set_objectids(int index, int32_t value);
  void add_objectids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      objectids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_objectids();

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_DESPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > objectids_;
  mutable std::atomic<int> _objectids_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_MOVE) */ {
 public:
  inline C_MOVE() : C_MOVE(nullptr) {}
  ~C_MOVE() override;
  explicit constexpr C_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_MOVE(const C_MOVE& from);
  C_MOVE(C_MOVE&& from) noexcept
    : C_MOVE() {
    *this = ::std::move(from);
  }

  inline C_MOVE& operator=(const C_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_MOVE& operator=(C_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_MOVE* internal_default_instance() {
    return reinterpret_cast<const C_MOVE*>(
               &_C_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(C_MOVE& a, C_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_MOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_MOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_MOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_MOVE& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_MOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_MOVE";
  }
  protected:
  explicit C_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .PROTOCOL.ObjectInfo object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ObjectInfo* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_MOVE) */ {
 public:
  inline S_MOVE() : S_MOVE(nullptr) {}
  ~S_MOVE() override;
  explicit constexpr S_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_MOVE(const S_MOVE& from);
  S_MOVE(S_MOVE&& from) noexcept
    : S_MOVE() {
    *this = ::std::move(from);
  }

  inline S_MOVE& operator=(const S_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_MOVE& operator=(S_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_MOVE* internal_default_instance() {
    return reinterpret_cast<const S_MOVE*>(
               &_S_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(S_MOVE& a, S_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_MOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_MOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_MOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_MOVE& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_MOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_MOVE";
  }
  protected:
  explicit S_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .PROTOCOL.ObjectInfo object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ObjectInfo* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_SKILL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_SKILL) */ {
 public:
  inline C_SKILL() : C_SKILL(nullptr) {}
  ~C_SKILL() override;
  explicit constexpr C_SKILL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_SKILL(const C_SKILL& from);
  C_SKILL(C_SKILL&& from) noexcept
    : C_SKILL() {
    *this = ::std::move(from);
  }

  inline C_SKILL& operator=(const C_SKILL& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_SKILL& operator=(C_SKILL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_SKILL& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_SKILL* internal_default_instance() {
    return reinterpret_cast<const C_SKILL*>(
               &_C_SKILL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(C_SKILL& a, C_SKILL& b) {
    a.Swap(&b);
  }
  inline void Swap(C_SKILL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_SKILL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_SKILL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_SKILL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_SKILL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_SKILL& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_SKILL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_SKILL";
  }
  protected:
  explicit C_SKILL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVictimsFieldNumber = 3,
    kSkillidFieldNumber = 1,
    kAttackerFieldNumber = 2,
  };
  // repeated int32 victims = 3;
  int victims_size() const;
  private:
  int _internal_victims_size() const;
  public:
  void clear_victims();
  private:
  int32_t _internal_victims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_victims() const;
  void _internal_add_victims(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_victims();
  public:
  int32_t victims(int index) const;
  void set_victims(int index, int32_t value);
  void add_victims(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      victims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_victims();

  // int32 skillid = 1;
  void clear_skillid();
  int32_t skillid() const;
  void set_skillid(int32_t value);
  private:
  int32_t _internal_skillid() const;
  void _internal_set_skillid(int32_t value);
  public:

  // int32 attacker = 2;
  void clear_attacker();
  int32_t attacker() const;
  void set_attacker(int32_t value);
  private:
  int32_t _internal_attacker() const;
  void _internal_set_attacker(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_SKILL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > victims_;
  mutable std::atomic<int> _victims_cached_byte_size_;
  int32_t skillid_;
  int32_t attacker_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_SKILL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_SKILL) */ {
 public:
  inline S_SKILL() : S_SKILL(nullptr) {}
  ~S_SKILL() override;
  explicit constexpr S_SKILL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SKILL(const S_SKILL& from);
  S_SKILL(S_SKILL&& from) noexcept
    : S_SKILL() {
    *this = ::std::move(from);
  }

  inline S_SKILL& operator=(const S_SKILL& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SKILL& operator=(S_SKILL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SKILL& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SKILL* internal_default_instance() {
    return reinterpret_cast<const S_SKILL*>(
               &_S_SKILL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(S_SKILL& a, S_SKILL& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SKILL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SKILL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SKILL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SKILL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SKILL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_SKILL& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SKILL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_SKILL";
  }
  protected:
  explicit S_SKILL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVictimsFieldNumber = 3,
    kSkillidFieldNumber = 1,
    kAttackerFieldNumber = 2,
  };
  // repeated int32 victims = 3;
  int victims_size() const;
  private:
  int _internal_victims_size() const;
  public:
  void clear_victims();
  private:
  int32_t _internal_victims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_victims() const;
  void _internal_add_victims(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_victims();
  public:
  int32_t victims(int index) const;
  void set_victims(int index, int32_t value);
  void add_victims(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      victims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_victims();

  // int32 skillid = 1;
  void clear_skillid();
  int32_t skillid() const;
  void set_skillid(int32_t value);
  private:
  int32_t _internal_skillid() const;
  void _internal_set_skillid(int32_t value);
  public:

  // int32 attacker = 2;
  void clear_attacker();
  int32_t attacker() const;
  void set_attacker(int32_t value);
  private:
  int32_t _internal_attacker() const;
  void _internal_set_attacker(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_SKILL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > victims_;
  mutable std::atomic<int> _victims_cached_byte_size_;
  int32_t skillid_;
  int32_t attacker_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_CHAT) */ {
 public:
  inline C_CHAT() : C_CHAT(nullptr) {}
  ~C_CHAT() override;
  explicit constexpr C_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CHAT(const C_CHAT& from);
  C_CHAT(C_CHAT&& from) noexcept
    : C_CHAT() {
    *this = ::std::move(from);
  }

  inline C_CHAT& operator=(const C_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CHAT& operator=(C_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CHAT* internal_default_instance() {
    return reinterpret_cast<const C_CHAT*>(
               &_C_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(C_CHAT& a, C_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_CHAT& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_CHAT";
  }
  protected:
  explicit C_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_CHAT) */ {
 public:
  inline S_CHAT() : S_CHAT(nullptr) {}
  ~S_CHAT() override;
  explicit constexpr S_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CHAT(const S_CHAT& from);
  S_CHAT(S_CHAT&& from) noexcept
    : S_CHAT() {
    *this = ::std::move(from);
  }

  inline S_CHAT& operator=(const S_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CHAT& operator=(S_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CHAT* internal_default_instance() {
    return reinterpret_cast<const S_CHAT*>(
               &_S_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(S_CHAT& a, S_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_CHAT& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_CHAT";
  }
  protected:
  explicit S_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 2,
    kObjectFieldNumber = 1,
  };
  // string text = 2;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .PROTOCOL.ObjectInfo object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOCOL::ObjectInfo* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_CHANGE_HP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_CHANGE_HP) */ {
 public:
  inline S_CHANGE_HP() : S_CHANGE_HP(nullptr) {}
  ~S_CHANGE_HP() override;
  explicit constexpr S_CHANGE_HP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CHANGE_HP(const S_CHANGE_HP& from);
  S_CHANGE_HP(S_CHANGE_HP&& from) noexcept
    : S_CHANGE_HP() {
    *this = ::std::move(from);
  }

  inline S_CHANGE_HP& operator=(const S_CHANGE_HP& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CHANGE_HP& operator=(S_CHANGE_HP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CHANGE_HP& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CHANGE_HP* internal_default_instance() {
    return reinterpret_cast<const S_CHANGE_HP*>(
               &_S_CHANGE_HP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(S_CHANGE_HP& a, S_CHANGE_HP& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CHANGE_HP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CHANGE_HP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CHANGE_HP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CHANGE_HP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CHANGE_HP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_CHANGE_HP& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CHANGE_HP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_CHANGE_HP";
  }
  protected:
  explicit S_CHANGE_HP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
    kHpFieldNumber = 2,
  };
  // int32 object = 1;
  void clear_object();
  int32_t object() const;
  void set_object(int32_t value);
  private:
  int32_t _internal_object() const;
  void _internal_set_object(int32_t value);
  public:

  // int32 hp = 2;
  void clear_hp();
  int32_t hp() const;
  void set_hp(int32_t value);
  private:
  int32_t _internal_hp() const;
  void _internal_set_hp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_CHANGE_HP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t object_;
  int32_t hp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_DIE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_DIE) */ {
 public:
  inline S_DIE() : S_DIE(nullptr) {}
  ~S_DIE() override;
  explicit constexpr S_DIE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DIE(const S_DIE& from);
  S_DIE(S_DIE&& from) noexcept
    : S_DIE() {
    *this = ::std::move(from);
  }

  inline S_DIE& operator=(const S_DIE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DIE& operator=(S_DIE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DIE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DIE* internal_default_instance() {
    return reinterpret_cast<const S_DIE*>(
               &_S_DIE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(S_DIE& a, S_DIE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DIE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DIE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_DIE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_DIE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_DIE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_DIE& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DIE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_DIE";
  }
  protected:
  explicit S_DIE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVictimFieldNumber = 1,
    kAttackerFieldNumber = 2,
  };
  // int32 victim = 1;
  void clear_victim();
  int32_t victim() const;
  void set_victim(int32_t value);
  private:
  int32_t _internal_victim() const;
  void _internal_set_victim(int32_t value);
  public:

  // int32 attacker = 2;
  void clear_attacker();
  int32_t attacker() const;
  void set_attacker(int32_t value);
  private:
  int32_t _internal_attacker() const;
  void _internal_set_attacker(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_DIE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t victim_;
  int32_t attacker_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_ITEMLIST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_ITEMLIST) */ {
 public:
  inline S_ITEMLIST() : S_ITEMLIST(nullptr) {}
  ~S_ITEMLIST() override;
  explicit constexpr S_ITEMLIST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ITEMLIST(const S_ITEMLIST& from);
  S_ITEMLIST(S_ITEMLIST&& from) noexcept
    : S_ITEMLIST() {
    *this = ::std::move(from);
  }

  inline S_ITEMLIST& operator=(const S_ITEMLIST& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ITEMLIST& operator=(S_ITEMLIST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ITEMLIST& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ITEMLIST* internal_default_instance() {
    return reinterpret_cast<const S_ITEMLIST*>(
               &_S_ITEMLIST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(S_ITEMLIST& a, S_ITEMLIST& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ITEMLIST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ITEMLIST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ITEMLIST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ITEMLIST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ITEMLIST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_ITEMLIST& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ITEMLIST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_ITEMLIST";
  }
  protected:
  explicit S_ITEMLIST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .PROTOCOL.ItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::PROTOCOL::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
      mutable_items();
  private:
  const ::PROTOCOL::ItemInfo& _internal_items(int index) const;
  ::PROTOCOL::ItemInfo* _internal_add_items();
  public:
  const ::PROTOCOL::ItemInfo& items(int index) const;
  ::PROTOCOL::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_ITEMLIST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_ADD_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_ADD_ITEM) */ {
 public:
  inline C_ADD_ITEM() : C_ADD_ITEM(nullptr) {}
  ~C_ADD_ITEM() override;
  explicit constexpr C_ADD_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ADD_ITEM(const C_ADD_ITEM& from);
  C_ADD_ITEM(C_ADD_ITEM&& from) noexcept
    : C_ADD_ITEM() {
    *this = ::std::move(from);
  }

  inline C_ADD_ITEM& operator=(const C_ADD_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ADD_ITEM& operator=(C_ADD_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ADD_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ADD_ITEM* internal_default_instance() {
    return reinterpret_cast<const C_ADD_ITEM*>(
               &_C_ADD_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(C_ADD_ITEM& a, C_ADD_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ADD_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ADD_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ADD_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ADD_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ADD_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_ADD_ITEM& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ADD_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_ADD_ITEM";
  }
  protected:
  explicit C_ADD_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .PROTOCOL.ItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::PROTOCOL::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
      mutable_items();
  private:
  const ::PROTOCOL::ItemInfo& _internal_items(int index) const;
  ::PROTOCOL::ItemInfo* _internal_add_items();
  public:
  const ::PROTOCOL::ItemInfo& items(int index) const;
  ::PROTOCOL::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_ADD_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_ADD_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_ADD_ITEM) */ {
 public:
  inline S_ADD_ITEM() : S_ADD_ITEM(nullptr) {}
  ~S_ADD_ITEM() override;
  explicit constexpr S_ADD_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ADD_ITEM(const S_ADD_ITEM& from);
  S_ADD_ITEM(S_ADD_ITEM&& from) noexcept
    : S_ADD_ITEM() {
    *this = ::std::move(from);
  }

  inline S_ADD_ITEM& operator=(const S_ADD_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ADD_ITEM& operator=(S_ADD_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ADD_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ADD_ITEM* internal_default_instance() {
    return reinterpret_cast<const S_ADD_ITEM*>(
               &_S_ADD_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(S_ADD_ITEM& a, S_ADD_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ADD_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ADD_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ADD_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ADD_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ADD_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_ADD_ITEM& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ADD_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_ADD_ITEM";
  }
  protected:
  explicit S_ADD_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .PROTOCOL.ItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::PROTOCOL::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
      mutable_items();
  private:
  const ::PROTOCOL::ItemInfo& _internal_items(int index) const;
  ::PROTOCOL::ItemInfo* _internal_add_items();
  public:
  const ::PROTOCOL::ItemInfo& items(int index) const;
  ::PROTOCOL::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_ADD_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_UPDATE_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_UPDATE_ITEM) */ {
 public:
  inline S_UPDATE_ITEM() : S_UPDATE_ITEM(nullptr) {}
  ~S_UPDATE_ITEM() override;
  explicit constexpr S_UPDATE_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_UPDATE_ITEM(const S_UPDATE_ITEM& from);
  S_UPDATE_ITEM(S_UPDATE_ITEM&& from) noexcept
    : S_UPDATE_ITEM() {
    *this = ::std::move(from);
  }

  inline S_UPDATE_ITEM& operator=(const S_UPDATE_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_UPDATE_ITEM& operator=(S_UPDATE_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_UPDATE_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_UPDATE_ITEM* internal_default_instance() {
    return reinterpret_cast<const S_UPDATE_ITEM*>(
               &_S_UPDATE_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(S_UPDATE_ITEM& a, S_UPDATE_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_UPDATE_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_UPDATE_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_UPDATE_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_UPDATE_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_UPDATE_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_UPDATE_ITEM& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_UPDATE_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_UPDATE_ITEM";
  }
  protected:
  explicit S_UPDATE_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .PROTOCOL.ItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::PROTOCOL::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
      mutable_items();
  private:
  const ::PROTOCOL::ItemInfo& _internal_items(int index) const;
  ::PROTOCOL::ItemInfo* _internal_add_items();
  public:
  const ::PROTOCOL::ItemInfo& items(int index) const;
  ::PROTOCOL::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_UPDATE_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_REMOVE_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_REMOVE_ITEM) */ {
 public:
  inline S_REMOVE_ITEM() : S_REMOVE_ITEM(nullptr) {}
  ~S_REMOVE_ITEM() override;
  explicit constexpr S_REMOVE_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_REMOVE_ITEM(const S_REMOVE_ITEM& from);
  S_REMOVE_ITEM(S_REMOVE_ITEM&& from) noexcept
    : S_REMOVE_ITEM() {
    *this = ::std::move(from);
  }

  inline S_REMOVE_ITEM& operator=(const S_REMOVE_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_REMOVE_ITEM& operator=(S_REMOVE_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_REMOVE_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_REMOVE_ITEM* internal_default_instance() {
    return reinterpret_cast<const S_REMOVE_ITEM*>(
               &_S_REMOVE_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(S_REMOVE_ITEM& a, S_REMOVE_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_REMOVE_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_REMOVE_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_REMOVE_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_REMOVE_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_REMOVE_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_REMOVE_ITEM& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_REMOVE_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_REMOVE_ITEM";
  }
  protected:
  explicit S_REMOVE_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotsFieldNumber = 1,
  };
  // repeated int32 slots = 1;
  int slots_size() const;
  private:
  int _internal_slots_size() const;
  public:
  void clear_slots();
  private:
  int32_t _internal_slots(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_slots() const;
  void _internal_add_slots(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_slots();
  public:
  int32_t slots(int index) const;
  void set_slots(int index, int32_t value);
  void add_slots(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      slots() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_slots();

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_REMOVE_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > slots_;
  mutable std::atomic<int> _slots_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_EQUIP_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_EQUIP_ITEM) */ {
 public:
  inline C_EQUIP_ITEM() : C_EQUIP_ITEM(nullptr) {}
  ~C_EQUIP_ITEM() override;
  explicit constexpr C_EQUIP_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EQUIP_ITEM(const C_EQUIP_ITEM& from);
  C_EQUIP_ITEM(C_EQUIP_ITEM&& from) noexcept
    : C_EQUIP_ITEM() {
    *this = ::std::move(from);
  }

  inline C_EQUIP_ITEM& operator=(const C_EQUIP_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EQUIP_ITEM& operator=(C_EQUIP_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EQUIP_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EQUIP_ITEM* internal_default_instance() {
    return reinterpret_cast<const C_EQUIP_ITEM*>(
               &_C_EQUIP_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(C_EQUIP_ITEM& a, C_EQUIP_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EQUIP_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EQUIP_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_EQUIP_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_EQUIP_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_EQUIP_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_EQUIP_ITEM& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_EQUIP_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_EQUIP_ITEM";
  }
  protected:
  explicit C_EQUIP_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemdbidFieldNumber = 1,
    kSlotFieldNumber = 2,
    kEquipFieldNumber = 3,
  };
  // int32 itemdbid = 1;
  void clear_itemdbid();
  int32_t itemdbid() const;
  void set_itemdbid(int32_t value);
  private:
  int32_t _internal_itemdbid() const;
  void _internal_set_itemdbid(int32_t value);
  public:

  // int32 slot = 2;
  void clear_slot();
  int32_t slot() const;
  void set_slot(int32_t value);
  private:
  int32_t _internal_slot() const;
  void _internal_set_slot(int32_t value);
  public:

  // bool equip = 3;
  void clear_equip();
  bool equip() const;
  void set_equip(bool value);
  private:
  bool _internal_equip() const;
  void _internal_set_equip(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_EQUIP_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t itemdbid_;
  int32_t slot_;
  bool equip_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_EQUIP_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_EQUIP_ITEM) */ {
 public:
  inline S_EQUIP_ITEM() : S_EQUIP_ITEM(nullptr) {}
  ~S_EQUIP_ITEM() override;
  explicit constexpr S_EQUIP_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EQUIP_ITEM(const S_EQUIP_ITEM& from);
  S_EQUIP_ITEM(S_EQUIP_ITEM&& from) noexcept
    : S_EQUIP_ITEM() {
    *this = ::std::move(from);
  }

  inline S_EQUIP_ITEM& operator=(const S_EQUIP_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EQUIP_ITEM& operator=(S_EQUIP_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EQUIP_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EQUIP_ITEM* internal_default_instance() {
    return reinterpret_cast<const S_EQUIP_ITEM*>(
               &_S_EQUIP_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(S_EQUIP_ITEM& a, S_EQUIP_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EQUIP_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EQUIP_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EQUIP_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_EQUIP_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_EQUIP_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_EQUIP_ITEM& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EQUIP_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_EQUIP_ITEM";
  }
  protected:
  explicit S_EQUIP_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemdbidFieldNumber = 1,
    kSlotFieldNumber = 2,
    kEquipFieldNumber = 3,
  };
  // int32 itemdbid = 1;
  void clear_itemdbid();
  int32_t itemdbid() const;
  void set_itemdbid(int32_t value);
  private:
  int32_t _internal_itemdbid() const;
  void _internal_set_itemdbid(int32_t value);
  public:

  // int32 slot = 2;
  void clear_slot();
  int32_t slot() const;
  void set_slot(int32_t value);
  private:
  int32_t _internal_slot() const;
  void _internal_set_slot(int32_t value);
  public:

  // bool equip = 3;
  void clear_equip();
  bool equip() const;
  void set_equip(bool value);
  private:
  bool _internal_equip() const;
  void _internal_set_equip(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_EQUIP_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t itemdbid_;
  int32_t slot_;
  bool equip_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_USE_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_USE_ITEM) */ {
 public:
  inline C_USE_ITEM() : C_USE_ITEM(nullptr) {}
  ~C_USE_ITEM() override;
  explicit constexpr C_USE_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_USE_ITEM(const C_USE_ITEM& from);
  C_USE_ITEM(C_USE_ITEM&& from) noexcept
    : C_USE_ITEM() {
    *this = ::std::move(from);
  }

  inline C_USE_ITEM& operator=(const C_USE_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_USE_ITEM& operator=(C_USE_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_USE_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_USE_ITEM* internal_default_instance() {
    return reinterpret_cast<const C_USE_ITEM*>(
               &_C_USE_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(C_USE_ITEM& a, C_USE_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_USE_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_USE_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_USE_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_USE_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_USE_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_USE_ITEM& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_USE_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_USE_ITEM";
  }
  protected:
  explicit C_USE_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemdbidFieldNumber = 1,
    kSlotFieldNumber = 2,
    kUseFieldNumber = 3,
  };
  // int32 itemdbid = 1;
  void clear_itemdbid();
  int32_t itemdbid() const;
  void set_itemdbid(int32_t value);
  private:
  int32_t _internal_itemdbid() const;
  void _internal_set_itemdbid(int32_t value);
  public:

  // int32 slot = 2;
  void clear_slot();
  int32_t slot() const;
  void set_slot(int32_t value);
  private:
  int32_t _internal_slot() const;
  void _internal_set_slot(int32_t value);
  public:

  // bool use = 3;
  void clear_use();
  bool use() const;
  void set_use(bool value);
  private:
  bool _internal_use() const;
  void _internal_set_use(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_USE_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t itemdbid_;
  int32_t slot_;
  bool use_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_USE_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_USE_ITEM) */ {
 public:
  inline S_USE_ITEM() : S_USE_ITEM(nullptr) {}
  ~S_USE_ITEM() override;
  explicit constexpr S_USE_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_USE_ITEM(const S_USE_ITEM& from);
  S_USE_ITEM(S_USE_ITEM&& from) noexcept
    : S_USE_ITEM() {
    *this = ::std::move(from);
  }

  inline S_USE_ITEM& operator=(const S_USE_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_USE_ITEM& operator=(S_USE_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_USE_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_USE_ITEM* internal_default_instance() {
    return reinterpret_cast<const S_USE_ITEM*>(
               &_S_USE_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(S_USE_ITEM& a, S_USE_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_USE_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_USE_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_USE_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_USE_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_USE_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_USE_ITEM& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_USE_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_USE_ITEM";
  }
  protected:
  explicit S_USE_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // .PROTOCOL.ItemInfo item = 1;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::PROTOCOL::ItemInfo& item() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ItemInfo* release_item();
  ::PROTOCOL::ItemInfo* mutable_item();
  void set_allocated_item(::PROTOCOL::ItemInfo* item);
  private:
  const ::PROTOCOL::ItemInfo& _internal_item() const;
  ::PROTOCOL::ItemInfo* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::PROTOCOL::ItemInfo* item);
  ::PROTOCOL::ItemInfo* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_USE_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ItemInfo* item_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_CHANGE_STAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_CHANGE_STAT) */ {
 public:
  inline S_CHANGE_STAT() : S_CHANGE_STAT(nullptr) {}
  ~S_CHANGE_STAT() override;
  explicit constexpr S_CHANGE_STAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CHANGE_STAT(const S_CHANGE_STAT& from);
  S_CHANGE_STAT(S_CHANGE_STAT&& from) noexcept
    : S_CHANGE_STAT() {
    *this = ::std::move(from);
  }

  inline S_CHANGE_STAT& operator=(const S_CHANGE_STAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CHANGE_STAT& operator=(S_CHANGE_STAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CHANGE_STAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CHANGE_STAT* internal_default_instance() {
    return reinterpret_cast<const S_CHANGE_STAT*>(
               &_S_CHANGE_STAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(S_CHANGE_STAT& a, S_CHANGE_STAT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CHANGE_STAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CHANGE_STAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CHANGE_STAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CHANGE_STAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CHANGE_STAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_CHANGE_STAT& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CHANGE_STAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_CHANGE_STAT";
  }
  protected:
  explicit S_CHANGE_STAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .PROTOCOL.ObjectInfo object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_CHANGE_STAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ObjectInfo* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_CREATE_PLAYER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_CREATE_PLAYER) */ {
 public:
  inline C_CREATE_PLAYER() : C_CREATE_PLAYER(nullptr) {}
  ~C_CREATE_PLAYER() override;
  explicit constexpr C_CREATE_PLAYER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CREATE_PLAYER(const C_CREATE_PLAYER& from);
  C_CREATE_PLAYER(C_CREATE_PLAYER&& from) noexcept
    : C_CREATE_PLAYER() {
    *this = ::std::move(from);
  }

  inline C_CREATE_PLAYER& operator=(const C_CREATE_PLAYER& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CREATE_PLAYER& operator=(C_CREATE_PLAYER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CREATE_PLAYER& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CREATE_PLAYER* internal_default_instance() {
    return reinterpret_cast<const C_CREATE_PLAYER*>(
               &_C_CREATE_PLAYER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(C_CREATE_PLAYER& a, C_CREATE_PLAYER& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CREATE_PLAYER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CREATE_PLAYER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CREATE_PLAYER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CREATE_PLAYER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CREATE_PLAYER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_CREATE_PLAYER& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CREATE_PLAYER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_CREATE_PLAYER";
  }
  protected:
  explicit C_CREATE_PLAYER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_CREATE_PLAYER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_CREATE_PLAYER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_CREATE_PLAYER) */ {
 public:
  inline S_CREATE_PLAYER() : S_CREATE_PLAYER(nullptr) {}
  ~S_CREATE_PLAYER() override;
  explicit constexpr S_CREATE_PLAYER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CREATE_PLAYER(const S_CREATE_PLAYER& from);
  S_CREATE_PLAYER(S_CREATE_PLAYER&& from) noexcept
    : S_CREATE_PLAYER() {
    *this = ::std::move(from);
  }

  inline S_CREATE_PLAYER& operator=(const S_CREATE_PLAYER& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CREATE_PLAYER& operator=(S_CREATE_PLAYER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CREATE_PLAYER& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CREATE_PLAYER* internal_default_instance() {
    return reinterpret_cast<const S_CREATE_PLAYER*>(
               &_S_CREATE_PLAYER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(S_CREATE_PLAYER& a, S_CREATE_PLAYER& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CREATE_PLAYER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CREATE_PLAYER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CREATE_PLAYER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CREATE_PLAYER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CREATE_PLAYER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_CREATE_PLAYER& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CREATE_PLAYER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_CREATE_PLAYER";
  }
  protected:
  explicit S_CREATE_PLAYER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .PROTOCOL.ObjectInfo object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PROTOCOL::ObjectInfo& object() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_object();
  ::PROTOCOL::ObjectInfo* mutable_object();
  void set_allocated_object(::PROTOCOL::ObjectInfo* object);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_object() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PROTOCOL::ObjectInfo* object);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_CREATE_PLAYER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ObjectInfo* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_ADD_EXP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_ADD_EXP) */ {
 public:
  inline S_ADD_EXP() : S_ADD_EXP(nullptr) {}
  ~S_ADD_EXP() override;
  explicit constexpr S_ADD_EXP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ADD_EXP(const S_ADD_EXP& from);
  S_ADD_EXP(S_ADD_EXP&& from) noexcept
    : S_ADD_EXP() {
    *this = ::std::move(from);
  }

  inline S_ADD_EXP& operator=(const S_ADD_EXP& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ADD_EXP& operator=(S_ADD_EXP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ADD_EXP& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ADD_EXP* internal_default_instance() {
    return reinterpret_cast<const S_ADD_EXP*>(
               &_S_ADD_EXP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(S_ADD_EXP& a, S_ADD_EXP& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ADD_EXP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ADD_EXP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ADD_EXP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ADD_EXP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ADD_EXP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_ADD_EXP& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ADD_EXP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_ADD_EXP";
  }
  protected:
  explicit S_ADD_EXP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpFieldNumber = 1,
  };
  // int32 exp = 1;
  void clear_exp();
  int32_t exp() const;
  void set_exp(int32_t value);
  private:
  int32_t _internal_exp() const;
  void _internal_set_exp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_ADD_EXP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t exp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_LEVEL_UP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_LEVEL_UP) */ {
 public:
  inline S_LEVEL_UP() : S_LEVEL_UP(nullptr) {}
  ~S_LEVEL_UP() override;
  explicit constexpr S_LEVEL_UP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LEVEL_UP(const S_LEVEL_UP& from);
  S_LEVEL_UP(S_LEVEL_UP&& from) noexcept
    : S_LEVEL_UP() {
    *this = ::std::move(from);
  }

  inline S_LEVEL_UP& operator=(const S_LEVEL_UP& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LEVEL_UP& operator=(S_LEVEL_UP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LEVEL_UP& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LEVEL_UP* internal_default_instance() {
    return reinterpret_cast<const S_LEVEL_UP*>(
               &_S_LEVEL_UP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(S_LEVEL_UP& a, S_LEVEL_UP& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LEVEL_UP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LEVEL_UP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LEVEL_UP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LEVEL_UP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LEVEL_UP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_LEVEL_UP& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LEVEL_UP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_LEVEL_UP";
  }
  protected:
  explicit S_LEVEL_UP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .PROTOCOL.ObjectInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::PROTOCOL::ObjectInfo& info() const;
  PROTOBUF_NODISCARD ::PROTOCOL::ObjectInfo* release_info();
  ::PROTOCOL::ObjectInfo* mutable_info();
  void set_allocated_info(::PROTOCOL::ObjectInfo* info);
  private:
  const ::PROTOCOL::ObjectInfo& _internal_info() const;
  ::PROTOCOL::ObjectInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::PROTOCOL::ObjectInfo* info);
  ::PROTOCOL::ObjectInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_LEVEL_UP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::ObjectInfo* info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_ADD_QUEST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_ADD_QUEST) */ {
 public:
  inline C_ADD_QUEST() : C_ADD_QUEST(nullptr) {}
  ~C_ADD_QUEST() override;
  explicit constexpr C_ADD_QUEST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ADD_QUEST(const C_ADD_QUEST& from);
  C_ADD_QUEST(C_ADD_QUEST&& from) noexcept
    : C_ADD_QUEST() {
    *this = ::std::move(from);
  }

  inline C_ADD_QUEST& operator=(const C_ADD_QUEST& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ADD_QUEST& operator=(C_ADD_QUEST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ADD_QUEST& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ADD_QUEST* internal_default_instance() {
    return reinterpret_cast<const C_ADD_QUEST*>(
               &_C_ADD_QUEST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(C_ADD_QUEST& a, C_ADD_QUEST& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ADD_QUEST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ADD_QUEST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ADD_QUEST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ADD_QUEST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ADD_QUEST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_ADD_QUEST& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ADD_QUEST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_ADD_QUEST";
  }
  protected:
  explicit C_ADD_QUEST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestFieldNumber = 1,
  };
  // .PROTOCOL.QuestInfo quest = 1;
  bool has_quest() const;
  private:
  bool _internal_has_quest() const;
  public:
  void clear_quest();
  const ::PROTOCOL::QuestInfo& quest() const;
  PROTOBUF_NODISCARD ::PROTOCOL::QuestInfo* release_quest();
  ::PROTOCOL::QuestInfo* mutable_quest();
  void set_allocated_quest(::PROTOCOL::QuestInfo* quest);
  private:
  const ::PROTOCOL::QuestInfo& _internal_quest() const;
  ::PROTOCOL::QuestInfo* _internal_mutable_quest();
  public:
  void unsafe_arena_set_allocated_quest(
      ::PROTOCOL::QuestInfo* quest);
  ::PROTOCOL::QuestInfo* unsafe_arena_release_quest();

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_ADD_QUEST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::QuestInfo* quest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_ADD_QUEST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_ADD_QUEST) */ {
 public:
  inline S_ADD_QUEST() : S_ADD_QUEST(nullptr) {}
  ~S_ADD_QUEST() override;
  explicit constexpr S_ADD_QUEST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ADD_QUEST(const S_ADD_QUEST& from);
  S_ADD_QUEST(S_ADD_QUEST&& from) noexcept
    : S_ADD_QUEST() {
    *this = ::std::move(from);
  }

  inline S_ADD_QUEST& operator=(const S_ADD_QUEST& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ADD_QUEST& operator=(S_ADD_QUEST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ADD_QUEST& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ADD_QUEST* internal_default_instance() {
    return reinterpret_cast<const S_ADD_QUEST*>(
               &_S_ADD_QUEST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(S_ADD_QUEST& a, S_ADD_QUEST& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ADD_QUEST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ADD_QUEST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ADD_QUEST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ADD_QUEST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ADD_QUEST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_ADD_QUEST& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ADD_QUEST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_ADD_QUEST";
  }
  protected:
  explicit S_ADD_QUEST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // .PROTOCOL.QuestInfo quest = 2;
  bool has_quest() const;
  private:
  bool _internal_has_quest() const;
  public:
  void clear_quest();
  const ::PROTOCOL::QuestInfo& quest() const;
  PROTOBUF_NODISCARD ::PROTOCOL::QuestInfo* release_quest();
  ::PROTOCOL::QuestInfo* mutable_quest();
  void set_allocated_quest(::PROTOCOL::QuestInfo* quest);
  private:
  const ::PROTOCOL::QuestInfo& _internal_quest() const;
  ::PROTOCOL::QuestInfo* _internal_mutable_quest();
  public:
  void unsafe_arena_set_allocated_quest(
      ::PROTOCOL::QuestInfo* quest);
  ::PROTOCOL::QuestInfo* unsafe_arena_release_quest();

  // bool result = 1;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_ADD_QUEST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::QuestInfo* quest_;
  bool result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_QUESTLIST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_QUESTLIST) */ {
 public:
  inline S_QUESTLIST() : S_QUESTLIST(nullptr) {}
  ~S_QUESTLIST() override;
  explicit constexpr S_QUESTLIST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_QUESTLIST(const S_QUESTLIST& from);
  S_QUESTLIST(S_QUESTLIST&& from) noexcept
    : S_QUESTLIST() {
    *this = ::std::move(from);
  }

  inline S_QUESTLIST& operator=(const S_QUESTLIST& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_QUESTLIST& operator=(S_QUESTLIST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_QUESTLIST& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_QUESTLIST* internal_default_instance() {
    return reinterpret_cast<const S_QUESTLIST*>(
               &_S_QUESTLIST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(S_QUESTLIST& a, S_QUESTLIST& b) {
    a.Swap(&b);
  }
  inline void Swap(S_QUESTLIST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_QUESTLIST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_QUESTLIST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_QUESTLIST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_QUESTLIST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_QUESTLIST& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_QUESTLIST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_QUESTLIST";
  }
  protected:
  explicit S_QUESTLIST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestsFieldNumber = 1,
  };
  // repeated .PROTOCOL.QuestInfo quests = 1;
  int quests_size() const;
  private:
  int _internal_quests_size() const;
  public:
  void clear_quests();
  ::PROTOCOL::QuestInfo* mutable_quests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::QuestInfo >*
      mutable_quests();
  private:
  const ::PROTOCOL::QuestInfo& _internal_quests(int index) const;
  ::PROTOCOL::QuestInfo* _internal_add_quests();
  public:
  const ::PROTOCOL::QuestInfo& quests(int index) const;
  ::PROTOCOL::QuestInfo* add_quests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::QuestInfo >&
      quests() const;

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_QUESTLIST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::QuestInfo > quests_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_REMOVE_QUEST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_REMOVE_QUEST) */ {
 public:
  inline C_REMOVE_QUEST() : C_REMOVE_QUEST(nullptr) {}
  ~C_REMOVE_QUEST() override;
  explicit constexpr C_REMOVE_QUEST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_REMOVE_QUEST(const C_REMOVE_QUEST& from);
  C_REMOVE_QUEST(C_REMOVE_QUEST&& from) noexcept
    : C_REMOVE_QUEST() {
    *this = ::std::move(from);
  }

  inline C_REMOVE_QUEST& operator=(const C_REMOVE_QUEST& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_REMOVE_QUEST& operator=(C_REMOVE_QUEST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_REMOVE_QUEST& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_REMOVE_QUEST* internal_default_instance() {
    return reinterpret_cast<const C_REMOVE_QUEST*>(
               &_C_REMOVE_QUEST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(C_REMOVE_QUEST& a, C_REMOVE_QUEST& b) {
    a.Swap(&b);
  }
  inline void Swap(C_REMOVE_QUEST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_REMOVE_QUEST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_REMOVE_QUEST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_REMOVE_QUEST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_REMOVE_QUEST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_REMOVE_QUEST& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_REMOVE_QUEST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_REMOVE_QUEST";
  }
  protected:
  explicit C_REMOVE_QUEST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestdbidFieldNumber = 1,
  };
  // int32 questdbid = 1;
  void clear_questdbid();
  int32_t questdbid() const;
  void set_questdbid(int32_t value);
  private:
  int32_t _internal_questdbid() const;
  void _internal_set_questdbid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_REMOVE_QUEST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t questdbid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_REMOVE_QUEST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_REMOVE_QUEST) */ {
 public:
  inline S_REMOVE_QUEST() : S_REMOVE_QUEST(nullptr) {}
  ~S_REMOVE_QUEST() override;
  explicit constexpr S_REMOVE_QUEST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_REMOVE_QUEST(const S_REMOVE_QUEST& from);
  S_REMOVE_QUEST(S_REMOVE_QUEST&& from) noexcept
    : S_REMOVE_QUEST() {
    *this = ::std::move(from);
  }

  inline S_REMOVE_QUEST& operator=(const S_REMOVE_QUEST& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_REMOVE_QUEST& operator=(S_REMOVE_QUEST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_REMOVE_QUEST& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_REMOVE_QUEST* internal_default_instance() {
    return reinterpret_cast<const S_REMOVE_QUEST*>(
               &_S_REMOVE_QUEST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(S_REMOVE_QUEST& a, S_REMOVE_QUEST& b) {
    a.Swap(&b);
  }
  inline void Swap(S_REMOVE_QUEST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_REMOVE_QUEST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_REMOVE_QUEST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_REMOVE_QUEST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_REMOVE_QUEST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_REMOVE_QUEST& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_REMOVE_QUEST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_REMOVE_QUEST";
  }
  protected:
  explicit S_REMOVE_QUEST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kQuestidFieldNumber = 2,
  };
  // bool result = 1;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // int32 questid = 2;
  void clear_questid();
  int32_t questid() const;
  void set_questid(int32_t value);
  private:
  int32_t _internal_questid() const;
  void _internal_set_questid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_REMOVE_QUEST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool result_;
  int32_t questid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_COMPLETE_QUEST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_COMPLETE_QUEST) */ {
 public:
  inline C_COMPLETE_QUEST() : C_COMPLETE_QUEST(nullptr) {}
  ~C_COMPLETE_QUEST() override;
  explicit constexpr C_COMPLETE_QUEST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_COMPLETE_QUEST(const C_COMPLETE_QUEST& from);
  C_COMPLETE_QUEST(C_COMPLETE_QUEST&& from) noexcept
    : C_COMPLETE_QUEST() {
    *this = ::std::move(from);
  }

  inline C_COMPLETE_QUEST& operator=(const C_COMPLETE_QUEST& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_COMPLETE_QUEST& operator=(C_COMPLETE_QUEST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_COMPLETE_QUEST& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_COMPLETE_QUEST* internal_default_instance() {
    return reinterpret_cast<const C_COMPLETE_QUEST*>(
               &_C_COMPLETE_QUEST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(C_COMPLETE_QUEST& a, C_COMPLETE_QUEST& b) {
    a.Swap(&b);
  }
  inline void Swap(C_COMPLETE_QUEST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_COMPLETE_QUEST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_COMPLETE_QUEST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_COMPLETE_QUEST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_COMPLETE_QUEST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_COMPLETE_QUEST& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_COMPLETE_QUEST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_COMPLETE_QUEST";
  }
  protected:
  explicit C_COMPLETE_QUEST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestdbidFieldNumber = 1,
  };
  // int32 questdbid = 1;
  void clear_questdbid();
  int32_t questdbid() const;
  void set_questdbid(int32_t value);
  private:
  int32_t _internal_questdbid() const;
  void _internal_set_questdbid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_COMPLETE_QUEST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t questdbid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_COMPLETE_QUEST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_COMPLETE_QUEST) */ {
 public:
  inline S_COMPLETE_QUEST() : S_COMPLETE_QUEST(nullptr) {}
  ~S_COMPLETE_QUEST() override;
  explicit constexpr S_COMPLETE_QUEST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_COMPLETE_QUEST(const S_COMPLETE_QUEST& from);
  S_COMPLETE_QUEST(S_COMPLETE_QUEST&& from) noexcept
    : S_COMPLETE_QUEST() {
    *this = ::std::move(from);
  }

  inline S_COMPLETE_QUEST& operator=(const S_COMPLETE_QUEST& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_COMPLETE_QUEST& operator=(S_COMPLETE_QUEST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_COMPLETE_QUEST& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_COMPLETE_QUEST* internal_default_instance() {
    return reinterpret_cast<const S_COMPLETE_QUEST*>(
               &_S_COMPLETE_QUEST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(S_COMPLETE_QUEST& a, S_COMPLETE_QUEST& b) {
    a.Swap(&b);
  }
  inline void Swap(S_COMPLETE_QUEST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_COMPLETE_QUEST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_COMPLETE_QUEST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_COMPLETE_QUEST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_COMPLETE_QUEST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_COMPLETE_QUEST& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_COMPLETE_QUEST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_COMPLETE_QUEST";
  }
  protected:
  explicit S_COMPLETE_QUEST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kQuestidFieldNumber = 2,
  };
  // bool result = 1;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // int32 questid = 2;
  void clear_questid();
  int32_t questid() const;
  void set_questid(int32_t value);
  private:
  int32_t _internal_questid() const;
  void _internal_set_questid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_COMPLETE_QUEST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool result_;
  int32_t questid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_UPDATE_QUEST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_UPDATE_QUEST) */ {
 public:
  inline C_UPDATE_QUEST() : C_UPDATE_QUEST(nullptr) {}
  ~C_UPDATE_QUEST() override;
  explicit constexpr C_UPDATE_QUEST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_UPDATE_QUEST(const C_UPDATE_QUEST& from);
  C_UPDATE_QUEST(C_UPDATE_QUEST&& from) noexcept
    : C_UPDATE_QUEST() {
    *this = ::std::move(from);
  }

  inline C_UPDATE_QUEST& operator=(const C_UPDATE_QUEST& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_UPDATE_QUEST& operator=(C_UPDATE_QUEST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_UPDATE_QUEST& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_UPDATE_QUEST* internal_default_instance() {
    return reinterpret_cast<const C_UPDATE_QUEST*>(
               &_C_UPDATE_QUEST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(C_UPDATE_QUEST& a, C_UPDATE_QUEST& b) {
    a.Swap(&b);
  }
  inline void Swap(C_UPDATE_QUEST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_UPDATE_QUEST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_UPDATE_QUEST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_UPDATE_QUEST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_UPDATE_QUEST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_UPDATE_QUEST& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_UPDATE_QUEST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_UPDATE_QUEST";
  }
  protected:
  explicit C_UPDATE_QUEST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestinfoFieldNumber = 1,
    kObjectidFieldNumber = 2,
  };
  // .PROTOCOL.QuestInfo questinfo = 1;
  bool has_questinfo() const;
  private:
  bool _internal_has_questinfo() const;
  public:
  void clear_questinfo();
  const ::PROTOCOL::QuestInfo& questinfo() const;
  PROTOBUF_NODISCARD ::PROTOCOL::QuestInfo* release_questinfo();
  ::PROTOCOL::QuestInfo* mutable_questinfo();
  void set_allocated_questinfo(::PROTOCOL::QuestInfo* questinfo);
  private:
  const ::PROTOCOL::QuestInfo& _internal_questinfo() const;
  ::PROTOCOL::QuestInfo* _internal_mutable_questinfo();
  public:
  void unsafe_arena_set_allocated_questinfo(
      ::PROTOCOL::QuestInfo* questinfo);
  ::PROTOCOL::QuestInfo* unsafe_arena_release_questinfo();

  // int32 objectid = 2;
  void clear_objectid();
  int32_t objectid() const;
  void set_objectid(int32_t value);
  private:
  int32_t _internal_objectid() const;
  void _internal_set_objectid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_UPDATE_QUEST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::QuestInfo* questinfo_;
  int32_t objectid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_UPDATE_QUEST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_UPDATE_QUEST) */ {
 public:
  inline S_UPDATE_QUEST() : S_UPDATE_QUEST(nullptr) {}
  ~S_UPDATE_QUEST() override;
  explicit constexpr S_UPDATE_QUEST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_UPDATE_QUEST(const S_UPDATE_QUEST& from);
  S_UPDATE_QUEST(S_UPDATE_QUEST&& from) noexcept
    : S_UPDATE_QUEST() {
    *this = ::std::move(from);
  }

  inline S_UPDATE_QUEST& operator=(const S_UPDATE_QUEST& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_UPDATE_QUEST& operator=(S_UPDATE_QUEST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_UPDATE_QUEST& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_UPDATE_QUEST* internal_default_instance() {
    return reinterpret_cast<const S_UPDATE_QUEST*>(
               &_S_UPDATE_QUEST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(S_UPDATE_QUEST& a, S_UPDATE_QUEST& b) {
    a.Swap(&b);
  }
  inline void Swap(S_UPDATE_QUEST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_UPDATE_QUEST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_UPDATE_QUEST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_UPDATE_QUEST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_UPDATE_QUEST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_UPDATE_QUEST& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_UPDATE_QUEST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_UPDATE_QUEST";
  }
  protected:
  explicit S_UPDATE_QUEST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestInfoFieldNumber = 1,
  };
  // .PROTOCOL.QuestInfo questInfo = 1;
  bool has_questinfo() const;
  private:
  bool _internal_has_questinfo() const;
  public:
  void clear_questinfo();
  const ::PROTOCOL::QuestInfo& questinfo() const;
  PROTOBUF_NODISCARD ::PROTOCOL::QuestInfo* release_questinfo();
  ::PROTOCOL::QuestInfo* mutable_questinfo();
  void set_allocated_questinfo(::PROTOCOL::QuestInfo* questinfo);
  private:
  const ::PROTOCOL::QuestInfo& _internal_questinfo() const;
  ::PROTOCOL::QuestInfo* _internal_mutable_questinfo();
  public:
  void unsafe_arena_set_allocated_questinfo(
      ::PROTOCOL::QuestInfo* questinfo);
  ::PROTOCOL::QuestInfo* unsafe_arena_release_questinfo();

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_UPDATE_QUEST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::QuestInfo* questinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_TEST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_TEST) */ {
 public:
  inline C_TEST() : C_TEST(nullptr) {}
  ~C_TEST() override;
  explicit constexpr C_TEST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_TEST(const C_TEST& from);
  C_TEST(C_TEST&& from) noexcept
    : C_TEST() {
    *this = ::std::move(from);
  }

  inline C_TEST& operator=(const C_TEST& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_TEST& operator=(C_TEST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_TEST& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_TEST* internal_default_instance() {
    return reinterpret_cast<const C_TEST*>(
               &_C_TEST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(C_TEST& a, C_TEST& b) {
    a.Swap(&b);
  }
  inline void Swap(C_TEST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_TEST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_TEST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_TEST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_TEST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_TEST& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_TEST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_TEST";
  }
  protected:
  explicit C_TEST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestintFieldNumber = 1,
    kTestboolFieldNumber = 2,
  };
  // int32 testint = 1;
  void clear_testint();
  int32_t testint() const;
  void set_testint(int32_t value);
  private:
  int32_t _internal_testint() const;
  void _internal_set_testint(int32_t value);
  public:

  // bool testbool = 2;
  void clear_testbool();
  bool testbool() const;
  void set_testbool(bool value);
  private:
  bool _internal_testbool() const;
  void _internal_set_testbool(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_TEST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t testint_;
  bool testbool_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class S_TEST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.S_TEST) */ {
 public:
  inline S_TEST() : S_TEST(nullptr) {}
  ~S_TEST() override;
  explicit constexpr S_TEST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_TEST(const S_TEST& from);
  S_TEST(S_TEST&& from) noexcept
    : S_TEST() {
    *this = ::std::move(from);
  }

  inline S_TEST& operator=(const S_TEST& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_TEST& operator=(S_TEST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_TEST& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_TEST* internal_default_instance() {
    return reinterpret_cast<const S_TEST*>(
               &_S_TEST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(S_TEST& a, S_TEST& b) {
    a.Swap(&b);
  }
  inline void Swap(S_TEST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_TEST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_TEST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_TEST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_TEST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_TEST& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_TEST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.S_TEST";
  }
  protected:
  explicit S_TEST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestintFieldNumber = 1,
    kTestboolFieldNumber = 2,
  };
  // int32 testint = 1;
  void clear_testint();
  int32_t testint() const;
  void set_testint(int32_t value);
  private:
  int32_t _internal_testint() const;
  void _internal_set_testint(int32_t value);
  public:

  // bool testbool = 2;
  void clear_testbool();
  bool testbool() const;
  void set_testbool(bool value);
  private:
  bool _internal_testbool() const;
  void _internal_set_testbool(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.S_TEST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t testint_;
  bool testbool_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class C_BOT_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.C_BOT_LOGIN) */ {
 public:
  inline C_BOT_LOGIN() : C_BOT_LOGIN(nullptr) {}
  ~C_BOT_LOGIN() override;
  explicit constexpr C_BOT_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_BOT_LOGIN(const C_BOT_LOGIN& from);
  C_BOT_LOGIN(C_BOT_LOGIN&& from) noexcept
    : C_BOT_LOGIN() {
    *this = ::std::move(from);
  }

  inline C_BOT_LOGIN& operator=(const C_BOT_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_BOT_LOGIN& operator=(C_BOT_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_BOT_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_BOT_LOGIN* internal_default_instance() {
    return reinterpret_cast<const C_BOT_LOGIN*>(
               &_C_BOT_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(C_BOT_LOGIN& a, C_BOT_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(C_BOT_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_BOT_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_BOT_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_BOT_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_BOT_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_BOT_LOGIN& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_BOT_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.C_BOT_LOGIN";
  }
  protected:
  explicit C_BOT_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 1,
  };
  // bool test = 1;
  void clear_test();
  bool test() const;
  void set_test(bool value);
  private:
  bool _internal_test() const;
  void _internal_set_test(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.C_BOT_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool test_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class PFVector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.PFVector) */ {
 public:
  inline PFVector() : PFVector(nullptr) {}
  ~PFVector() override;
  explicit constexpr PFVector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PFVector(const PFVector& from);
  PFVector(PFVector&& from) noexcept
    : PFVector() {
    *this = ::std::move(from);
  }

  inline PFVector& operator=(const PFVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline PFVector& operator=(PFVector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PFVector& default_instance() {
    return *internal_default_instance();
  }
  static inline const PFVector* internal_default_instance() {
    return reinterpret_cast<const PFVector*>(
               &_PFVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(PFVector& a, PFVector& b) {
    a.Swap(&b);
  }
  inline void Swap(PFVector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PFVector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PFVector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PFVector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PFVector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PFVector& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PFVector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.PFVector";
  }
  protected:
  explicit PFVector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.PFVector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class AI_C_PATHFIND final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.AI_C_PATHFIND) */ {
 public:
  inline AI_C_PATHFIND() : AI_C_PATHFIND(nullptr) {}
  ~AI_C_PATHFIND() override;
  explicit constexpr AI_C_PATHFIND(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AI_C_PATHFIND(const AI_C_PATHFIND& from);
  AI_C_PATHFIND(AI_C_PATHFIND&& from) noexcept
    : AI_C_PATHFIND() {
    *this = ::std::move(from);
  }

  inline AI_C_PATHFIND& operator=(const AI_C_PATHFIND& from) {
    CopyFrom(from);
    return *this;
  }
  inline AI_C_PATHFIND& operator=(AI_C_PATHFIND&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AI_C_PATHFIND& default_instance() {
    return *internal_default_instance();
  }
  static inline const AI_C_PATHFIND* internal_default_instance() {
    return reinterpret_cast<const AI_C_PATHFIND*>(
               &_AI_C_PATHFIND_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(AI_C_PATHFIND& a, AI_C_PATHFIND& b) {
    a.Swap(&b);
  }
  inline void Swap(AI_C_PATHFIND* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AI_C_PATHFIND* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AI_C_PATHFIND* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AI_C_PATHFIND>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AI_C_PATHFIND& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AI_C_PATHFIND& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AI_C_PATHFIND* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.AI_C_PATHFIND";
  }
  protected:
  explicit AI_C_PATHFIND(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpFieldNumber = 3,
    kEpFieldNumber = 4,
    kMonsteridFieldNumber = 1,
    kMapidFieldNumber = 2,
    kRandomFieldNumber = 5,
    kRadiusFieldNumber = 6,
  };
  // .PROTOCOL.PFVector sp = 3;
  bool has_sp() const;
  private:
  bool _internal_has_sp() const;
  public:
  void clear_sp();
  const ::PROTOCOL::PFVector& sp() const;
  PROTOBUF_NODISCARD ::PROTOCOL::PFVector* release_sp();
  ::PROTOCOL::PFVector* mutable_sp();
  void set_allocated_sp(::PROTOCOL::PFVector* sp);
  private:
  const ::PROTOCOL::PFVector& _internal_sp() const;
  ::PROTOCOL::PFVector* _internal_mutable_sp();
  public:
  void unsafe_arena_set_allocated_sp(
      ::PROTOCOL::PFVector* sp);
  ::PROTOCOL::PFVector* unsafe_arena_release_sp();

  // .PROTOCOL.PFVector ep = 4;
  bool has_ep() const;
  private:
  bool _internal_has_ep() const;
  public:
  void clear_ep();
  const ::PROTOCOL::PFVector& ep() const;
  PROTOBUF_NODISCARD ::PROTOCOL::PFVector* release_ep();
  ::PROTOCOL::PFVector* mutable_ep();
  void set_allocated_ep(::PROTOCOL::PFVector* ep);
  private:
  const ::PROTOCOL::PFVector& _internal_ep() const;
  ::PROTOCOL::PFVector* _internal_mutable_ep();
  public:
  void unsafe_arena_set_allocated_ep(
      ::PROTOCOL::PFVector* ep);
  ::PROTOCOL::PFVector* unsafe_arena_release_ep();

  // int32 monsterid = 1;
  void clear_monsterid();
  int32_t monsterid() const;
  void set_monsterid(int32_t value);
  private:
  int32_t _internal_monsterid() const;
  void _internal_set_monsterid(int32_t value);
  public:

  // int32 mapid = 2;
  void clear_mapid();
  int32_t mapid() const;
  void set_mapid(int32_t value);
  private:
  int32_t _internal_mapid() const;
  void _internal_set_mapid(int32_t value);
  public:

  // bool random = 5;
  void clear_random();
  bool random() const;
  void set_random(bool value);
  private:
  bool _internal_random() const;
  void _internal_set_random(bool value);
  public:

  // float radius = 6;
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.AI_C_PATHFIND)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOCOL::PFVector* sp_;
  ::PROTOCOL::PFVector* ep_;
  int32_t monsterid_;
  int32_t mapid_;
  bool random_;
  float radius_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// -------------------------------------------------------------------

class AI_S_PATHFIND final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PROTOCOL.AI_S_PATHFIND) */ {
 public:
  inline AI_S_PATHFIND() : AI_S_PATHFIND(nullptr) {}
  ~AI_S_PATHFIND() override;
  explicit constexpr AI_S_PATHFIND(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AI_S_PATHFIND(const AI_S_PATHFIND& from);
  AI_S_PATHFIND(AI_S_PATHFIND&& from) noexcept
    : AI_S_PATHFIND() {
    *this = ::std::move(from);
  }

  inline AI_S_PATHFIND& operator=(const AI_S_PATHFIND& from) {
    CopyFrom(from);
    return *this;
  }
  inline AI_S_PATHFIND& operator=(AI_S_PATHFIND&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AI_S_PATHFIND& default_instance() {
    return *internal_default_instance();
  }
  static inline const AI_S_PATHFIND* internal_default_instance() {
    return reinterpret_cast<const AI_S_PATHFIND*>(
               &_AI_S_PATHFIND_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(AI_S_PATHFIND& a, AI_S_PATHFIND& b) {
    a.Swap(&b);
  }
  inline void Swap(AI_S_PATHFIND* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AI_S_PATHFIND* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AI_S_PATHFIND* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AI_S_PATHFIND>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AI_S_PATHFIND& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AI_S_PATHFIND& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AI_S_PATHFIND* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PROTOCOL.AI_S_PATHFIND";
  }
  protected:
  explicit AI_S_PATHFIND(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathsFieldNumber = 3,
    kMonsteridFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // repeated .PROTOCOL.PFVector paths = 3;
  int paths_size() const;
  private:
  int _internal_paths_size() const;
  public:
  void clear_paths();
  ::PROTOCOL::PFVector* mutable_paths(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::PFVector >*
      mutable_paths();
  private:
  const ::PROTOCOL::PFVector& _internal_paths(int index) const;
  ::PROTOCOL::PFVector* _internal_add_paths();
  public:
  const ::PROTOCOL::PFVector& paths(int index) const;
  ::PROTOCOL::PFVector* add_paths();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::PFVector >&
      paths() const;

  // int32 monsterid = 1;
  void clear_monsterid();
  int32_t monsterid() const;
  void set_monsterid(int32_t value);
  private:
  int32_t _internal_monsterid() const;
  void _internal_set_monsterid(int32_t value);
  public:

  // bool result = 2;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PROTOCOL.AI_S_PATHFIND)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::PFVector > paths_;
  int32_t monsterid_;
  bool result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol3_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Position

// .PROTOCOL.PFVector location = 1;
inline bool Position::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool Position::has_location() const {
  return _internal_has_location();
}
inline void Position::clear_location() {
  if (GetArenaForAllocation() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::PROTOCOL::PFVector& Position::_internal_location() const {
  const ::PROTOCOL::PFVector* p = location_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::PFVector&>(
      ::PROTOCOL::_PFVector_default_instance_);
}
inline const ::PROTOCOL::PFVector& Position::location() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Position.location)
  return _internal_location();
}
inline void Position::unsafe_arena_set_allocated_location(
    ::PROTOCOL::PFVector* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.Position.location)
}
inline ::PROTOCOL::PFVector* Position::release_location() {
  
  ::PROTOCOL::PFVector* temp = location_;
  location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::PFVector* Position::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:PROTOCOL.Position.location)
  
  ::PROTOCOL::PFVector* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::PROTOCOL::PFVector* Position::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::PFVector>(GetArenaForAllocation());
    location_ = p;
  }
  return location_;
}
inline ::PROTOCOL::PFVector* Position::mutable_location() {
  ::PROTOCOL::PFVector* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.Position.location)
  return _msg;
}
inline void Position::set_allocated_location(::PROTOCOL::PFVector* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::PFVector>::GetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.Position.location)
}

// .PROTOCOL.PFVector rotation = 2;
inline bool Position::_internal_has_rotation() const {
  return this != internal_default_instance() && rotation_ != nullptr;
}
inline bool Position::has_rotation() const {
  return _internal_has_rotation();
}
inline void Position::clear_rotation() {
  if (GetArenaForAllocation() == nullptr && rotation_ != nullptr) {
    delete rotation_;
  }
  rotation_ = nullptr;
}
inline const ::PROTOCOL::PFVector& Position::_internal_rotation() const {
  const ::PROTOCOL::PFVector* p = rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::PFVector&>(
      ::PROTOCOL::_PFVector_default_instance_);
}
inline const ::PROTOCOL::PFVector& Position::rotation() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Position.rotation)
  return _internal_rotation();
}
inline void Position::unsafe_arena_set_allocated_rotation(
    ::PROTOCOL::PFVector* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_);
  }
  rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.Position.rotation)
}
inline ::PROTOCOL::PFVector* Position::release_rotation() {
  
  ::PROTOCOL::PFVector* temp = rotation_;
  rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::PFVector* Position::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:PROTOCOL.Position.rotation)
  
  ::PROTOCOL::PFVector* temp = rotation_;
  rotation_ = nullptr;
  return temp;
}
inline ::PROTOCOL::PFVector* Position::_internal_mutable_rotation() {
  
  if (rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::PFVector>(GetArenaForAllocation());
    rotation_ = p;
  }
  return rotation_;
}
inline ::PROTOCOL::PFVector* Position::mutable_rotation() {
  ::PROTOCOL::PFVector* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.Position.rotation)
  return _msg;
}
inline void Position::set_allocated_rotation(::PROTOCOL::PFVector* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::PFVector>::GetOwningArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.Position.rotation)
}

// .PROTOCOL.PFVector velocity = 3;
inline bool Position::_internal_has_velocity() const {
  return this != internal_default_instance() && velocity_ != nullptr;
}
inline bool Position::has_velocity() const {
  return _internal_has_velocity();
}
inline void Position::clear_velocity() {
  if (GetArenaForAllocation() == nullptr && velocity_ != nullptr) {
    delete velocity_;
  }
  velocity_ = nullptr;
}
inline const ::PROTOCOL::PFVector& Position::_internal_velocity() const {
  const ::PROTOCOL::PFVector* p = velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::PFVector&>(
      ::PROTOCOL::_PFVector_default_instance_);
}
inline const ::PROTOCOL::PFVector& Position::velocity() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Position.velocity)
  return _internal_velocity();
}
inline void Position::unsafe_arena_set_allocated_velocity(
    ::PROTOCOL::PFVector* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_);
  }
  velocity_ = velocity;
  if (velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.Position.velocity)
}
inline ::PROTOCOL::PFVector* Position::release_velocity() {
  
  ::PROTOCOL::PFVector* temp = velocity_;
  velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::PFVector* Position::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:PROTOCOL.Position.velocity)
  
  ::PROTOCOL::PFVector* temp = velocity_;
  velocity_ = nullptr;
  return temp;
}
inline ::PROTOCOL::PFVector* Position::_internal_mutable_velocity() {
  
  if (velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::PFVector>(GetArenaForAllocation());
    velocity_ = p;
  }
  return velocity_;
}
inline ::PROTOCOL::PFVector* Position::mutable_velocity() {
  ::PROTOCOL::PFVector* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.Position.velocity)
  return _msg;
}
inline void Position::set_allocated_velocity(::PROTOCOL::PFVector* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::PFVector>::GetOwningArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.Position.velocity)
}

// -------------------------------------------------------------------

// Stat

// int32 level = 1;
inline void Stat::clear_level() {
  level_ = 0;
}
inline int32_t Stat::_internal_level() const {
  return level_;
}
inline int32_t Stat::level() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.level)
  return _internal_level();
}
inline void Stat::_internal_set_level(int32_t value) {
  
  level_ = value;
}
inline void Stat::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.level)
}

// int32 totalExp = 2;
inline void Stat::clear_totalexp() {
  totalexp_ = 0;
}
inline int32_t Stat::_internal_totalexp() const {
  return totalexp_;
}
inline int32_t Stat::totalexp() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.totalExp)
  return _internal_totalexp();
}
inline void Stat::_internal_set_totalexp(int32_t value) {
  
  totalexp_ = value;
}
inline void Stat::set_totalexp(int32_t value) {
  _internal_set_totalexp(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.totalExp)
}

// int32 exp = 3;
inline void Stat::clear_exp() {
  exp_ = 0;
}
inline int32_t Stat::_internal_exp() const {
  return exp_;
}
inline int32_t Stat::exp() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.exp)
  return _internal_exp();
}
inline void Stat::_internal_set_exp(int32_t value) {
  
  exp_ = value;
}
inline void Stat::set_exp(int32_t value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.exp)
}

// int32 maxhp = 4;
inline void Stat::clear_maxhp() {
  maxhp_ = 0;
}
inline int32_t Stat::_internal_maxhp() const {
  return maxhp_;
}
inline int32_t Stat::maxhp() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.maxhp)
  return _internal_maxhp();
}
inline void Stat::_internal_set_maxhp(int32_t value) {
  
  maxhp_ = value;
}
inline void Stat::set_maxhp(int32_t value) {
  _internal_set_maxhp(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.maxhp)
}

// int32 hp = 5;
inline void Stat::clear_hp() {
  hp_ = 0;
}
inline int32_t Stat::_internal_hp() const {
  return hp_;
}
inline int32_t Stat::hp() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.hp)
  return _internal_hp();
}
inline void Stat::_internal_set_hp(int32_t value) {
  
  hp_ = value;
}
inline void Stat::set_hp(int32_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.hp)
}

// int32 damage = 6;
inline void Stat::clear_damage() {
  damage_ = 0;
}
inline int32_t Stat::_internal_damage() const {
  return damage_;
}
inline int32_t Stat::damage() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.damage)
  return _internal_damage();
}
inline void Stat::_internal_set_damage(int32_t value) {
  
  damage_ = value;
}
inline void Stat::set_damage(int32_t value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.damage)
}

// int32 defence = 7;
inline void Stat::clear_defence() {
  defence_ = 0;
}
inline int32_t Stat::_internal_defence() const {
  return defence_;
}
inline int32_t Stat::defence() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.defence)
  return _internal_defence();
}
inline void Stat::_internal_set_defence(int32_t value) {
  
  defence_ = value;
}
inline void Stat::set_defence(int32_t value) {
  _internal_set_defence(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.defence)
}

// float speed = 8;
inline void Stat::clear_speed() {
  speed_ = 0;
}
inline float Stat::_internal_speed() const {
  return speed_;
}
inline float Stat::speed() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.speed)
  return _internal_speed();
}
inline void Stat::_internal_set_speed(float value) {
  
  speed_ = value;
}
inline void Stat::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.speed)
}

// float attackdistance = 9;
inline void Stat::clear_attackdistance() {
  attackdistance_ = 0;
}
inline float Stat::_internal_attackdistance() const {
  return attackdistance_;
}
inline float Stat::attackdistance() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.attackdistance)
  return _internal_attackdistance();
}
inline void Stat::_internal_set_attackdistance(float value) {
  
  attackdistance_ = value;
}
inline void Stat::set_attackdistance(float value) {
  _internal_set_attackdistance(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.attackdistance)
}

// float noticedistance = 10;
inline void Stat::clear_noticedistance() {
  noticedistance_ = 0;
}
inline float Stat::_internal_noticedistance() const {
  return noticedistance_;
}
inline float Stat::noticedistance() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.noticedistance)
  return _internal_noticedistance();
}
inline void Stat::_internal_set_noticedistance(float value) {
  
  noticedistance_ = value;
}
inline void Stat::set_noticedistance(float value) {
  _internal_set_noticedistance(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.noticedistance)
}

// float returndistance = 11;
inline void Stat::clear_returndistance() {
  returndistance_ = 0;
}
inline float Stat::_internal_returndistance() const {
  return returndistance_;
}
inline float Stat::returndistance() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.returndistance)
  return _internal_returndistance();
}
inline void Stat::_internal_set_returndistance(float value) {
  
  returndistance_ = value;
}
inline void Stat::set_returndistance(float value) {
  _internal_set_returndistance(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.returndistance)
}

// float attackcooltime = 12;
inline void Stat::clear_attackcooltime() {
  attackcooltime_ = 0;
}
inline float Stat::_internal_attackcooltime() const {
  return attackcooltime_;
}
inline float Stat::attackcooltime() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Stat.attackcooltime)
  return _internal_attackcooltime();
}
inline void Stat::_internal_set_attackcooltime(float value) {
  
  attackcooltime_ = value;
}
inline void Stat::set_attackcooltime(float value) {
  _internal_set_attackcooltime(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Stat.attackcooltime)
}

// -------------------------------------------------------------------

// ObjectInfo

// int32 objectId = 1;
inline void ObjectInfo::clear_objectid() {
  objectid_ = 0;
}
inline int32_t ObjectInfo::_internal_objectid() const {
  return objectid_;
}
inline int32_t ObjectInfo::objectid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ObjectInfo.objectId)
  return _internal_objectid();
}
inline void ObjectInfo::_internal_set_objectid(int32_t value) {
  
  objectid_ = value;
}
inline void ObjectInfo::set_objectid(int32_t value) {
  _internal_set_objectid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ObjectInfo.objectId)
}

// int32 playerdbid = 2;
inline void ObjectInfo::clear_playerdbid() {
  playerdbid_ = 0;
}
inline int32_t ObjectInfo::_internal_playerdbid() const {
  return playerdbid_;
}
inline int32_t ObjectInfo::playerdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ObjectInfo.playerdbid)
  return _internal_playerdbid();
}
inline void ObjectInfo::_internal_set_playerdbid(int32_t value) {
  
  playerdbid_ = value;
}
inline void ObjectInfo::set_playerdbid(int32_t value) {
  _internal_set_playerdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ObjectInfo.playerdbid)
}

// string name = 3;
inline void ObjectInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ObjectInfo::name() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ObjectInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PROTOCOL.ObjectInfo.name)
}
inline std::string* ObjectInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.ObjectInfo.name)
  return _s;
}
inline const std::string& ObjectInfo::_internal_name() const {
  return name_.Get();
}
inline void ObjectInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ObjectInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ObjectInfo::release_name() {
  // @@protoc_insertion_point(field_release:PROTOCOL.ObjectInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ObjectInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.ObjectInfo.name)
}

// .PROTOCOL.GameObjectType objecttype = 4;
inline void ObjectInfo::clear_objecttype() {
  objecttype_ = 0;
}
inline ::PROTOCOL::GameObjectType ObjectInfo::_internal_objecttype() const {
  return static_cast< ::PROTOCOL::GameObjectType >(objecttype_);
}
inline ::PROTOCOL::GameObjectType ObjectInfo::objecttype() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ObjectInfo.objecttype)
  return _internal_objecttype();
}
inline void ObjectInfo::_internal_set_objecttype(::PROTOCOL::GameObjectType value) {
  
  objecttype_ = value;
}
inline void ObjectInfo::set_objecttype(::PROTOCOL::GameObjectType value) {
  _internal_set_objecttype(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ObjectInfo.objecttype)
}

// int32 typetemplateid = 5;
inline void ObjectInfo::clear_typetemplateid() {
  typetemplateid_ = 0;
}
inline int32_t ObjectInfo::_internal_typetemplateid() const {
  return typetemplateid_;
}
inline int32_t ObjectInfo::typetemplateid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ObjectInfo.typetemplateid)
  return _internal_typetemplateid();
}
inline void ObjectInfo::_internal_set_typetemplateid(int32_t value) {
  
  typetemplateid_ = value;
}
inline void ObjectInfo::set_typetemplateid(int32_t value) {
  _internal_set_typetemplateid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ObjectInfo.typetemplateid)
}

// .PROTOCOL.Position pos = 6;
inline bool ObjectInfo::_internal_has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline bool ObjectInfo::has_pos() const {
  return _internal_has_pos();
}
inline void ObjectInfo::clear_pos() {
  if (GetArenaForAllocation() == nullptr && pos_ != nullptr) {
    delete pos_;
  }
  pos_ = nullptr;
}
inline const ::PROTOCOL::Position& ObjectInfo::_internal_pos() const {
  const ::PROTOCOL::Position* p = pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::Position&>(
      ::PROTOCOL::_Position_default_instance_);
}
inline const ::PROTOCOL::Position& ObjectInfo::pos() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ObjectInfo.pos)
  return _internal_pos();
}
inline void ObjectInfo::unsafe_arena_set_allocated_pos(
    ::PROTOCOL::Position* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.ObjectInfo.pos)
}
inline ::PROTOCOL::Position* ObjectInfo::release_pos() {
  
  ::PROTOCOL::Position* temp = pos_;
  pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::Position* ObjectInfo::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:PROTOCOL.ObjectInfo.pos)
  
  ::PROTOCOL::Position* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::PROTOCOL::Position* ObjectInfo::_internal_mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::Position>(GetArenaForAllocation());
    pos_ = p;
  }
  return pos_;
}
inline ::PROTOCOL::Position* ObjectInfo::mutable_pos() {
  ::PROTOCOL::Position* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.ObjectInfo.pos)
  return _msg;
}
inline void ObjectInfo::set_allocated_pos(::PROTOCOL::Position* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::Position>::GetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.ObjectInfo.pos)
}

// .PROTOCOL.Stat stat = 7;
inline bool ObjectInfo::_internal_has_stat() const {
  return this != internal_default_instance() && stat_ != nullptr;
}
inline bool ObjectInfo::has_stat() const {
  return _internal_has_stat();
}
inline void ObjectInfo::clear_stat() {
  if (GetArenaForAllocation() == nullptr && stat_ != nullptr) {
    delete stat_;
  }
  stat_ = nullptr;
}
inline const ::PROTOCOL::Stat& ObjectInfo::_internal_stat() const {
  const ::PROTOCOL::Stat* p = stat_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::Stat&>(
      ::PROTOCOL::_Stat_default_instance_);
}
inline const ::PROTOCOL::Stat& ObjectInfo::stat() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ObjectInfo.stat)
  return _internal_stat();
}
inline void ObjectInfo::unsafe_arena_set_allocated_stat(
    ::PROTOCOL::Stat* stat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stat_);
  }
  stat_ = stat;
  if (stat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.ObjectInfo.stat)
}
inline ::PROTOCOL::Stat* ObjectInfo::release_stat() {
  
  ::PROTOCOL::Stat* temp = stat_;
  stat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::Stat* ObjectInfo::unsafe_arena_release_stat() {
  // @@protoc_insertion_point(field_release:PROTOCOL.ObjectInfo.stat)
  
  ::PROTOCOL::Stat* temp = stat_;
  stat_ = nullptr;
  return temp;
}
inline ::PROTOCOL::Stat* ObjectInfo::_internal_mutable_stat() {
  
  if (stat_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::Stat>(GetArenaForAllocation());
    stat_ = p;
  }
  return stat_;
}
inline ::PROTOCOL::Stat* ObjectInfo::mutable_stat() {
  ::PROTOCOL::Stat* _msg = _internal_mutable_stat();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.ObjectInfo.stat)
  return _msg;
}
inline void ObjectInfo::set_allocated_stat(::PROTOCOL::Stat* stat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete stat_;
  }
  if (stat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::Stat>::GetOwningArena(stat);
    if (message_arena != submessage_arena) {
      stat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stat, submessage_arena);
    }
    
  } else {
    
  }
  stat_ = stat;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.ObjectInfo.stat)
}

// -------------------------------------------------------------------

// LobbyPlayerInfo

// int32 playerdbid = 1;
inline void LobbyPlayerInfo::clear_playerdbid() {
  playerdbid_ = 0;
}
inline int32_t LobbyPlayerInfo::_internal_playerdbid() const {
  return playerdbid_;
}
inline int32_t LobbyPlayerInfo::playerdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.LobbyPlayerInfo.playerdbid)
  return _internal_playerdbid();
}
inline void LobbyPlayerInfo::_internal_set_playerdbid(int32_t value) {
  
  playerdbid_ = value;
}
inline void LobbyPlayerInfo::set_playerdbid(int32_t value) {
  _internal_set_playerdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.LobbyPlayerInfo.playerdbid)
}

// string name = 2;
inline void LobbyPlayerInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& LobbyPlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.LobbyPlayerInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LobbyPlayerInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PROTOCOL.LobbyPlayerInfo.name)
}
inline std::string* LobbyPlayerInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.LobbyPlayerInfo.name)
  return _s;
}
inline const std::string& LobbyPlayerInfo::_internal_name() const {
  return name_.Get();
}
inline void LobbyPlayerInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LobbyPlayerInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LobbyPlayerInfo::release_name() {
  // @@protoc_insertion_point(field_release:PROTOCOL.LobbyPlayerInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LobbyPlayerInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.LobbyPlayerInfo.name)
}

// .PROTOCOL.Stat stat = 3;
inline bool LobbyPlayerInfo::_internal_has_stat() const {
  return this != internal_default_instance() && stat_ != nullptr;
}
inline bool LobbyPlayerInfo::has_stat() const {
  return _internal_has_stat();
}
inline void LobbyPlayerInfo::clear_stat() {
  if (GetArenaForAllocation() == nullptr && stat_ != nullptr) {
    delete stat_;
  }
  stat_ = nullptr;
}
inline const ::PROTOCOL::Stat& LobbyPlayerInfo::_internal_stat() const {
  const ::PROTOCOL::Stat* p = stat_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::Stat&>(
      ::PROTOCOL::_Stat_default_instance_);
}
inline const ::PROTOCOL::Stat& LobbyPlayerInfo::stat() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.LobbyPlayerInfo.stat)
  return _internal_stat();
}
inline void LobbyPlayerInfo::unsafe_arena_set_allocated_stat(
    ::PROTOCOL::Stat* stat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stat_);
  }
  stat_ = stat;
  if (stat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.LobbyPlayerInfo.stat)
}
inline ::PROTOCOL::Stat* LobbyPlayerInfo::release_stat() {
  
  ::PROTOCOL::Stat* temp = stat_;
  stat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::Stat* LobbyPlayerInfo::unsafe_arena_release_stat() {
  // @@protoc_insertion_point(field_release:PROTOCOL.LobbyPlayerInfo.stat)
  
  ::PROTOCOL::Stat* temp = stat_;
  stat_ = nullptr;
  return temp;
}
inline ::PROTOCOL::Stat* LobbyPlayerInfo::_internal_mutable_stat() {
  
  if (stat_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::Stat>(GetArenaForAllocation());
    stat_ = p;
  }
  return stat_;
}
inline ::PROTOCOL::Stat* LobbyPlayerInfo::mutable_stat() {
  ::PROTOCOL::Stat* _msg = _internal_mutable_stat();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.LobbyPlayerInfo.stat)
  return _msg;
}
inline void LobbyPlayerInfo::set_allocated_stat(::PROTOCOL::Stat* stat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete stat_;
  }
  if (stat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::Stat>::GetOwningArena(stat);
    if (message_arena != submessage_arena) {
      stat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stat, submessage_arena);
    }
    
  } else {
    
  }
  stat_ = stat;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.LobbyPlayerInfo.stat)
}

// -------------------------------------------------------------------

// Skill

// int32 skillId = 1;
inline void Skill::clear_skillid() {
  skillid_ = 0;
}
inline int32_t Skill::_internal_skillid() const {
  return skillid_;
}
inline int32_t Skill::skillid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.Skill.skillId)
  return _internal_skillid();
}
inline void Skill::_internal_set_skillid(int32_t value) {
  
  skillid_ = value;
}
inline void Skill::set_skillid(int32_t value) {
  _internal_set_skillid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.Skill.skillId)
}

// -------------------------------------------------------------------

// ItemInfo

// int32 itemDbId = 1;
inline void ItemInfo::clear_itemdbid() {
  itemdbid_ = 0;
}
inline int32_t ItemInfo::_internal_itemdbid() const {
  return itemdbid_;
}
inline int32_t ItemInfo::itemdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ItemInfo.itemDbId)
  return _internal_itemdbid();
}
inline void ItemInfo::_internal_set_itemdbid(int32_t value) {
  
  itemdbid_ = value;
}
inline void ItemInfo::set_itemdbid(int32_t value) {
  _internal_set_itemdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ItemInfo.itemDbId)
}

// int32 templateId = 2;
inline void ItemInfo::clear_templateid() {
  templateid_ = 0;
}
inline int32_t ItemInfo::_internal_templateid() const {
  return templateid_;
}
inline int32_t ItemInfo::templateid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ItemInfo.templateId)
  return _internal_templateid();
}
inline void ItemInfo::_internal_set_templateid(int32_t value) {
  
  templateid_ = value;
}
inline void ItemInfo::set_templateid(int32_t value) {
  _internal_set_templateid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ItemInfo.templateId)
}

// int32 count = 3;
inline void ItemInfo::clear_count() {
  count_ = 0;
}
inline int32_t ItemInfo::_internal_count() const {
  return count_;
}
inline int32_t ItemInfo::count() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ItemInfo.count)
  return _internal_count();
}
inline void ItemInfo::_internal_set_count(int32_t value) {
  
  count_ = value;
}
inline void ItemInfo::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ItemInfo.count)
}

// int32 slot = 4;
inline void ItemInfo::clear_slot() {
  slot_ = 0;
}
inline int32_t ItemInfo::_internal_slot() const {
  return slot_;
}
inline int32_t ItemInfo::slot() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ItemInfo.slot)
  return _internal_slot();
}
inline void ItemInfo::_internal_set_slot(int32_t value) {
  
  slot_ = value;
}
inline void ItemInfo::set_slot(int32_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ItemInfo.slot)
}

// bool equipped = 5;
inline void ItemInfo::clear_equipped() {
  equipped_ = false;
}
inline bool ItemInfo::_internal_equipped() const {
  return equipped_;
}
inline bool ItemInfo::equipped() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ItemInfo.equipped)
  return _internal_equipped();
}
inline void ItemInfo::_internal_set_equipped(bool value) {
  
  equipped_ = value;
}
inline void ItemInfo::set_equipped(bool value) {
  _internal_set_equipped(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ItemInfo.equipped)
}

// int32 playerdbid = 6;
inline void ItemInfo::clear_playerdbid() {
  playerdbid_ = 0;
}
inline int32_t ItemInfo::_internal_playerdbid() const {
  return playerdbid_;
}
inline int32_t ItemInfo::playerdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.ItemInfo.playerdbid)
  return _internal_playerdbid();
}
inline void ItemInfo::_internal_set_playerdbid(int32_t value) {
  
  playerdbid_ = value;
}
inline void ItemInfo::set_playerdbid(int32_t value) {
  _internal_set_playerdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.ItemInfo.playerdbid)
}

// -------------------------------------------------------------------

// QuestInfo

// int32 questdbid = 1;
inline void QuestInfo::clear_questdbid() {
  questdbid_ = 0;
}
inline int32_t QuestInfo::_internal_questdbid() const {
  return questdbid_;
}
inline int32_t QuestInfo::questdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.QuestInfo.questdbid)
  return _internal_questdbid();
}
inline void QuestInfo::_internal_set_questdbid(int32_t value) {
  
  questdbid_ = value;
}
inline void QuestInfo::set_questdbid(int32_t value) {
  _internal_set_questdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.QuestInfo.questdbid)
}

// int32 templateid = 2;
inline void QuestInfo::clear_templateid() {
  templateid_ = 0;
}
inline int32_t QuestInfo::_internal_templateid() const {
  return templateid_;
}
inline int32_t QuestInfo::templateid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.QuestInfo.templateid)
  return _internal_templateid();
}
inline void QuestInfo::_internal_set_templateid(int32_t value) {
  
  templateid_ = value;
}
inline void QuestInfo::set_templateid(int32_t value) {
  _internal_set_templateid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.QuestInfo.templateid)
}

// int32 progress = 3;
inline void QuestInfo::clear_progress() {
  progress_ = 0;
}
inline int32_t QuestInfo::_internal_progress() const {
  return progress_;
}
inline int32_t QuestInfo::progress() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.QuestInfo.progress)
  return _internal_progress();
}
inline void QuestInfo::_internal_set_progress(int32_t value) {
  
  progress_ = value;
}
inline void QuestInfo::set_progress(int32_t value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.QuestInfo.progress)
}

// bool completed = 4;
inline void QuestInfo::clear_completed() {
  completed_ = false;
}
inline bool QuestInfo::_internal_completed() const {
  return completed_;
}
inline bool QuestInfo::completed() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.QuestInfo.completed)
  return _internal_completed();
}
inline void QuestInfo::_internal_set_completed(bool value) {
  
  completed_ = value;
}
inline void QuestInfo::set_completed(bool value) {
  _internal_set_completed(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.QuestInfo.completed)
}

// int32 playerdbid = 5;
inline void QuestInfo::clear_playerdbid() {
  playerdbid_ = 0;
}
inline int32_t QuestInfo::_internal_playerdbid() const {
  return playerdbid_;
}
inline int32_t QuestInfo::playerdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.QuestInfo.playerdbid)
  return _internal_playerdbid();
}
inline void QuestInfo::_internal_set_playerdbid(int32_t value) {
  
  playerdbid_ = value;
}
inline void QuestInfo::set_playerdbid(int32_t value) {
  _internal_set_playerdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.QuestInfo.playerdbid)
}

// -------------------------------------------------------------------

// C_LOGIN

// string id = 1;
inline void C_LOGIN::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& C_LOGIN::id() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_LOGIN.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_LOGIN::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PROTOCOL.C_LOGIN.id)
}
inline std::string* C_LOGIN::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_LOGIN.id)
  return _s;
}
inline const std::string& C_LOGIN::_internal_id() const {
  return id_.Get();
}
inline void C_LOGIN::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_LOGIN::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_LOGIN::release_id() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_LOGIN.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_LOGIN::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_LOGIN.id)
}

// string pw = 2;
inline void C_LOGIN::clear_pw() {
  pw_.ClearToEmpty();
}
inline const std::string& C_LOGIN::pw() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_LOGIN.pw)
  return _internal_pw();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_LOGIN::set_pw(ArgT0&& arg0, ArgT... args) {
 
 pw_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PROTOCOL.C_LOGIN.pw)
}
inline std::string* C_LOGIN::mutable_pw() {
  std::string* _s = _internal_mutable_pw();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_LOGIN.pw)
  return _s;
}
inline const std::string& C_LOGIN::_internal_pw() const {
  return pw_.Get();
}
inline void C_LOGIN::_internal_set_pw(const std::string& value) {
  
  pw_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_LOGIN::_internal_mutable_pw() {
  
  return pw_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_LOGIN::release_pw() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_LOGIN.pw)
  return pw_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_LOGIN::set_allocated_pw(std::string* pw) {
  if (pw != nullptr) {
    
  } else {
    
  }
  pw_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pw,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pw_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pw_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_LOGIN.pw)
}

// string tokenstring = 3;
inline void C_LOGIN::clear_tokenstring() {
  tokenstring_.ClearToEmpty();
}
inline const std::string& C_LOGIN::tokenstring() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_LOGIN.tokenstring)
  return _internal_tokenstring();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_LOGIN::set_tokenstring(ArgT0&& arg0, ArgT... args) {
 
 tokenstring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PROTOCOL.C_LOGIN.tokenstring)
}
inline std::string* C_LOGIN::mutable_tokenstring() {
  std::string* _s = _internal_mutable_tokenstring();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_LOGIN.tokenstring)
  return _s;
}
inline const std::string& C_LOGIN::_internal_tokenstring() const {
  return tokenstring_.Get();
}
inline void C_LOGIN::_internal_set_tokenstring(const std::string& value) {
  
  tokenstring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_LOGIN::_internal_mutable_tokenstring() {
  
  return tokenstring_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_LOGIN::release_tokenstring() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_LOGIN.tokenstring)
  return tokenstring_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_LOGIN::set_allocated_tokenstring(std::string* tokenstring) {
  if (tokenstring != nullptr) {
    
  } else {
    
  }
  tokenstring_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tokenstring,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tokenstring_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tokenstring_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_LOGIN.tokenstring)
}

// -------------------------------------------------------------------

// S_LOGIN

// bool success = 1;
inline void S_LOGIN::clear_success() {
  success_ = false;
}
inline bool S_LOGIN::_internal_success() const {
  return success_;
}
inline bool S_LOGIN::success() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_LOGIN.success)
  return _internal_success();
}
inline void S_LOGIN::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void S_LOGIN::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_LOGIN.success)
}

// repeated .PROTOCOL.ObjectInfo objectinfos = 2;
inline int S_LOGIN::_internal_objectinfos_size() const {
  return objectinfos_.size();
}
inline int S_LOGIN::objectinfos_size() const {
  return _internal_objectinfos_size();
}
inline void S_LOGIN::clear_objectinfos() {
  objectinfos_.Clear();
}
inline ::PROTOCOL::ObjectInfo* S_LOGIN::mutable_objectinfos(int index) {
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_LOGIN.objectinfos)
  return objectinfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo >*
S_LOGIN::mutable_objectinfos() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_LOGIN.objectinfos)
  return &objectinfos_;
}
inline const ::PROTOCOL::ObjectInfo& S_LOGIN::_internal_objectinfos(int index) const {
  return objectinfos_.Get(index);
}
inline const ::PROTOCOL::ObjectInfo& S_LOGIN::objectinfos(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_LOGIN.objectinfos)
  return _internal_objectinfos(index);
}
inline ::PROTOCOL::ObjectInfo* S_LOGIN::_internal_add_objectinfos() {
  return objectinfos_.Add();
}
inline ::PROTOCOL::ObjectInfo* S_LOGIN::add_objectinfos() {
  ::PROTOCOL::ObjectInfo* _add = _internal_add_objectinfos();
  // @@protoc_insertion_point(field_add:PROTOCOL.S_LOGIN.objectinfos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo >&
S_LOGIN::objectinfos() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_LOGIN.objectinfos)
  return objectinfos_;
}

// repeated .PROTOCOL.LobbyPlayerInfo lobbyplayerinfos = 3;
inline int S_LOGIN::_internal_lobbyplayerinfos_size() const {
  return lobbyplayerinfos_.size();
}
inline int S_LOGIN::lobbyplayerinfos_size() const {
  return _internal_lobbyplayerinfos_size();
}
inline void S_LOGIN::clear_lobbyplayerinfos() {
  lobbyplayerinfos_.Clear();
}
inline ::PROTOCOL::LobbyPlayerInfo* S_LOGIN::mutable_lobbyplayerinfos(int index) {
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_LOGIN.lobbyplayerinfos)
  return lobbyplayerinfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::LobbyPlayerInfo >*
S_LOGIN::mutable_lobbyplayerinfos() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_LOGIN.lobbyplayerinfos)
  return &lobbyplayerinfos_;
}
inline const ::PROTOCOL::LobbyPlayerInfo& S_LOGIN::_internal_lobbyplayerinfos(int index) const {
  return lobbyplayerinfos_.Get(index);
}
inline const ::PROTOCOL::LobbyPlayerInfo& S_LOGIN::lobbyplayerinfos(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_LOGIN.lobbyplayerinfos)
  return _internal_lobbyplayerinfos(index);
}
inline ::PROTOCOL::LobbyPlayerInfo* S_LOGIN::_internal_add_lobbyplayerinfos() {
  return lobbyplayerinfos_.Add();
}
inline ::PROTOCOL::LobbyPlayerInfo* S_LOGIN::add_lobbyplayerinfos() {
  ::PROTOCOL::LobbyPlayerInfo* _add = _internal_add_lobbyplayerinfos();
  // @@protoc_insertion_point(field_add:PROTOCOL.S_LOGIN.lobbyplayerinfos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::LobbyPlayerInfo >&
S_LOGIN::lobbyplayerinfos() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_LOGIN.lobbyplayerinfos)
  return lobbyplayerinfos_;
}

// -------------------------------------------------------------------

// C_ENTER_ROOM

// uint64 roomNum = 1;
inline void C_ENTER_ROOM::clear_roomnum() {
  roomnum_ = uint64_t{0u};
}
inline uint64_t C_ENTER_ROOM::_internal_roomnum() const {
  return roomnum_;
}
inline uint64_t C_ENTER_ROOM::roomnum() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_ENTER_ROOM.roomNum)
  return _internal_roomnum();
}
inline void C_ENTER_ROOM::_internal_set_roomnum(uint64_t value) {
  
  roomnum_ = value;
}
inline void C_ENTER_ROOM::set_roomnum(uint64_t value) {
  _internal_set_roomnum(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_ENTER_ROOM.roomNum)
}

// .PROTOCOL.ObjectInfo object = 2;
inline bool C_ENTER_ROOM::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool C_ENTER_ROOM::has_object() const {
  return _internal_has_object();
}
inline void C_ENTER_ROOM::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& C_ENTER_ROOM::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& C_ENTER_ROOM::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_ENTER_ROOM.object)
  return _internal_object();
}
inline void C_ENTER_ROOM::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.C_ENTER_ROOM.object)
}
inline ::PROTOCOL::ObjectInfo* C_ENTER_ROOM::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* C_ENTER_ROOM::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_ENTER_ROOM.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* C_ENTER_ROOM::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* C_ENTER_ROOM::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_ENTER_ROOM.object)
  return _msg;
}
inline void C_ENTER_ROOM::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_ENTER_ROOM.object)
}

// bool isrespawn = 3;
inline void C_ENTER_ROOM::clear_isrespawn() {
  isrespawn_ = false;
}
inline bool C_ENTER_ROOM::_internal_isrespawn() const {
  return isrespawn_;
}
inline bool C_ENTER_ROOM::isrespawn() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_ENTER_ROOM.isrespawn)
  return _internal_isrespawn();
}
inline void C_ENTER_ROOM::_internal_set_isrespawn(bool value) {
  
  isrespawn_ = value;
}
inline void C_ENTER_ROOM::set_isrespawn(bool value) {
  _internal_set_isrespawn(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_ENTER_ROOM.isrespawn)
}

// -------------------------------------------------------------------

// S_ENTER_ROOM

// bool success = 1;
inline void S_ENTER_ROOM::clear_success() {
  success_ = false;
}
inline bool S_ENTER_ROOM::_internal_success() const {
  return success_;
}
inline bool S_ENTER_ROOM::success() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_ENTER_ROOM.success)
  return _internal_success();
}
inline void S_ENTER_ROOM::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void S_ENTER_ROOM::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_ENTER_ROOM.success)
}

// .PROTOCOL.ObjectInfo object = 2;
inline bool S_ENTER_ROOM::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool S_ENTER_ROOM::has_object() const {
  return _internal_has_object();
}
inline void S_ENTER_ROOM::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& S_ENTER_ROOM::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& S_ENTER_ROOM::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_ENTER_ROOM.object)
  return _internal_object();
}
inline void S_ENTER_ROOM::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_ENTER_ROOM.object)
}
inline ::PROTOCOL::ObjectInfo* S_ENTER_ROOM::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_ENTER_ROOM::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_ENTER_ROOM.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_ENTER_ROOM::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* S_ENTER_ROOM::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_ENTER_ROOM.object)
  return _msg;
}
inline void S_ENTER_ROOM::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_ENTER_ROOM.object)
}

// repeated .PROTOCOL.ItemInfo items = 3;
inline int S_ENTER_ROOM::_internal_items_size() const {
  return items_.size();
}
inline int S_ENTER_ROOM::items_size() const {
  return _internal_items_size();
}
inline void S_ENTER_ROOM::clear_items() {
  items_.Clear();
}
inline ::PROTOCOL::ItemInfo* S_ENTER_ROOM::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_ENTER_ROOM.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
S_ENTER_ROOM::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_ENTER_ROOM.items)
  return &items_;
}
inline const ::PROTOCOL::ItemInfo& S_ENTER_ROOM::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::PROTOCOL::ItemInfo& S_ENTER_ROOM::items(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_ENTER_ROOM.items)
  return _internal_items(index);
}
inline ::PROTOCOL::ItemInfo* S_ENTER_ROOM::_internal_add_items() {
  return items_.Add();
}
inline ::PROTOCOL::ItemInfo* S_ENTER_ROOM::add_items() {
  ::PROTOCOL::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:PROTOCOL.S_ENTER_ROOM.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
S_ENTER_ROOM::items() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_ENTER_ROOM.items)
  return items_;
}

// -------------------------------------------------------------------

// C_LEAVE_ROOM

// .PROTOCOL.ObjectInfo object = 1;
inline bool C_LEAVE_ROOM::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool C_LEAVE_ROOM::has_object() const {
  return _internal_has_object();
}
inline void C_LEAVE_ROOM::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& C_LEAVE_ROOM::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& C_LEAVE_ROOM::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_LEAVE_ROOM.object)
  return _internal_object();
}
inline void C_LEAVE_ROOM::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.C_LEAVE_ROOM.object)
}
inline ::PROTOCOL::ObjectInfo* C_LEAVE_ROOM::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* C_LEAVE_ROOM::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_LEAVE_ROOM.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* C_LEAVE_ROOM::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* C_LEAVE_ROOM::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_LEAVE_ROOM.object)
  return _msg;
}
inline void C_LEAVE_ROOM::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_LEAVE_ROOM.object)
}

// -------------------------------------------------------------------

// S_LEAVE_ROOM

// bool success = 1;
inline void S_LEAVE_ROOM::clear_success() {
  success_ = false;
}
inline bool S_LEAVE_ROOM::_internal_success() const {
  return success_;
}
inline bool S_LEAVE_ROOM::success() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_LEAVE_ROOM.success)
  return _internal_success();
}
inline void S_LEAVE_ROOM::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void S_LEAVE_ROOM::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_LEAVE_ROOM.success)
}

// .PROTOCOL.ObjectInfo object = 2;
inline bool S_LEAVE_ROOM::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool S_LEAVE_ROOM::has_object() const {
  return _internal_has_object();
}
inline void S_LEAVE_ROOM::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& S_LEAVE_ROOM::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& S_LEAVE_ROOM::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_LEAVE_ROOM.object)
  return _internal_object();
}
inline void S_LEAVE_ROOM::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_LEAVE_ROOM.object)
}
inline ::PROTOCOL::ObjectInfo* S_LEAVE_ROOM::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_LEAVE_ROOM::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_LEAVE_ROOM.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_LEAVE_ROOM::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* S_LEAVE_ROOM::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_LEAVE_ROOM.object)
  return _msg;
}
inline void S_LEAVE_ROOM::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_LEAVE_ROOM.object)
}

// -------------------------------------------------------------------

// C_SPAWN

// .PROTOCOL.ObjectInfo object = 1;
inline bool C_SPAWN::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool C_SPAWN::has_object() const {
  return _internal_has_object();
}
inline void C_SPAWN::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& C_SPAWN::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& C_SPAWN::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_SPAWN.object)
  return _internal_object();
}
inline void C_SPAWN::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.C_SPAWN.object)
}
inline ::PROTOCOL::ObjectInfo* C_SPAWN::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* C_SPAWN::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_SPAWN.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* C_SPAWN::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* C_SPAWN::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_SPAWN.object)
  return _msg;
}
inline void C_SPAWN::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_SPAWN.object)
}

// -------------------------------------------------------------------

// S_SPAWN

// bool success = 1;
inline void S_SPAWN::clear_success() {
  success_ = false;
}
inline bool S_SPAWN::_internal_success() const {
  return success_;
}
inline bool S_SPAWN::success() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_SPAWN.success)
  return _internal_success();
}
inline void S_SPAWN::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void S_SPAWN::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_SPAWN.success)
}

// repeated .PROTOCOL.ObjectInfo object = 2;
inline int S_SPAWN::_internal_object_size() const {
  return object_.size();
}
inline int S_SPAWN::object_size() const {
  return _internal_object_size();
}
inline void S_SPAWN::clear_object() {
  object_.Clear();
}
inline ::PROTOCOL::ObjectInfo* S_SPAWN::mutable_object(int index) {
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_SPAWN.object)
  return object_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo >*
S_SPAWN::mutable_object() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_SPAWN.object)
  return &object_;
}
inline const ::PROTOCOL::ObjectInfo& S_SPAWN::_internal_object(int index) const {
  return object_.Get(index);
}
inline const ::PROTOCOL::ObjectInfo& S_SPAWN::object(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_SPAWN.object)
  return _internal_object(index);
}
inline ::PROTOCOL::ObjectInfo* S_SPAWN::_internal_add_object() {
  return object_.Add();
}
inline ::PROTOCOL::ObjectInfo* S_SPAWN::add_object() {
  ::PROTOCOL::ObjectInfo* _add = _internal_add_object();
  // @@protoc_insertion_point(field_add:PROTOCOL.S_SPAWN.object)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ObjectInfo >&
S_SPAWN::object() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_SPAWN.object)
  return object_;
}

// -------------------------------------------------------------------

// C_DESPAWN

// -------------------------------------------------------------------

// S_DESPAWN

// repeated int32 objectids = 1;
inline int S_DESPAWN::_internal_objectids_size() const {
  return objectids_.size();
}
inline int S_DESPAWN::objectids_size() const {
  return _internal_objectids_size();
}
inline void S_DESPAWN::clear_objectids() {
  objectids_.Clear();
}
inline int32_t S_DESPAWN::_internal_objectids(int index) const {
  return objectids_.Get(index);
}
inline int32_t S_DESPAWN::objectids(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_DESPAWN.objectids)
  return _internal_objectids(index);
}
inline void S_DESPAWN::set_objectids(int index, int32_t value) {
  objectids_.Set(index, value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_DESPAWN.objectids)
}
inline void S_DESPAWN::_internal_add_objectids(int32_t value) {
  objectids_.Add(value);
}
inline void S_DESPAWN::add_objectids(int32_t value) {
  _internal_add_objectids(value);
  // @@protoc_insertion_point(field_add:PROTOCOL.S_DESPAWN.objectids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_DESPAWN::_internal_objectids() const {
  return objectids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_DESPAWN::objectids() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_DESPAWN.objectids)
  return _internal_objectids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_DESPAWN::_internal_mutable_objectids() {
  return &objectids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_DESPAWN::mutable_objectids() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_DESPAWN.objectids)
  return _internal_mutable_objectids();
}

// -------------------------------------------------------------------

// C_MOVE

// .PROTOCOL.ObjectInfo object = 1;
inline bool C_MOVE::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool C_MOVE::has_object() const {
  return _internal_has_object();
}
inline void C_MOVE::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& C_MOVE::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& C_MOVE::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_MOVE.object)
  return _internal_object();
}
inline void C_MOVE::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.C_MOVE.object)
}
inline ::PROTOCOL::ObjectInfo* C_MOVE::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* C_MOVE::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_MOVE.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* C_MOVE::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* C_MOVE::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_MOVE.object)
  return _msg;
}
inline void C_MOVE::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_MOVE.object)
}

// -------------------------------------------------------------------

// S_MOVE

// .PROTOCOL.ObjectInfo object = 1;
inline bool S_MOVE::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool S_MOVE::has_object() const {
  return _internal_has_object();
}
inline void S_MOVE::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& S_MOVE::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& S_MOVE::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_MOVE.object)
  return _internal_object();
}
inline void S_MOVE::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_MOVE.object)
}
inline ::PROTOCOL::ObjectInfo* S_MOVE::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_MOVE::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_MOVE.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_MOVE::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* S_MOVE::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_MOVE.object)
  return _msg;
}
inline void S_MOVE::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_MOVE.object)
}

// -------------------------------------------------------------------

// C_SKILL

// int32 skillid = 1;
inline void C_SKILL::clear_skillid() {
  skillid_ = 0;
}
inline int32_t C_SKILL::_internal_skillid() const {
  return skillid_;
}
inline int32_t C_SKILL::skillid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_SKILL.skillid)
  return _internal_skillid();
}
inline void C_SKILL::_internal_set_skillid(int32_t value) {
  
  skillid_ = value;
}
inline void C_SKILL::set_skillid(int32_t value) {
  _internal_set_skillid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_SKILL.skillid)
}

// int32 attacker = 2;
inline void C_SKILL::clear_attacker() {
  attacker_ = 0;
}
inline int32_t C_SKILL::_internal_attacker() const {
  return attacker_;
}
inline int32_t C_SKILL::attacker() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_SKILL.attacker)
  return _internal_attacker();
}
inline void C_SKILL::_internal_set_attacker(int32_t value) {
  
  attacker_ = value;
}
inline void C_SKILL::set_attacker(int32_t value) {
  _internal_set_attacker(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_SKILL.attacker)
}

// repeated int32 victims = 3;
inline int C_SKILL::_internal_victims_size() const {
  return victims_.size();
}
inline int C_SKILL::victims_size() const {
  return _internal_victims_size();
}
inline void C_SKILL::clear_victims() {
  victims_.Clear();
}
inline int32_t C_SKILL::_internal_victims(int index) const {
  return victims_.Get(index);
}
inline int32_t C_SKILL::victims(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_SKILL.victims)
  return _internal_victims(index);
}
inline void C_SKILL::set_victims(int index, int32_t value) {
  victims_.Set(index, value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_SKILL.victims)
}
inline void C_SKILL::_internal_add_victims(int32_t value) {
  victims_.Add(value);
}
inline void C_SKILL::add_victims(int32_t value) {
  _internal_add_victims(value);
  // @@protoc_insertion_point(field_add:PROTOCOL.C_SKILL.victims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
C_SKILL::_internal_victims() const {
  return victims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
C_SKILL::victims() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.C_SKILL.victims)
  return _internal_victims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
C_SKILL::_internal_mutable_victims() {
  return &victims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
C_SKILL::mutable_victims() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.C_SKILL.victims)
  return _internal_mutable_victims();
}

// -------------------------------------------------------------------

// S_SKILL

// int32 skillid = 1;
inline void S_SKILL::clear_skillid() {
  skillid_ = 0;
}
inline int32_t S_SKILL::_internal_skillid() const {
  return skillid_;
}
inline int32_t S_SKILL::skillid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_SKILL.skillid)
  return _internal_skillid();
}
inline void S_SKILL::_internal_set_skillid(int32_t value) {
  
  skillid_ = value;
}
inline void S_SKILL::set_skillid(int32_t value) {
  _internal_set_skillid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_SKILL.skillid)
}

// int32 attacker = 2;
inline void S_SKILL::clear_attacker() {
  attacker_ = 0;
}
inline int32_t S_SKILL::_internal_attacker() const {
  return attacker_;
}
inline int32_t S_SKILL::attacker() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_SKILL.attacker)
  return _internal_attacker();
}
inline void S_SKILL::_internal_set_attacker(int32_t value) {
  
  attacker_ = value;
}
inline void S_SKILL::set_attacker(int32_t value) {
  _internal_set_attacker(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_SKILL.attacker)
}

// repeated int32 victims = 3;
inline int S_SKILL::_internal_victims_size() const {
  return victims_.size();
}
inline int S_SKILL::victims_size() const {
  return _internal_victims_size();
}
inline void S_SKILL::clear_victims() {
  victims_.Clear();
}
inline int32_t S_SKILL::_internal_victims(int index) const {
  return victims_.Get(index);
}
inline int32_t S_SKILL::victims(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_SKILL.victims)
  return _internal_victims(index);
}
inline void S_SKILL::set_victims(int index, int32_t value) {
  victims_.Set(index, value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_SKILL.victims)
}
inline void S_SKILL::_internal_add_victims(int32_t value) {
  victims_.Add(value);
}
inline void S_SKILL::add_victims(int32_t value) {
  _internal_add_victims(value);
  // @@protoc_insertion_point(field_add:PROTOCOL.S_SKILL.victims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_SKILL::_internal_victims() const {
  return victims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_SKILL::victims() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_SKILL.victims)
  return _internal_victims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_SKILL::_internal_mutable_victims() {
  return &victims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_SKILL::mutable_victims() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_SKILL.victims)
  return _internal_mutable_victims();
}

// -------------------------------------------------------------------

// C_CHAT

// string text = 1;
inline void C_CHAT::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& C_CHAT::text() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_CHAT.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CHAT::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PROTOCOL.C_CHAT.text)
}
inline std::string* C_CHAT::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_CHAT.text)
  return _s;
}
inline const std::string& C_CHAT::_internal_text() const {
  return text_.Get();
}
inline void C_CHAT::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_CHAT::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_CHAT::release_text() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_CHAT.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_CHAT::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_CHAT.text)
}

// -------------------------------------------------------------------

// S_CHAT

// .PROTOCOL.ObjectInfo object = 1;
inline bool S_CHAT::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool S_CHAT::has_object() const {
  return _internal_has_object();
}
inline void S_CHAT::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& S_CHAT::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& S_CHAT::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_CHAT.object)
  return _internal_object();
}
inline void S_CHAT::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_CHAT.object)
}
inline ::PROTOCOL::ObjectInfo* S_CHAT::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_CHAT::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_CHAT.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_CHAT::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* S_CHAT::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_CHAT.object)
  return _msg;
}
inline void S_CHAT::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_CHAT.object)
}

// string text = 2;
inline void S_CHAT::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& S_CHAT::text() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_CHAT.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_CHAT::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PROTOCOL.S_CHAT.text)
}
inline std::string* S_CHAT::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_CHAT.text)
  return _s;
}
inline const std::string& S_CHAT::_internal_text() const {
  return text_.Get();
}
inline void S_CHAT::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* S_CHAT::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* S_CHAT::release_text() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_CHAT.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void S_CHAT::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_CHAT.text)
}

// -------------------------------------------------------------------

// S_CHANGE_HP

// int32 object = 1;
inline void S_CHANGE_HP::clear_object() {
  object_ = 0;
}
inline int32_t S_CHANGE_HP::_internal_object() const {
  return object_;
}
inline int32_t S_CHANGE_HP::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_CHANGE_HP.object)
  return _internal_object();
}
inline void S_CHANGE_HP::_internal_set_object(int32_t value) {
  
  object_ = value;
}
inline void S_CHANGE_HP::set_object(int32_t value) {
  _internal_set_object(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_CHANGE_HP.object)
}

// int32 hp = 2;
inline void S_CHANGE_HP::clear_hp() {
  hp_ = 0;
}
inline int32_t S_CHANGE_HP::_internal_hp() const {
  return hp_;
}
inline int32_t S_CHANGE_HP::hp() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_CHANGE_HP.hp)
  return _internal_hp();
}
inline void S_CHANGE_HP::_internal_set_hp(int32_t value) {
  
  hp_ = value;
}
inline void S_CHANGE_HP::set_hp(int32_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_CHANGE_HP.hp)
}

// -------------------------------------------------------------------

// S_DIE

// int32 victim = 1;
inline void S_DIE::clear_victim() {
  victim_ = 0;
}
inline int32_t S_DIE::_internal_victim() const {
  return victim_;
}
inline int32_t S_DIE::victim() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_DIE.victim)
  return _internal_victim();
}
inline void S_DIE::_internal_set_victim(int32_t value) {
  
  victim_ = value;
}
inline void S_DIE::set_victim(int32_t value) {
  _internal_set_victim(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_DIE.victim)
}

// int32 attacker = 2;
inline void S_DIE::clear_attacker() {
  attacker_ = 0;
}
inline int32_t S_DIE::_internal_attacker() const {
  return attacker_;
}
inline int32_t S_DIE::attacker() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_DIE.attacker)
  return _internal_attacker();
}
inline void S_DIE::_internal_set_attacker(int32_t value) {
  
  attacker_ = value;
}
inline void S_DIE::set_attacker(int32_t value) {
  _internal_set_attacker(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_DIE.attacker)
}

// -------------------------------------------------------------------

// S_ITEMLIST

// repeated .PROTOCOL.ItemInfo items = 1;
inline int S_ITEMLIST::_internal_items_size() const {
  return items_.size();
}
inline int S_ITEMLIST::items_size() const {
  return _internal_items_size();
}
inline void S_ITEMLIST::clear_items() {
  items_.Clear();
}
inline ::PROTOCOL::ItemInfo* S_ITEMLIST::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_ITEMLIST.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
S_ITEMLIST::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_ITEMLIST.items)
  return &items_;
}
inline const ::PROTOCOL::ItemInfo& S_ITEMLIST::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::PROTOCOL::ItemInfo& S_ITEMLIST::items(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_ITEMLIST.items)
  return _internal_items(index);
}
inline ::PROTOCOL::ItemInfo* S_ITEMLIST::_internal_add_items() {
  return items_.Add();
}
inline ::PROTOCOL::ItemInfo* S_ITEMLIST::add_items() {
  ::PROTOCOL::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:PROTOCOL.S_ITEMLIST.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
S_ITEMLIST::items() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_ITEMLIST.items)
  return items_;
}

// -------------------------------------------------------------------

// C_ADD_ITEM

// repeated .PROTOCOL.ItemInfo items = 1;
inline int C_ADD_ITEM::_internal_items_size() const {
  return items_.size();
}
inline int C_ADD_ITEM::items_size() const {
  return _internal_items_size();
}
inline void C_ADD_ITEM::clear_items() {
  items_.Clear();
}
inline ::PROTOCOL::ItemInfo* C_ADD_ITEM::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_ADD_ITEM.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
C_ADD_ITEM::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.C_ADD_ITEM.items)
  return &items_;
}
inline const ::PROTOCOL::ItemInfo& C_ADD_ITEM::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::PROTOCOL::ItemInfo& C_ADD_ITEM::items(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_ADD_ITEM.items)
  return _internal_items(index);
}
inline ::PROTOCOL::ItemInfo* C_ADD_ITEM::_internal_add_items() {
  return items_.Add();
}
inline ::PROTOCOL::ItemInfo* C_ADD_ITEM::add_items() {
  ::PROTOCOL::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:PROTOCOL.C_ADD_ITEM.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
C_ADD_ITEM::items() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.C_ADD_ITEM.items)
  return items_;
}

// -------------------------------------------------------------------

// S_ADD_ITEM

// repeated .PROTOCOL.ItemInfo items = 1;
inline int S_ADD_ITEM::_internal_items_size() const {
  return items_.size();
}
inline int S_ADD_ITEM::items_size() const {
  return _internal_items_size();
}
inline void S_ADD_ITEM::clear_items() {
  items_.Clear();
}
inline ::PROTOCOL::ItemInfo* S_ADD_ITEM::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_ADD_ITEM.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
S_ADD_ITEM::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_ADD_ITEM.items)
  return &items_;
}
inline const ::PROTOCOL::ItemInfo& S_ADD_ITEM::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::PROTOCOL::ItemInfo& S_ADD_ITEM::items(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_ADD_ITEM.items)
  return _internal_items(index);
}
inline ::PROTOCOL::ItemInfo* S_ADD_ITEM::_internal_add_items() {
  return items_.Add();
}
inline ::PROTOCOL::ItemInfo* S_ADD_ITEM::add_items() {
  ::PROTOCOL::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:PROTOCOL.S_ADD_ITEM.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
S_ADD_ITEM::items() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_ADD_ITEM.items)
  return items_;
}

// -------------------------------------------------------------------

// S_UPDATE_ITEM

// repeated .PROTOCOL.ItemInfo items = 1;
inline int S_UPDATE_ITEM::_internal_items_size() const {
  return items_.size();
}
inline int S_UPDATE_ITEM::items_size() const {
  return _internal_items_size();
}
inline void S_UPDATE_ITEM::clear_items() {
  items_.Clear();
}
inline ::PROTOCOL::ItemInfo* S_UPDATE_ITEM::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_UPDATE_ITEM.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >*
S_UPDATE_ITEM::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_UPDATE_ITEM.items)
  return &items_;
}
inline const ::PROTOCOL::ItemInfo& S_UPDATE_ITEM::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::PROTOCOL::ItemInfo& S_UPDATE_ITEM::items(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_UPDATE_ITEM.items)
  return _internal_items(index);
}
inline ::PROTOCOL::ItemInfo* S_UPDATE_ITEM::_internal_add_items() {
  return items_.Add();
}
inline ::PROTOCOL::ItemInfo* S_UPDATE_ITEM::add_items() {
  ::PROTOCOL::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:PROTOCOL.S_UPDATE_ITEM.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::ItemInfo >&
S_UPDATE_ITEM::items() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_UPDATE_ITEM.items)
  return items_;
}

// -------------------------------------------------------------------

// S_REMOVE_ITEM

// repeated int32 slots = 1;
inline int S_REMOVE_ITEM::_internal_slots_size() const {
  return slots_.size();
}
inline int S_REMOVE_ITEM::slots_size() const {
  return _internal_slots_size();
}
inline void S_REMOVE_ITEM::clear_slots() {
  slots_.Clear();
}
inline int32_t S_REMOVE_ITEM::_internal_slots(int index) const {
  return slots_.Get(index);
}
inline int32_t S_REMOVE_ITEM::slots(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_REMOVE_ITEM.slots)
  return _internal_slots(index);
}
inline void S_REMOVE_ITEM::set_slots(int index, int32_t value) {
  slots_.Set(index, value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_REMOVE_ITEM.slots)
}
inline void S_REMOVE_ITEM::_internal_add_slots(int32_t value) {
  slots_.Add(value);
}
inline void S_REMOVE_ITEM::add_slots(int32_t value) {
  _internal_add_slots(value);
  // @@protoc_insertion_point(field_add:PROTOCOL.S_REMOVE_ITEM.slots)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_REMOVE_ITEM::_internal_slots() const {
  return slots_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_REMOVE_ITEM::slots() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_REMOVE_ITEM.slots)
  return _internal_slots();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_REMOVE_ITEM::_internal_mutable_slots() {
  return &slots_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_REMOVE_ITEM::mutable_slots() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_REMOVE_ITEM.slots)
  return _internal_mutable_slots();
}

// -------------------------------------------------------------------

// C_EQUIP_ITEM

// int32 itemdbid = 1;
inline void C_EQUIP_ITEM::clear_itemdbid() {
  itemdbid_ = 0;
}
inline int32_t C_EQUIP_ITEM::_internal_itemdbid() const {
  return itemdbid_;
}
inline int32_t C_EQUIP_ITEM::itemdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_EQUIP_ITEM.itemdbid)
  return _internal_itemdbid();
}
inline void C_EQUIP_ITEM::_internal_set_itemdbid(int32_t value) {
  
  itemdbid_ = value;
}
inline void C_EQUIP_ITEM::set_itemdbid(int32_t value) {
  _internal_set_itemdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_EQUIP_ITEM.itemdbid)
}

// int32 slot = 2;
inline void C_EQUIP_ITEM::clear_slot() {
  slot_ = 0;
}
inline int32_t C_EQUIP_ITEM::_internal_slot() const {
  return slot_;
}
inline int32_t C_EQUIP_ITEM::slot() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_EQUIP_ITEM.slot)
  return _internal_slot();
}
inline void C_EQUIP_ITEM::_internal_set_slot(int32_t value) {
  
  slot_ = value;
}
inline void C_EQUIP_ITEM::set_slot(int32_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_EQUIP_ITEM.slot)
}

// bool equip = 3;
inline void C_EQUIP_ITEM::clear_equip() {
  equip_ = false;
}
inline bool C_EQUIP_ITEM::_internal_equip() const {
  return equip_;
}
inline bool C_EQUIP_ITEM::equip() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_EQUIP_ITEM.equip)
  return _internal_equip();
}
inline void C_EQUIP_ITEM::_internal_set_equip(bool value) {
  
  equip_ = value;
}
inline void C_EQUIP_ITEM::set_equip(bool value) {
  _internal_set_equip(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_EQUIP_ITEM.equip)
}

// -------------------------------------------------------------------

// S_EQUIP_ITEM

// int32 itemdbid = 1;
inline void S_EQUIP_ITEM::clear_itemdbid() {
  itemdbid_ = 0;
}
inline int32_t S_EQUIP_ITEM::_internal_itemdbid() const {
  return itemdbid_;
}
inline int32_t S_EQUIP_ITEM::itemdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_EQUIP_ITEM.itemdbid)
  return _internal_itemdbid();
}
inline void S_EQUIP_ITEM::_internal_set_itemdbid(int32_t value) {
  
  itemdbid_ = value;
}
inline void S_EQUIP_ITEM::set_itemdbid(int32_t value) {
  _internal_set_itemdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_EQUIP_ITEM.itemdbid)
}

// int32 slot = 2;
inline void S_EQUIP_ITEM::clear_slot() {
  slot_ = 0;
}
inline int32_t S_EQUIP_ITEM::_internal_slot() const {
  return slot_;
}
inline int32_t S_EQUIP_ITEM::slot() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_EQUIP_ITEM.slot)
  return _internal_slot();
}
inline void S_EQUIP_ITEM::_internal_set_slot(int32_t value) {
  
  slot_ = value;
}
inline void S_EQUIP_ITEM::set_slot(int32_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_EQUIP_ITEM.slot)
}

// bool equip = 3;
inline void S_EQUIP_ITEM::clear_equip() {
  equip_ = false;
}
inline bool S_EQUIP_ITEM::_internal_equip() const {
  return equip_;
}
inline bool S_EQUIP_ITEM::equip() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_EQUIP_ITEM.equip)
  return _internal_equip();
}
inline void S_EQUIP_ITEM::_internal_set_equip(bool value) {
  
  equip_ = value;
}
inline void S_EQUIP_ITEM::set_equip(bool value) {
  _internal_set_equip(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_EQUIP_ITEM.equip)
}

// -------------------------------------------------------------------

// C_USE_ITEM

// int32 itemdbid = 1;
inline void C_USE_ITEM::clear_itemdbid() {
  itemdbid_ = 0;
}
inline int32_t C_USE_ITEM::_internal_itemdbid() const {
  return itemdbid_;
}
inline int32_t C_USE_ITEM::itemdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_USE_ITEM.itemdbid)
  return _internal_itemdbid();
}
inline void C_USE_ITEM::_internal_set_itemdbid(int32_t value) {
  
  itemdbid_ = value;
}
inline void C_USE_ITEM::set_itemdbid(int32_t value) {
  _internal_set_itemdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_USE_ITEM.itemdbid)
}

// int32 slot = 2;
inline void C_USE_ITEM::clear_slot() {
  slot_ = 0;
}
inline int32_t C_USE_ITEM::_internal_slot() const {
  return slot_;
}
inline int32_t C_USE_ITEM::slot() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_USE_ITEM.slot)
  return _internal_slot();
}
inline void C_USE_ITEM::_internal_set_slot(int32_t value) {
  
  slot_ = value;
}
inline void C_USE_ITEM::set_slot(int32_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_USE_ITEM.slot)
}

// bool use = 3;
inline void C_USE_ITEM::clear_use() {
  use_ = false;
}
inline bool C_USE_ITEM::_internal_use() const {
  return use_;
}
inline bool C_USE_ITEM::use() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_USE_ITEM.use)
  return _internal_use();
}
inline void C_USE_ITEM::_internal_set_use(bool value) {
  
  use_ = value;
}
inline void C_USE_ITEM::set_use(bool value) {
  _internal_set_use(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_USE_ITEM.use)
}

// -------------------------------------------------------------------

// S_USE_ITEM

// .PROTOCOL.ItemInfo item = 1;
inline bool S_USE_ITEM::_internal_has_item() const {
  return this != internal_default_instance() && item_ != nullptr;
}
inline bool S_USE_ITEM::has_item() const {
  return _internal_has_item();
}
inline void S_USE_ITEM::clear_item() {
  if (GetArenaForAllocation() == nullptr && item_ != nullptr) {
    delete item_;
  }
  item_ = nullptr;
}
inline const ::PROTOCOL::ItemInfo& S_USE_ITEM::_internal_item() const {
  const ::PROTOCOL::ItemInfo* p = item_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ItemInfo&>(
      ::PROTOCOL::_ItemInfo_default_instance_);
}
inline const ::PROTOCOL::ItemInfo& S_USE_ITEM::item() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_USE_ITEM.item)
  return _internal_item();
}
inline void S_USE_ITEM::unsafe_arena_set_allocated_item(
    ::PROTOCOL::ItemInfo* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_);
  }
  item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_USE_ITEM.item)
}
inline ::PROTOCOL::ItemInfo* S_USE_ITEM::release_item() {
  
  ::PROTOCOL::ItemInfo* temp = item_;
  item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ItemInfo* S_USE_ITEM::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_USE_ITEM.item)
  
  ::PROTOCOL::ItemInfo* temp = item_;
  item_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ItemInfo* S_USE_ITEM::_internal_mutable_item() {
  
  if (item_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ItemInfo>(GetArenaForAllocation());
    item_ = p;
  }
  return item_;
}
inline ::PROTOCOL::ItemInfo* S_USE_ITEM::mutable_item() {
  ::PROTOCOL::ItemInfo* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_USE_ITEM.item)
  return _msg;
}
inline void S_USE_ITEM::set_allocated_item(::PROTOCOL::ItemInfo* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ItemInfo>::GetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  item_ = item;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_USE_ITEM.item)
}

// -------------------------------------------------------------------

// S_CHANGE_STAT

// .PROTOCOL.ObjectInfo object = 1;
inline bool S_CHANGE_STAT::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool S_CHANGE_STAT::has_object() const {
  return _internal_has_object();
}
inline void S_CHANGE_STAT::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& S_CHANGE_STAT::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& S_CHANGE_STAT::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_CHANGE_STAT.object)
  return _internal_object();
}
inline void S_CHANGE_STAT::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_CHANGE_STAT.object)
}
inline ::PROTOCOL::ObjectInfo* S_CHANGE_STAT::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_CHANGE_STAT::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_CHANGE_STAT.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_CHANGE_STAT::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* S_CHANGE_STAT::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_CHANGE_STAT.object)
  return _msg;
}
inline void S_CHANGE_STAT::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_CHANGE_STAT.object)
}

// -------------------------------------------------------------------

// C_CREATE_PLAYER

// string name = 1;
inline void C_CREATE_PLAYER::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& C_CREATE_PLAYER::name() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_CREATE_PLAYER.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CREATE_PLAYER::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PROTOCOL.C_CREATE_PLAYER.name)
}
inline std::string* C_CREATE_PLAYER::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_CREATE_PLAYER.name)
  return _s;
}
inline const std::string& C_CREATE_PLAYER::_internal_name() const {
  return name_.Get();
}
inline void C_CREATE_PLAYER::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_CREATE_PLAYER::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_CREATE_PLAYER::release_name() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_CREATE_PLAYER.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_CREATE_PLAYER::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_CREATE_PLAYER.name)
}

// -------------------------------------------------------------------

// S_CREATE_PLAYER

// .PROTOCOL.ObjectInfo object = 1;
inline bool S_CREATE_PLAYER::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool S_CREATE_PLAYER::has_object() const {
  return _internal_has_object();
}
inline void S_CREATE_PLAYER::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& S_CREATE_PLAYER::_internal_object() const {
  const ::PROTOCOL::ObjectInfo* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& S_CREATE_PLAYER::object() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_CREATE_PLAYER.object)
  return _internal_object();
}
inline void S_CREATE_PLAYER::unsafe_arena_set_allocated_object(
    ::PROTOCOL::ObjectInfo* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_CREATE_PLAYER.object)
}
inline ::PROTOCOL::ObjectInfo* S_CREATE_PLAYER::release_object() {
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_CREATE_PLAYER::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_CREATE_PLAYER.object)
  
  ::PROTOCOL::ObjectInfo* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_CREATE_PLAYER::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PROTOCOL::ObjectInfo* S_CREATE_PLAYER::mutable_object() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_CREATE_PLAYER.object)
  return _msg;
}
inline void S_CREATE_PLAYER::set_allocated_object(::PROTOCOL::ObjectInfo* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_CREATE_PLAYER.object)
}

// -------------------------------------------------------------------

// S_ADD_EXP

// int32 exp = 1;
inline void S_ADD_EXP::clear_exp() {
  exp_ = 0;
}
inline int32_t S_ADD_EXP::_internal_exp() const {
  return exp_;
}
inline int32_t S_ADD_EXP::exp() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_ADD_EXP.exp)
  return _internal_exp();
}
inline void S_ADD_EXP::_internal_set_exp(int32_t value) {
  
  exp_ = value;
}
inline void S_ADD_EXP::set_exp(int32_t value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_ADD_EXP.exp)
}

// -------------------------------------------------------------------

// S_LEVEL_UP

// .PROTOCOL.ObjectInfo info = 1;
inline bool S_LEVEL_UP::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool S_LEVEL_UP::has_info() const {
  return _internal_has_info();
}
inline void S_LEVEL_UP::clear_info() {
  if (GetArenaForAllocation() == nullptr && info_ != nullptr) {
    delete info_;
  }
  info_ = nullptr;
}
inline const ::PROTOCOL::ObjectInfo& S_LEVEL_UP::_internal_info() const {
  const ::PROTOCOL::ObjectInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::ObjectInfo&>(
      ::PROTOCOL::_ObjectInfo_default_instance_);
}
inline const ::PROTOCOL::ObjectInfo& S_LEVEL_UP::info() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_LEVEL_UP.info)
  return _internal_info();
}
inline void S_LEVEL_UP::unsafe_arena_set_allocated_info(
    ::PROTOCOL::ObjectInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_LEVEL_UP.info)
}
inline ::PROTOCOL::ObjectInfo* S_LEVEL_UP::release_info() {
  
  ::PROTOCOL::ObjectInfo* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_LEVEL_UP::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_LEVEL_UP.info)
  
  ::PROTOCOL::ObjectInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::PROTOCOL::ObjectInfo* S_LEVEL_UP::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::ObjectInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::PROTOCOL::ObjectInfo* S_LEVEL_UP::mutable_info() {
  ::PROTOCOL::ObjectInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_LEVEL_UP.info)
  return _msg;
}
inline void S_LEVEL_UP::set_allocated_info(::PROTOCOL::ObjectInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::ObjectInfo>::GetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_LEVEL_UP.info)
}

// -------------------------------------------------------------------

// C_ADD_QUEST

// .PROTOCOL.QuestInfo quest = 1;
inline bool C_ADD_QUEST::_internal_has_quest() const {
  return this != internal_default_instance() && quest_ != nullptr;
}
inline bool C_ADD_QUEST::has_quest() const {
  return _internal_has_quest();
}
inline void C_ADD_QUEST::clear_quest() {
  if (GetArenaForAllocation() == nullptr && quest_ != nullptr) {
    delete quest_;
  }
  quest_ = nullptr;
}
inline const ::PROTOCOL::QuestInfo& C_ADD_QUEST::_internal_quest() const {
  const ::PROTOCOL::QuestInfo* p = quest_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::QuestInfo&>(
      ::PROTOCOL::_QuestInfo_default_instance_);
}
inline const ::PROTOCOL::QuestInfo& C_ADD_QUEST::quest() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_ADD_QUEST.quest)
  return _internal_quest();
}
inline void C_ADD_QUEST::unsafe_arena_set_allocated_quest(
    ::PROTOCOL::QuestInfo* quest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(quest_);
  }
  quest_ = quest;
  if (quest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.C_ADD_QUEST.quest)
}
inline ::PROTOCOL::QuestInfo* C_ADD_QUEST::release_quest() {
  
  ::PROTOCOL::QuestInfo* temp = quest_;
  quest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::QuestInfo* C_ADD_QUEST::unsafe_arena_release_quest() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_ADD_QUEST.quest)
  
  ::PROTOCOL::QuestInfo* temp = quest_;
  quest_ = nullptr;
  return temp;
}
inline ::PROTOCOL::QuestInfo* C_ADD_QUEST::_internal_mutable_quest() {
  
  if (quest_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::QuestInfo>(GetArenaForAllocation());
    quest_ = p;
  }
  return quest_;
}
inline ::PROTOCOL::QuestInfo* C_ADD_QUEST::mutable_quest() {
  ::PROTOCOL::QuestInfo* _msg = _internal_mutable_quest();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_ADD_QUEST.quest)
  return _msg;
}
inline void C_ADD_QUEST::set_allocated_quest(::PROTOCOL::QuestInfo* quest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete quest_;
  }
  if (quest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::QuestInfo>::GetOwningArena(quest);
    if (message_arena != submessage_arena) {
      quest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quest, submessage_arena);
    }
    
  } else {
    
  }
  quest_ = quest;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_ADD_QUEST.quest)
}

// -------------------------------------------------------------------

// S_ADD_QUEST

// bool result = 1;
inline void S_ADD_QUEST::clear_result() {
  result_ = false;
}
inline bool S_ADD_QUEST::_internal_result() const {
  return result_;
}
inline bool S_ADD_QUEST::result() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_ADD_QUEST.result)
  return _internal_result();
}
inline void S_ADD_QUEST::_internal_set_result(bool value) {
  
  result_ = value;
}
inline void S_ADD_QUEST::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_ADD_QUEST.result)
}

// .PROTOCOL.QuestInfo quest = 2;
inline bool S_ADD_QUEST::_internal_has_quest() const {
  return this != internal_default_instance() && quest_ != nullptr;
}
inline bool S_ADD_QUEST::has_quest() const {
  return _internal_has_quest();
}
inline void S_ADD_QUEST::clear_quest() {
  if (GetArenaForAllocation() == nullptr && quest_ != nullptr) {
    delete quest_;
  }
  quest_ = nullptr;
}
inline const ::PROTOCOL::QuestInfo& S_ADD_QUEST::_internal_quest() const {
  const ::PROTOCOL::QuestInfo* p = quest_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::QuestInfo&>(
      ::PROTOCOL::_QuestInfo_default_instance_);
}
inline const ::PROTOCOL::QuestInfo& S_ADD_QUEST::quest() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_ADD_QUEST.quest)
  return _internal_quest();
}
inline void S_ADD_QUEST::unsafe_arena_set_allocated_quest(
    ::PROTOCOL::QuestInfo* quest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(quest_);
  }
  quest_ = quest;
  if (quest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_ADD_QUEST.quest)
}
inline ::PROTOCOL::QuestInfo* S_ADD_QUEST::release_quest() {
  
  ::PROTOCOL::QuestInfo* temp = quest_;
  quest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::QuestInfo* S_ADD_QUEST::unsafe_arena_release_quest() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_ADD_QUEST.quest)
  
  ::PROTOCOL::QuestInfo* temp = quest_;
  quest_ = nullptr;
  return temp;
}
inline ::PROTOCOL::QuestInfo* S_ADD_QUEST::_internal_mutable_quest() {
  
  if (quest_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::QuestInfo>(GetArenaForAllocation());
    quest_ = p;
  }
  return quest_;
}
inline ::PROTOCOL::QuestInfo* S_ADD_QUEST::mutable_quest() {
  ::PROTOCOL::QuestInfo* _msg = _internal_mutable_quest();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_ADD_QUEST.quest)
  return _msg;
}
inline void S_ADD_QUEST::set_allocated_quest(::PROTOCOL::QuestInfo* quest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete quest_;
  }
  if (quest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::QuestInfo>::GetOwningArena(quest);
    if (message_arena != submessage_arena) {
      quest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quest, submessage_arena);
    }
    
  } else {
    
  }
  quest_ = quest;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_ADD_QUEST.quest)
}

// -------------------------------------------------------------------

// S_QUESTLIST

// repeated .PROTOCOL.QuestInfo quests = 1;
inline int S_QUESTLIST::_internal_quests_size() const {
  return quests_.size();
}
inline int S_QUESTLIST::quests_size() const {
  return _internal_quests_size();
}
inline void S_QUESTLIST::clear_quests() {
  quests_.Clear();
}
inline ::PROTOCOL::QuestInfo* S_QUESTLIST::mutable_quests(int index) {
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_QUESTLIST.quests)
  return quests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::QuestInfo >*
S_QUESTLIST::mutable_quests() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.S_QUESTLIST.quests)
  return &quests_;
}
inline const ::PROTOCOL::QuestInfo& S_QUESTLIST::_internal_quests(int index) const {
  return quests_.Get(index);
}
inline const ::PROTOCOL::QuestInfo& S_QUESTLIST::quests(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_QUESTLIST.quests)
  return _internal_quests(index);
}
inline ::PROTOCOL::QuestInfo* S_QUESTLIST::_internal_add_quests() {
  return quests_.Add();
}
inline ::PROTOCOL::QuestInfo* S_QUESTLIST::add_quests() {
  ::PROTOCOL::QuestInfo* _add = _internal_add_quests();
  // @@protoc_insertion_point(field_add:PROTOCOL.S_QUESTLIST.quests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::QuestInfo >&
S_QUESTLIST::quests() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.S_QUESTLIST.quests)
  return quests_;
}

// -------------------------------------------------------------------

// C_REMOVE_QUEST

// int32 questdbid = 1;
inline void C_REMOVE_QUEST::clear_questdbid() {
  questdbid_ = 0;
}
inline int32_t C_REMOVE_QUEST::_internal_questdbid() const {
  return questdbid_;
}
inline int32_t C_REMOVE_QUEST::questdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_REMOVE_QUEST.questdbid)
  return _internal_questdbid();
}
inline void C_REMOVE_QUEST::_internal_set_questdbid(int32_t value) {
  
  questdbid_ = value;
}
inline void C_REMOVE_QUEST::set_questdbid(int32_t value) {
  _internal_set_questdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_REMOVE_QUEST.questdbid)
}

// -------------------------------------------------------------------

// S_REMOVE_QUEST

// bool result = 1;
inline void S_REMOVE_QUEST::clear_result() {
  result_ = false;
}
inline bool S_REMOVE_QUEST::_internal_result() const {
  return result_;
}
inline bool S_REMOVE_QUEST::result() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_REMOVE_QUEST.result)
  return _internal_result();
}
inline void S_REMOVE_QUEST::_internal_set_result(bool value) {
  
  result_ = value;
}
inline void S_REMOVE_QUEST::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_REMOVE_QUEST.result)
}

// int32 questid = 2;
inline void S_REMOVE_QUEST::clear_questid() {
  questid_ = 0;
}
inline int32_t S_REMOVE_QUEST::_internal_questid() const {
  return questid_;
}
inline int32_t S_REMOVE_QUEST::questid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_REMOVE_QUEST.questid)
  return _internal_questid();
}
inline void S_REMOVE_QUEST::_internal_set_questid(int32_t value) {
  
  questid_ = value;
}
inline void S_REMOVE_QUEST::set_questid(int32_t value) {
  _internal_set_questid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_REMOVE_QUEST.questid)
}

// -------------------------------------------------------------------

// C_COMPLETE_QUEST

// int32 questdbid = 1;
inline void C_COMPLETE_QUEST::clear_questdbid() {
  questdbid_ = 0;
}
inline int32_t C_COMPLETE_QUEST::_internal_questdbid() const {
  return questdbid_;
}
inline int32_t C_COMPLETE_QUEST::questdbid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_COMPLETE_QUEST.questdbid)
  return _internal_questdbid();
}
inline void C_COMPLETE_QUEST::_internal_set_questdbid(int32_t value) {
  
  questdbid_ = value;
}
inline void C_COMPLETE_QUEST::set_questdbid(int32_t value) {
  _internal_set_questdbid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_COMPLETE_QUEST.questdbid)
}

// -------------------------------------------------------------------

// S_COMPLETE_QUEST

// bool result = 1;
inline void S_COMPLETE_QUEST::clear_result() {
  result_ = false;
}
inline bool S_COMPLETE_QUEST::_internal_result() const {
  return result_;
}
inline bool S_COMPLETE_QUEST::result() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_COMPLETE_QUEST.result)
  return _internal_result();
}
inline void S_COMPLETE_QUEST::_internal_set_result(bool value) {
  
  result_ = value;
}
inline void S_COMPLETE_QUEST::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_COMPLETE_QUEST.result)
}

// int32 questid = 2;
inline void S_COMPLETE_QUEST::clear_questid() {
  questid_ = 0;
}
inline int32_t S_COMPLETE_QUEST::_internal_questid() const {
  return questid_;
}
inline int32_t S_COMPLETE_QUEST::questid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_COMPLETE_QUEST.questid)
  return _internal_questid();
}
inline void S_COMPLETE_QUEST::_internal_set_questid(int32_t value) {
  
  questid_ = value;
}
inline void S_COMPLETE_QUEST::set_questid(int32_t value) {
  _internal_set_questid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_COMPLETE_QUEST.questid)
}

// -------------------------------------------------------------------

// C_UPDATE_QUEST

// .PROTOCOL.QuestInfo questinfo = 1;
inline bool C_UPDATE_QUEST::_internal_has_questinfo() const {
  return this != internal_default_instance() && questinfo_ != nullptr;
}
inline bool C_UPDATE_QUEST::has_questinfo() const {
  return _internal_has_questinfo();
}
inline void C_UPDATE_QUEST::clear_questinfo() {
  if (GetArenaForAllocation() == nullptr && questinfo_ != nullptr) {
    delete questinfo_;
  }
  questinfo_ = nullptr;
}
inline const ::PROTOCOL::QuestInfo& C_UPDATE_QUEST::_internal_questinfo() const {
  const ::PROTOCOL::QuestInfo* p = questinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::QuestInfo&>(
      ::PROTOCOL::_QuestInfo_default_instance_);
}
inline const ::PROTOCOL::QuestInfo& C_UPDATE_QUEST::questinfo() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_UPDATE_QUEST.questinfo)
  return _internal_questinfo();
}
inline void C_UPDATE_QUEST::unsafe_arena_set_allocated_questinfo(
    ::PROTOCOL::QuestInfo* questinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(questinfo_);
  }
  questinfo_ = questinfo;
  if (questinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.C_UPDATE_QUEST.questinfo)
}
inline ::PROTOCOL::QuestInfo* C_UPDATE_QUEST::release_questinfo() {
  
  ::PROTOCOL::QuestInfo* temp = questinfo_;
  questinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::QuestInfo* C_UPDATE_QUEST::unsafe_arena_release_questinfo() {
  // @@protoc_insertion_point(field_release:PROTOCOL.C_UPDATE_QUEST.questinfo)
  
  ::PROTOCOL::QuestInfo* temp = questinfo_;
  questinfo_ = nullptr;
  return temp;
}
inline ::PROTOCOL::QuestInfo* C_UPDATE_QUEST::_internal_mutable_questinfo() {
  
  if (questinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::QuestInfo>(GetArenaForAllocation());
    questinfo_ = p;
  }
  return questinfo_;
}
inline ::PROTOCOL::QuestInfo* C_UPDATE_QUEST::mutable_questinfo() {
  ::PROTOCOL::QuestInfo* _msg = _internal_mutable_questinfo();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.C_UPDATE_QUEST.questinfo)
  return _msg;
}
inline void C_UPDATE_QUEST::set_allocated_questinfo(::PROTOCOL::QuestInfo* questinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete questinfo_;
  }
  if (questinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::QuestInfo>::GetOwningArena(questinfo);
    if (message_arena != submessage_arena) {
      questinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, questinfo, submessage_arena);
    }
    
  } else {
    
  }
  questinfo_ = questinfo;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.C_UPDATE_QUEST.questinfo)
}

// int32 objectid = 2;
inline void C_UPDATE_QUEST::clear_objectid() {
  objectid_ = 0;
}
inline int32_t C_UPDATE_QUEST::_internal_objectid() const {
  return objectid_;
}
inline int32_t C_UPDATE_QUEST::objectid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_UPDATE_QUEST.objectid)
  return _internal_objectid();
}
inline void C_UPDATE_QUEST::_internal_set_objectid(int32_t value) {
  
  objectid_ = value;
}
inline void C_UPDATE_QUEST::set_objectid(int32_t value) {
  _internal_set_objectid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_UPDATE_QUEST.objectid)
}

// -------------------------------------------------------------------

// S_UPDATE_QUEST

// .PROTOCOL.QuestInfo questInfo = 1;
inline bool S_UPDATE_QUEST::_internal_has_questinfo() const {
  return this != internal_default_instance() && questinfo_ != nullptr;
}
inline bool S_UPDATE_QUEST::has_questinfo() const {
  return _internal_has_questinfo();
}
inline void S_UPDATE_QUEST::clear_questinfo() {
  if (GetArenaForAllocation() == nullptr && questinfo_ != nullptr) {
    delete questinfo_;
  }
  questinfo_ = nullptr;
}
inline const ::PROTOCOL::QuestInfo& S_UPDATE_QUEST::_internal_questinfo() const {
  const ::PROTOCOL::QuestInfo* p = questinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::QuestInfo&>(
      ::PROTOCOL::_QuestInfo_default_instance_);
}
inline const ::PROTOCOL::QuestInfo& S_UPDATE_QUEST::questinfo() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_UPDATE_QUEST.questInfo)
  return _internal_questinfo();
}
inline void S_UPDATE_QUEST::unsafe_arena_set_allocated_questinfo(
    ::PROTOCOL::QuestInfo* questinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(questinfo_);
  }
  questinfo_ = questinfo;
  if (questinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.S_UPDATE_QUEST.questInfo)
}
inline ::PROTOCOL::QuestInfo* S_UPDATE_QUEST::release_questinfo() {
  
  ::PROTOCOL::QuestInfo* temp = questinfo_;
  questinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::QuestInfo* S_UPDATE_QUEST::unsafe_arena_release_questinfo() {
  // @@protoc_insertion_point(field_release:PROTOCOL.S_UPDATE_QUEST.questInfo)
  
  ::PROTOCOL::QuestInfo* temp = questinfo_;
  questinfo_ = nullptr;
  return temp;
}
inline ::PROTOCOL::QuestInfo* S_UPDATE_QUEST::_internal_mutable_questinfo() {
  
  if (questinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::QuestInfo>(GetArenaForAllocation());
    questinfo_ = p;
  }
  return questinfo_;
}
inline ::PROTOCOL::QuestInfo* S_UPDATE_QUEST::mutable_questinfo() {
  ::PROTOCOL::QuestInfo* _msg = _internal_mutable_questinfo();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.S_UPDATE_QUEST.questInfo)
  return _msg;
}
inline void S_UPDATE_QUEST::set_allocated_questinfo(::PROTOCOL::QuestInfo* questinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete questinfo_;
  }
  if (questinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::QuestInfo>::GetOwningArena(questinfo);
    if (message_arena != submessage_arena) {
      questinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, questinfo, submessage_arena);
    }
    
  } else {
    
  }
  questinfo_ = questinfo;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.S_UPDATE_QUEST.questInfo)
}

// -------------------------------------------------------------------

// C_TEST

// int32 testint = 1;
inline void C_TEST::clear_testint() {
  testint_ = 0;
}
inline int32_t C_TEST::_internal_testint() const {
  return testint_;
}
inline int32_t C_TEST::testint() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_TEST.testint)
  return _internal_testint();
}
inline void C_TEST::_internal_set_testint(int32_t value) {
  
  testint_ = value;
}
inline void C_TEST::set_testint(int32_t value) {
  _internal_set_testint(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_TEST.testint)
}

// bool testbool = 2;
inline void C_TEST::clear_testbool() {
  testbool_ = false;
}
inline bool C_TEST::_internal_testbool() const {
  return testbool_;
}
inline bool C_TEST::testbool() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_TEST.testbool)
  return _internal_testbool();
}
inline void C_TEST::_internal_set_testbool(bool value) {
  
  testbool_ = value;
}
inline void C_TEST::set_testbool(bool value) {
  _internal_set_testbool(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_TEST.testbool)
}

// -------------------------------------------------------------------

// S_TEST

// int32 testint = 1;
inline void S_TEST::clear_testint() {
  testint_ = 0;
}
inline int32_t S_TEST::_internal_testint() const {
  return testint_;
}
inline int32_t S_TEST::testint() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_TEST.testint)
  return _internal_testint();
}
inline void S_TEST::_internal_set_testint(int32_t value) {
  
  testint_ = value;
}
inline void S_TEST::set_testint(int32_t value) {
  _internal_set_testint(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_TEST.testint)
}

// bool testbool = 2;
inline void S_TEST::clear_testbool() {
  testbool_ = false;
}
inline bool S_TEST::_internal_testbool() const {
  return testbool_;
}
inline bool S_TEST::testbool() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.S_TEST.testbool)
  return _internal_testbool();
}
inline void S_TEST::_internal_set_testbool(bool value) {
  
  testbool_ = value;
}
inline void S_TEST::set_testbool(bool value) {
  _internal_set_testbool(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.S_TEST.testbool)
}

// -------------------------------------------------------------------

// C_BOT_LOGIN

// bool test = 1;
inline void C_BOT_LOGIN::clear_test() {
  test_ = false;
}
inline bool C_BOT_LOGIN::_internal_test() const {
  return test_;
}
inline bool C_BOT_LOGIN::test() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.C_BOT_LOGIN.test)
  return _internal_test();
}
inline void C_BOT_LOGIN::_internal_set_test(bool value) {
  
  test_ = value;
}
inline void C_BOT_LOGIN::set_test(bool value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.C_BOT_LOGIN.test)
}

// -------------------------------------------------------------------

// PFVector

// float x = 1;
inline void PFVector::clear_x() {
  x_ = 0;
}
inline float PFVector::_internal_x() const {
  return x_;
}
inline float PFVector::x() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.PFVector.x)
  return _internal_x();
}
inline void PFVector::_internal_set_x(float value) {
  
  x_ = value;
}
inline void PFVector::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.PFVector.x)
}

// float y = 2;
inline void PFVector::clear_y() {
  y_ = 0;
}
inline float PFVector::_internal_y() const {
  return y_;
}
inline float PFVector::y() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.PFVector.y)
  return _internal_y();
}
inline void PFVector::_internal_set_y(float value) {
  
  y_ = value;
}
inline void PFVector::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.PFVector.y)
}

// float z = 3;
inline void PFVector::clear_z() {
  z_ = 0;
}
inline float PFVector::_internal_z() const {
  return z_;
}
inline float PFVector::z() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.PFVector.z)
  return _internal_z();
}
inline void PFVector::_internal_set_z(float value) {
  
  z_ = value;
}
inline void PFVector::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.PFVector.z)
}

// -------------------------------------------------------------------

// AI_C_PATHFIND

// int32 monsterid = 1;
inline void AI_C_PATHFIND::clear_monsterid() {
  monsterid_ = 0;
}
inline int32_t AI_C_PATHFIND::_internal_monsterid() const {
  return monsterid_;
}
inline int32_t AI_C_PATHFIND::monsterid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.AI_C_PATHFIND.monsterid)
  return _internal_monsterid();
}
inline void AI_C_PATHFIND::_internal_set_monsterid(int32_t value) {
  
  monsterid_ = value;
}
inline void AI_C_PATHFIND::set_monsterid(int32_t value) {
  _internal_set_monsterid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.AI_C_PATHFIND.monsterid)
}

// int32 mapid = 2;
inline void AI_C_PATHFIND::clear_mapid() {
  mapid_ = 0;
}
inline int32_t AI_C_PATHFIND::_internal_mapid() const {
  return mapid_;
}
inline int32_t AI_C_PATHFIND::mapid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.AI_C_PATHFIND.mapid)
  return _internal_mapid();
}
inline void AI_C_PATHFIND::_internal_set_mapid(int32_t value) {
  
  mapid_ = value;
}
inline void AI_C_PATHFIND::set_mapid(int32_t value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.AI_C_PATHFIND.mapid)
}

// .PROTOCOL.PFVector sp = 3;
inline bool AI_C_PATHFIND::_internal_has_sp() const {
  return this != internal_default_instance() && sp_ != nullptr;
}
inline bool AI_C_PATHFIND::has_sp() const {
  return _internal_has_sp();
}
inline void AI_C_PATHFIND::clear_sp() {
  if (GetArenaForAllocation() == nullptr && sp_ != nullptr) {
    delete sp_;
  }
  sp_ = nullptr;
}
inline const ::PROTOCOL::PFVector& AI_C_PATHFIND::_internal_sp() const {
  const ::PROTOCOL::PFVector* p = sp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::PFVector&>(
      ::PROTOCOL::_PFVector_default_instance_);
}
inline const ::PROTOCOL::PFVector& AI_C_PATHFIND::sp() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.AI_C_PATHFIND.sp)
  return _internal_sp();
}
inline void AI_C_PATHFIND::unsafe_arena_set_allocated_sp(
    ::PROTOCOL::PFVector* sp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sp_);
  }
  sp_ = sp;
  if (sp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.AI_C_PATHFIND.sp)
}
inline ::PROTOCOL::PFVector* AI_C_PATHFIND::release_sp() {
  
  ::PROTOCOL::PFVector* temp = sp_;
  sp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::PFVector* AI_C_PATHFIND::unsafe_arena_release_sp() {
  // @@protoc_insertion_point(field_release:PROTOCOL.AI_C_PATHFIND.sp)
  
  ::PROTOCOL::PFVector* temp = sp_;
  sp_ = nullptr;
  return temp;
}
inline ::PROTOCOL::PFVector* AI_C_PATHFIND::_internal_mutable_sp() {
  
  if (sp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::PFVector>(GetArenaForAllocation());
    sp_ = p;
  }
  return sp_;
}
inline ::PROTOCOL::PFVector* AI_C_PATHFIND::mutable_sp() {
  ::PROTOCOL::PFVector* _msg = _internal_mutable_sp();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.AI_C_PATHFIND.sp)
  return _msg;
}
inline void AI_C_PATHFIND::set_allocated_sp(::PROTOCOL::PFVector* sp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sp_;
  }
  if (sp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::PFVector>::GetOwningArena(sp);
    if (message_arena != submessage_arena) {
      sp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sp, submessage_arena);
    }
    
  } else {
    
  }
  sp_ = sp;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.AI_C_PATHFIND.sp)
}

// .PROTOCOL.PFVector ep = 4;
inline bool AI_C_PATHFIND::_internal_has_ep() const {
  return this != internal_default_instance() && ep_ != nullptr;
}
inline bool AI_C_PATHFIND::has_ep() const {
  return _internal_has_ep();
}
inline void AI_C_PATHFIND::clear_ep() {
  if (GetArenaForAllocation() == nullptr && ep_ != nullptr) {
    delete ep_;
  }
  ep_ = nullptr;
}
inline const ::PROTOCOL::PFVector& AI_C_PATHFIND::_internal_ep() const {
  const ::PROTOCOL::PFVector* p = ep_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOCOL::PFVector&>(
      ::PROTOCOL::_PFVector_default_instance_);
}
inline const ::PROTOCOL::PFVector& AI_C_PATHFIND::ep() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.AI_C_PATHFIND.ep)
  return _internal_ep();
}
inline void AI_C_PATHFIND::unsafe_arena_set_allocated_ep(
    ::PROTOCOL::PFVector* ep) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ep_);
  }
  ep_ = ep;
  if (ep) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PROTOCOL.AI_C_PATHFIND.ep)
}
inline ::PROTOCOL::PFVector* AI_C_PATHFIND::release_ep() {
  
  ::PROTOCOL::PFVector* temp = ep_;
  ep_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOCOL::PFVector* AI_C_PATHFIND::unsafe_arena_release_ep() {
  // @@protoc_insertion_point(field_release:PROTOCOL.AI_C_PATHFIND.ep)
  
  ::PROTOCOL::PFVector* temp = ep_;
  ep_ = nullptr;
  return temp;
}
inline ::PROTOCOL::PFVector* AI_C_PATHFIND::_internal_mutable_ep() {
  
  if (ep_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOCOL::PFVector>(GetArenaForAllocation());
    ep_ = p;
  }
  return ep_;
}
inline ::PROTOCOL::PFVector* AI_C_PATHFIND::mutable_ep() {
  ::PROTOCOL::PFVector* _msg = _internal_mutable_ep();
  // @@protoc_insertion_point(field_mutable:PROTOCOL.AI_C_PATHFIND.ep)
  return _msg;
}
inline void AI_C_PATHFIND::set_allocated_ep(::PROTOCOL::PFVector* ep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ep_;
  }
  if (ep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PROTOCOL::PFVector>::GetOwningArena(ep);
    if (message_arena != submessage_arena) {
      ep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ep, submessage_arena);
    }
    
  } else {
    
  }
  ep_ = ep;
  // @@protoc_insertion_point(field_set_allocated:PROTOCOL.AI_C_PATHFIND.ep)
}

// bool random = 5;
inline void AI_C_PATHFIND::clear_random() {
  random_ = false;
}
inline bool AI_C_PATHFIND::_internal_random() const {
  return random_;
}
inline bool AI_C_PATHFIND::random() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.AI_C_PATHFIND.random)
  return _internal_random();
}
inline void AI_C_PATHFIND::_internal_set_random(bool value) {
  
  random_ = value;
}
inline void AI_C_PATHFIND::set_random(bool value) {
  _internal_set_random(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.AI_C_PATHFIND.random)
}

// float radius = 6;
inline void AI_C_PATHFIND::clear_radius() {
  radius_ = 0;
}
inline float AI_C_PATHFIND::_internal_radius() const {
  return radius_;
}
inline float AI_C_PATHFIND::radius() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.AI_C_PATHFIND.radius)
  return _internal_radius();
}
inline void AI_C_PATHFIND::_internal_set_radius(float value) {
  
  radius_ = value;
}
inline void AI_C_PATHFIND::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.AI_C_PATHFIND.radius)
}

// -------------------------------------------------------------------

// AI_S_PATHFIND

// int32 monsterid = 1;
inline void AI_S_PATHFIND::clear_monsterid() {
  monsterid_ = 0;
}
inline int32_t AI_S_PATHFIND::_internal_monsterid() const {
  return monsterid_;
}
inline int32_t AI_S_PATHFIND::monsterid() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.AI_S_PATHFIND.monsterid)
  return _internal_monsterid();
}
inline void AI_S_PATHFIND::_internal_set_monsterid(int32_t value) {
  
  monsterid_ = value;
}
inline void AI_S_PATHFIND::set_monsterid(int32_t value) {
  _internal_set_monsterid(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.AI_S_PATHFIND.monsterid)
}

// bool result = 2;
inline void AI_S_PATHFIND::clear_result() {
  result_ = false;
}
inline bool AI_S_PATHFIND::_internal_result() const {
  return result_;
}
inline bool AI_S_PATHFIND::result() const {
  // @@protoc_insertion_point(field_get:PROTOCOL.AI_S_PATHFIND.result)
  return _internal_result();
}
inline void AI_S_PATHFIND::_internal_set_result(bool value) {
  
  result_ = value;
}
inline void AI_S_PATHFIND::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:PROTOCOL.AI_S_PATHFIND.result)
}

// repeated .PROTOCOL.PFVector paths = 3;
inline int AI_S_PATHFIND::_internal_paths_size() const {
  return paths_.size();
}
inline int AI_S_PATHFIND::paths_size() const {
  return _internal_paths_size();
}
inline void AI_S_PATHFIND::clear_paths() {
  paths_.Clear();
}
inline ::PROTOCOL::PFVector* AI_S_PATHFIND::mutable_paths(int index) {
  // @@protoc_insertion_point(field_mutable:PROTOCOL.AI_S_PATHFIND.paths)
  return paths_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::PFVector >*
AI_S_PATHFIND::mutable_paths() {
  // @@protoc_insertion_point(field_mutable_list:PROTOCOL.AI_S_PATHFIND.paths)
  return &paths_;
}
inline const ::PROTOCOL::PFVector& AI_S_PATHFIND::_internal_paths(int index) const {
  return paths_.Get(index);
}
inline const ::PROTOCOL::PFVector& AI_S_PATHFIND::paths(int index) const {
  // @@protoc_insertion_point(field_get:PROTOCOL.AI_S_PATHFIND.paths)
  return _internal_paths(index);
}
inline ::PROTOCOL::PFVector* AI_S_PATHFIND::_internal_add_paths() {
  return paths_.Add();
}
inline ::PROTOCOL::PFVector* AI_S_PATHFIND::add_paths() {
  ::PROTOCOL::PFVector* _add = _internal_add_paths();
  // @@protoc_insertion_point(field_add:PROTOCOL.AI_S_PATHFIND.paths)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOCOL::PFVector >&
AI_S_PATHFIND::paths() const {
  // @@protoc_insertion_point(field_list:PROTOCOL.AI_S_PATHFIND.paths)
  return paths_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace PROTOCOL

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::PROTOCOL::MsgId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PROTOCOL::MsgId>() {
  return ::PROTOCOL::MsgId_descriptor();
}
template <> struct is_proto_enum< ::PROTOCOL::PlayerServerState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PROTOCOL::PlayerServerState>() {
  return ::PROTOCOL::PlayerServerState_descriptor();
}
template <> struct is_proto_enum< ::PROTOCOL::GameObjectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PROTOCOL::GameObjectType>() {
  return ::PROTOCOL::GameObjectType_descriptor();
}
template <> struct is_proto_enum< ::PROTOCOL::SkillType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PROTOCOL::SkillType>() {
  return ::PROTOCOL::SkillType_descriptor();
}
template <> struct is_proto_enum< ::PROTOCOL::ItemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PROTOCOL::ItemType>() {
  return ::PROTOCOL::ItemType_descriptor();
}
template <> struct is_proto_enum< ::PROTOCOL::WeaponType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PROTOCOL::WeaponType>() {
  return ::PROTOCOL::WeaponType_descriptor();
}
template <> struct is_proto_enum< ::PROTOCOL::ArmorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PROTOCOL::ArmorType>() {
  return ::PROTOCOL::ArmorType_descriptor();
}
template <> struct is_proto_enum< ::PROTOCOL::ConsumableType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PROTOCOL::ConsumableType>() {
  return ::PROTOCOL::ConsumableType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol3_2eproto
